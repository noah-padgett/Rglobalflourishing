0.1**2
# Script: main.R#
# Created by: R. Noah Padgett#
# Last edited on: 2024-01-02#
#
# WARNING: The package was set up to be user-friendly for researchers part of the GFS core#
#   team who mainly have experience with other statistical analysis software such as STATA,#
#   SAS, and SPSS. This package and implementation of the analyses for Wave 2 of the Global#
#   Flourishing Study does NOT conform to "tidy" principles in general. While some elements of tidy#
#   evaluation and syntax structure are used throughout, we did not implement everything with#
#   "tidyness" in mind. As such, we make no guarantees that the package will integrate or#
#   "play nice" with other packages.#
#
# install.packages("remotes")#
#remotes::install_github("noah-padgett/Rglobalflourishing")#
#library(Rglobalflourishing)#
#
# Analysis Set-Up#
#
# Add the directory where the dataset is stored on your computer#
data.dir <- "/Users/noahp/Documents/GitHub/global-flourishing-study/data/wave1-data"#
dataset.name <- "gfs_all_countries_wave1.sav"#
#
# Specify where you want to output results#
# Can be left blank, and the results will output to the same directory as the data.#
out.dir <- "/Users/noahp/Documents/GitHub/global-flourishing-study/3-Rglobalflourishing"#
#
# Here is YOUR wave 1 construct variable#
FOCAL_PREDICTOR <- "PHYSICAL_HLTH_W1"#
FOCAL_PREDICTOR_BETTER_NAME <- "Self-rated physical health"#
FOCAL_PREDICTOR_REFERENCE_VALE <- "estimate population mean of self rated physical health"#
#
# IF your predictor is binary/categorical, use the code below to define how you want it to be#
# 	categorized. Categorization must result in a binary variable 0/1 for consistency across studies.#
# 	Please report how you have categorized your variable to Noah (npadgett@hsph.harvard.edu)#
VALUES_DEFINING_UPPER_CATEGORY <- c(NULL)#
VALUES_DEFINING_LOWER_CATEGORY <- c(NULL)#
# Note 1: if your focal predictor is continuous (all items with 7+ response options), you can force the responses#
# 	to be categorized as 0/1 using the above with the below option changed to TRUE. This can be useful#
# 	when testing the sensitivity of results or for composite outcomes such as anxiety (sum of#
# feel_anxious and control_worry)  or depression (sum of depressed and interest) that have a#
# 	history of being dichotomized.#
FORCE_BINARY <- FALSE#
# Note 2: if your focal predictor is categorical/binary, you can use the responses as if they were continuous.#
# 	This can be done in several ways, but the provided (straightforward-ish) approach is to reverse#
# 	code all ordered-categorical variables (reverse code from what is reported in the codebook), and#
# standardized as if continuous. This approach is not applicable for variables with nominal#
# response categories such as employment. This is employed using the option below.#
FORCE_CONTINUOUS <- FALSE
if (is.null(out.dir)) {#
    out.dir <- data.dir#
  }#
  # setwd(out.dir)#
  # Note:#
  # The following function loads the required packages for the remainder of the script to work.#
  load_packages()#
  # global options#
  options(#
    survey.lonely.psu = "certainty"#
  )
devtools::load_all()
if (is.null(out.dir)) {#
    out.dir <- data.dir#
  }#
  # setwd(out.dir)#
  # Note:#
  # The following function loads the required packages for the remainder of the script to work.#
  load_packages()#
  # global options#
  options(#
    survey.lonely.psu = "certainty"#
  )
# outcome vectors#
  OUTCOME.VEC <- get_variable_codes()[['OUTCOME.VEC']]#
  LIST.COMPOSITES <- get_variable_codes()[['LIST.COMPOSITES']]#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC <- get_variable_codes()[['DEMOGRAPHICS.CHILDHOOD.PRED.VEC']]
OUTCOME.VEC
devtools::load_all()
OUTCOME.VEC <- get_variable_codes()[['OUTCOME.VEC']]#
  LIST.COMPOSITES <- get_variable_codes()[['LIST.COMPOSITES']]#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC <- get_variable_codes()[['DEMOGRAPHICS.CHILDHOOD.PRED.VEC']]
load(here::here(data.dir, "gfs_imputed_data_test.RData"))#
  # ~~#
  RECODE.DEFAULTS <- list(#
    FOCAL_PREDICTOR = FOCAL_PREDICTOR,#
    DEMOGRAPHICS.CHILDHOOD.PRED.VEC = DEMOGRAPHICS.CHILDHOOD.PRED.VEC,#
    OUTCOME.VEC = OUTCOME.VEC,#
    FORCE_BINARY = FORCE_BINARY,#
    FORCE_CONTINUOUS = FORCE_CONTINUOUS,#
    VALUES_DEFINING_UPPER_CATEGORY = VALUES_DEFINING_UPPER_CATEGORY,#
    VALUES_DEFINING_LOWER_CATEGORY = VALUES_DEFINING_LOWER_CATEGORY,#
    USE_DEFAULT = !(FORCE_BINARY | FORCE_CONTINUOUS)#
  )#
  df.imp.long <- recode_imputed_data(#
    df.imp,#
    list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES#
  )
devtools::load_all()
df.imp.long <- recode_imputed_data(#
    df.imp,#
    list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES#
  )
devtools::load_all()
OUTCOME.VEC <- get_variable_codes()[['OUTCOME.VEC']]#
  LIST.COMPOSITES <- get_variable_codes()[['LIST.COMPOSITES']]#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC <- get_variable_codes()[['DEMOGRAPHICS.CHILDHOOD.PRED.VEC']]
OUTCOME.VEC
load(here::here(data.dir, "gfs_imputed_data_test.RData"))#
  # ~~#
  RECODE.DEFAULTS <- list(#
    FOCAL_PREDICTOR = FOCAL_PREDICTOR,#
    DEMOGRAPHICS.CHILDHOOD.PRED.VEC = DEMOGRAPHICS.CHILDHOOD.PRED.VEC,#
    OUTCOME.VEC = OUTCOME.VEC,#
    FORCE_BINARY = FORCE_BINARY,#
    FORCE_CONTINUOUS = FORCE_CONTINUOUS,#
    VALUES_DEFINING_UPPER_CATEGORY = VALUES_DEFINING_UPPER_CATEGORY,#
    VALUES_DEFINING_LOWER_CATEGORY = VALUES_DEFINING_LOWER_CATEGORY,#
    USE_DEFAULT = !(FORCE_BINARY | FORCE_CONTINUOUS)#
  )#
  df.imp.long <- recode_imputed_data(#
    df.imp,#
    list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES#
  )
table(df.imp.long$HAPPY_W2, useNA="always")#
table(df.imp.long$HAPPY_W2, df.imp.long$HAPPY_W1, useNA="always")
DEMO.CHILDHOOD.PRED <-#
  c(#
    "COV_AGE_GRP_W1",#
    "COV_GENDER_W1",#
    "COV_EDUCATION_3_W1",#
    "COV_EMPLOYMENT_W1",#
    "COV_MARITAL_STATUS_W1",#
    "COV_ATTEND_SVCS_W1",#
    "COV_BORN_COUNTRY_W1",#
    "COV_PARENTS_12YRS_W1",#
    "COV_SVCS_12YRS_W1",#
    "COV_MOTHER_RELATN_W1",#
    "COV_FATHER_RELATN_W1",#
    "COV_OUTSIDER_W1",#
    "COV_ABUSED_W1",#
    "COV_HEALTH_GROWUP_W1",#
    "COV_INCOME_12YRS_W1",#
    "COV_REL1_W1",#
    "COV_RACE_PLURALITY",#
    "COV_MOTHER_NA",#
    "COV_FATHER_NA"#
  )#
CONTEMPORANEOUS.EXPOSURES.VEC <- OUTCOME.VEC[str_detect(OUTCOME.VEC, "COMPOSITE", negate = TRUE)]#
CONTEMPORANEOUS.EXPOSURES.VEC <- CONTEMPORANEOUS.EXPOSURES.VEC[str_detect(CONTEMPORANEOUS.EXPOSURES.VEC, "_W1")]
# Run country-specific regression analyses for ALL wave 2 outcomes#
OUTCOME.VEC0 <- OUTCOME.VEC[str_detect(OUTCOME.VEC, "_W2")]
OUTCOME.VEC0
table(df.imp.long$COMPOSITE_DEPRESSION_W2)
table(df.imp.long$COMPOSITE_DEPRESSION_W2, useNA="always")
LIST.COMPOSITES
OUTCOME.VEC0 <- OUTCOME.VEC[str_detect(OUTCOME.VEC, "_W2")] # c(1, 8, 24)+76,#
your.outcome <- OUTCOME.VEC0[1]#
#
# Analysis set 1: Run without principal components#
LIST.RES1 <- map(OUTCOME.VEC0, \(x){#
  gfs_run_regression_single_outcome(#
    data = df.imp.long,#
    your.pred = FOCAL_PREDICTOR,#
    your.outcome = x,#
    covariates = DEMO.CHILDHOOD.PRED,#
    contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
    list.composites = LIST.COMPOSITES[[1]],#
    # advanced options: only change if you know what you are doing#
    standardize = TRUE,#
    res.dir = "results-wopc",#
    pc.rule = "omit"#
  )#
}, .progress = TRUE)#
#
# Analysis set 2: Run with principal components#
LIST.RES2 <- map(OUTCOME.VEC0, \(x){#
  gfs_run_regression_single_outcome(#
    data = df.imp.long,#
    your.pred = FOCAL_PREDICTOR,#
    your.outcome = x,#
    covariates = DEMO.CHILDHOOD.PRED,#
    contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
    list.composites = LIST.COMPOSITES[[1]],#
    # advanced options: only change if you know what you are doing#
    standardize = TRUE,#
    res.dir = "results-wpc",#
    pc.cutoff = 7,#
    pc.rule = "constant"#
  )#
}, .progress = TRUE)
OUTCOME0
OUTCOME.VEC0
data = df.imp.long
OUTCOME.VEC0[15]
OUTCOME.VEC0[16]
your.outcome <- OUTCOME.VEC0[16]
your.outcome
your.outcome <- OUTCOME.VEC0[17]
your.outcome
devtools::load_all()
OUTCOME.VEC0[-c(1:16)]
LIST.RES1 <- map(OUTCOME.VEC0[-c(1:16)], \(x){#
  gfs_run_regression_single_outcome(#
    data = df.imp.long,#
    your.pred = FOCAL_PREDICTOR,#
    your.outcome = x,#
    covariates = DEMO.CHILDHOOD.PRED,#
    contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
    list.composites = LIST.COMPOSITES[[1]],#
    # advanced options: only change if you know what you are doing#
    standardize = TRUE,#
    res.dir = "results-wopc",#
    pc.rule = "omit"#
  )#
}, .progress = TRUE)
data <- data %>%#
          dplyr::filter(str_detect(COUNTRY2,"Egypt", negate=TRUE))
table(data$COUNTRY2)
devtools::load_all()
LIST.RES1 <- map(OUTCOME.VEC0, \(x){#
  gfs_run_regression_single_outcome(#
    data = df.imp.long,#
    your.pred = FOCAL_PREDICTOR,#
    your.outcome = x,#
    covariates = DEMO.CHILDHOOD.PRED,#
    contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
    list.composites = LIST.COMPOSITES[[1]],#
    # advanced options: only change if you know what you are doing#
    standardize = TRUE,#
    res.dir = "results-wopc",#
    pc.rule = "omit"#
  )#
}, .progress = TRUE)
LIST.RES2 <- map(OUTCOME.VEC0, \(x){#
  gfs_run_regression_single_outcome(#
    data = df.imp.long,#
    your.pred = FOCAL_PREDICTOR,#
    your.outcome = x,#
    covariates = DEMO.CHILDHOOD.PRED,#
    contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
    list.composites = LIST.COMPOSITES[[1]],#
    # advanced options: only change if you know what you are doing#
    standardize = TRUE,#
    res.dir = "results-wpc",#
    pc.cutoff = 7,#
    pc.rule = "constant"#
  )#
}, .progress = TRUE)
{#
# Analysis set 1: country-specific results without adjusting for principal components#
LIST.RES1 <- construct_meta_input_from_saved_results("results-wopc", OUTCOME.VEC0, FOCAL_PREDICTOR)#
meta.input <- LIST.RES1 %>%#
  bind_rows() %>%#
  mutate(OUTCOME0 = OUTCOME) %>%#
  group_by(OUTCOME0) %>%#
  nest()#
#
META.RES1 <- gfs_meta_analysis(#
  meta.input,#
  better.name = FOCAL_PREDICTOR_BETTER_NAME,#
  p.subtitle = "Principal components excluded"#
)#
readr::write_rds(#
  META.RES1,#
  file = here::here(out.dir, "results-wopc", "0_meta_analyzed_results_wopc.rds"),#
  compress = "gz"#
)#
#
# Analysis set 2: country-specific results adjusting for principal components#
LIST.RES2 <- construct_meta_input_from_saved_results("results-wpc", OUTCOME.VEC0, FOCAL_PREDICTOR)#
meta.input <- LIST.RES2 %>%#
  bind_rows() %>%#
  mutate(OUTCOME0 = OUTCOME) %>%#
  group_by(OUTCOME0) %>%#
  nest()#
#
META.RES2 <- gfs_meta_analysis(#
  meta.input,#
  better.name = FOCAL_PREDICTOR_BETTER_NAME,#
  p.subtitle = "Principal components included"#
)#
#
readr::write_rds(#
  META.RES2,#
  file = here::here(out.dir, "results-wpc","0_meta_analyzed_results_wpc.rds"),#
  compress = "gz"#
)#
}#
# ================================================================================================ ##
# ================================================================================================ ##
# Construct manuscript tables#
# TO-DO#
#
df.raw <- gfs_get_labelled_raw_data(#
  here::here(data.dir, dataset.name),#
  list.composites = LIST.COMPOSITES,#
  add.whitespace = TRUE#
)#
#
COUN.RES.WOPC <- get_country_specific_regression_results("results-wopc", OUTCOME.VEC0, FOCAL_PREDICTOR)#
COUN.RES.WPC <- get_country_specific_regression_results("results-wpc", OUTCOME.VEC0, FOCAL_PREDICTOR)#
FIT.PCA.SUM <- get_country_specific_pca_summary("results-wpc", OUTCOME.VEC0, FOCAL_PREDICTOR)#
# also need: META.RES1, META.RES2#
#focal.predictor.reference.value = FOCAL_PREDICTOR_REFERENCE_VALE#
# main text#
gfs_generate_main_doc(#
	META.RES1, META.RES2,#
	focal.predictor=FOCAL_PREDICTOR,#
	focal.better.name=FOCAL_PREDICTOR_BETTER_NAME, #
	focal.predictor.reference.value=FOCAL_PREDICTOR_REFERENCE_VALE, #
	res.dir = "results"	#
)#
gfs_generate_supplemental_docs(#
	meta.wopc=META.RES1, meta.wpc=META.RES2,#
	 coun.wopc=COUN.RES.WOPC , coun.wpc=COUN.RES.WPC ,#
	 coun.fit.pca = FIT.PCA.SUM ,#
	focal.predictor=FOCAL_PREDICTOR,#
	focal.better.name=FOCAL_PREDICTOR_BETTER_NAME, #
	focal.predictor.reference.value=FOCAL_PREDICTOR_REFERENCE_VALE, #
	res.dir = "results")
devtools::load_all()
devtools::load_all()
gfs_generate_supplemental_docs(#
	meta.wopc=META.RES1, meta.wpc=META.RES2,#
	 coun.wopc=COUN.RES.WOPC , coun.wpc=COUN.RES.WPC ,#
	 coun.fit.pca = FIT.PCA.SUM ,#
	focal.predictor=FOCAL_PREDICTOR,#
	focal.better.name=FOCAL_PREDICTOR_BETTER_NAME, #
	focal.predictor.reference.value=FOCAL_PREDICTOR_REFERENCE_VALE, #
	res.dir = "results")
devtools::load_all()
# main text#
gfs_generate_main_doc(#
	META.RES1, META.RES2,#
	focal.predictor=FOCAL_PREDICTOR,#
	focal.better.name=FOCAL_PREDICTOR_BETTER_NAME, #
	focal.predictor.reference.value=FOCAL_PREDICTOR_REFERENCE_VALE, #
	res.dir = "results"	#
)#
gfs_generate_supplemental_docs(#
	meta.wopc=META.RES1, meta.wpc=META.RES2,#
	 coun.wopc=COUN.RES.WOPC , coun.wpc=COUN.RES.WPC ,#
	 coun.fit.pca = FIT.PCA.SUM ,#
	focal.predictor=FOCAL_PREDICTOR,#
	focal.better.name=FOCAL_PREDICTOR_BETTER_NAME, #
	focal.predictor.reference.value=FOCAL_PREDICTOR_REFERENCE_VALE, #
	res.dir = "results")
COUN.RES.WOPC
META.RES1
colnames(META.RES1)
devtools::load_all()
gfs_generate_supplemental_docs(#
	meta.wopc=META.RES1, meta.wpc=META.RES2,#
	 coun.wopc=COUN.RES.WOPC , coun.wpc=COUN.RES.WPC ,#
	 coun.fit.pca = FIT.PCA.SUM ,#
	focal.predictor=FOCAL_PREDICTOR,#
	focal.better.name=FOCAL_PREDICTOR_BETTER_NAME, #
	focal.predictor.reference.value=FOCAL_PREDICTOR_REFERENCE_VALE, #
	res.dir = "results")
ls()
coun.wopc=COUN.RES.WOPC
coun.wpc=COUN.RES.WPC
coun.fit.pca = FIT.PCA.SUM
focal.predictor=FOCAL_PREDICTOR
focal.better.name=FOCAL_PREDICTOR_BETTER_NAME
focal.predictor.reference.value=FOCAL_PREDICTOR_REFERENCE_VALE
included.countries=NULL
res.dir = "results"
mylabels = NULL
outcome.vec = NULL
baseline.pred = NULL
p.bonferroni = NULL
meta.wopc=META.RES1
meta.wpc=META.RES2
focal.predictor0 <- str_remove(focal.predictor,"_W1")#
#
  if(is.null(p.bonferroni)){#
    p.bonferroni = 0.05/nrow(coun.wopc)#
  }#
  if(is.null(baseline.pred)){#
    baseline.pred = str_remove(#
      c(#
        "COV_AGE_GRP_W1",#
        "COV_GENDER_W1",#
        "COV_EDUCATION_3_W1",#
        "COV_EMPLOYMENT_W1",#
        "COV_MARITAL_STATUS_W1",#
        "COV_ATTEND_SVCS_W1",#
        "COV_BORN_COUNTRY_W1",#
        "COV_PARENTS_12YRS_W1",#
        "COV_SVCS_12YRS_W1",#
        "COV_MOTHER_RELATN_W1",#
        "COV_FATHER_RELATN_W1",#
        "COV_OUTSIDER_W1",#
        "COV_ABUSED_W1",#
        "COV_HEALTH_GROWUP_W1",#
        "COV_INCOME_12YRS_W1",#
        "COV_REL1_W1",#
        "COV_RACE_PLURALITY_W1"#
      ), "COV_")#
  }#
  baseline.pred0 <- str_remove(baseline.pred, "_W1")#
  if (!dir.exists(here::here(res.dir))) {#
    dir.create(here::here(res.dir))#
  }#
  if(!dir.exists(here::here(res.dir, "fig"))){#
  	dir.create(here::here(res.dir, "fig"))#
  }#
  ## ============================================================================================ ###
  ## ====== INTERNAL VECTORS FOR PRINTING ======================================================= ###
  ## Initialize internal word document formatting functions#
  {#
    normal_portrait <- block_section(#
      prop_section(page_size = page_size(orient = "portrait"), type = "continuous")#
    )#
    extra_wide_landscape <- block_section(prop_section(#
      page_size = page_size(#
        orient = "landscape",#
        width = 29.7 / 2.54 * 2,#
        height = 29.7 / 2.54#
      ),#
      type = "continuous"#
    ))#
#
    landscape_three_columns <- block_section(#
      prop_section(#
        page_size = page_size(orient = "landscape"), type = "continuous",#
        section_columns = section_columns(widths = c(3.24,3.24,3.24))#
      )#
    )#
    landscape_two_columns <- block_section(#
      prop_section(#
        page_size = page_size(orient = "landscape"), type = "continuous",#
        section_columns = section_columns(widths = c(4.8,4.8))#
      )#
    )#
    landscape_one_column <- block_section(#
      prop_section(#
        page_size = page_size(orient = "landscape"), type = "continuous"#
      )#
    )#
    # body_end_section_landscape(x, w = 21/2.54, h = 29.7/2.54)#
  }#
  ## DEFINE VECTOR OF OUTCOMES#
  {#
    if(is.null(outcome.vec)){#
      OUTCOME.VEC0 <- c(#
        # Flourishing#
        'blank',#
        "COMPOSITE_FLOURISHING_SECURE",#
        "COMPOSITE_FLOURISHING",#
        "COMPOSITE_HAPPI_LIFE_SAT",#
        "COMPOSITE_HEALTH",#
        "COMPOSITE_MEANING_PURPOSE",#
        "COMPOSITE_CHARACTER",#
        "COMPOSITE_SUBJECTIVE_SOC_CONN",#
        "COMPOSITE_FINL_MAT_WORRY",#
#
        # Psychological well-being#
        'blank',#
        'HAPPY',#
        'LIFE_SAT',#
        'WB_TODAY',#
        'WB_FIVEYRS',#
        'EXPECT_GOOD',#
        'FREEDOM',#
        'PEACE',#
        'LIFE_BALANCE',#
        'CAPABLE',#
        'WORTHWHILE',#
        'LIFE_PURPOSE',#
        'MENTAL_HEALTH',#
#
        # Social Well-Being#
        'blank',#
        'CONTENT',#
        'SAT_RELATNSHP',#
        'PEOPLE_HELP',#
        'CLOSE_TO',#
        'APPROVE_GOVT',#
        'SAY_IN_GOVT',#
        'BELONGING',#
        'SAT_LIVE',#
        'TRUST_PEOPLE',#
        'GROUP_NOT_REL',#
#
        # Psychological Distress#
        'blank',#
        'THREAT_LIFE',#
        'COMPOSITE_DEPRESSION', 'DEPRESSED', 'INTEREST',#
        'COMPOSITE_ANXIETY', 'FEEL_ANXIOUS', 'CONTROL_WORRY',#
        'SUFFERING',#
#
        # Social Distress#
        'blank',#
        'LONELY',#
        'DISCRIMINATED',#
#
        # Character & Prosocial Behavior#
        'blank',#
        'PROMOTE_GOOD',#
        'GIVE_UP',#
        'HOPE_FUTURE',#
        'GRATEFUL',#
        'SHOW_LOVE',#
        'FORGIVE',#
        'DONATED',#
        'HELP_STRANGER',#
        'VOLUNTEERED',#
#
        # Physical Health & Health Behavior#
        'blank',#
        'PHYSICAL_HLTH',#
        'HEALTH_PROB',#
        'BODILY_PAIN',#
        'CIGARETTES',#
        'DRINKS',#
        'DAYS_EXERCISE',#
#
        # Socioeconomic Outcomes#
        'blank',#
        'EXPENSES',#
        'WORRY_SAFETY',#
        'EDUCATION_3',#
        'EMPLOYMENT',#
        'INCOME_FEELINGS',#
        'OWN_RENT_HOME',#
        'INCOME_QUINTILE',#
#
        # Family factors#
        'blank',#
        'MARITAL_STATUS_EVER_MARRIED',#
        'NUM_CHILDREN',#
#
        # Personality#
        'blank',#
        "COMPOSITE_EXTRAVERSION",#
        "COMPOSITE_OPENNESS",#
        "COMPOSITE_AGREEABLENESS",#
        "COMPOSITE_CONSCIENTIOUSNESS",#
        "COMPOSITE_NEUROTICISM",#
#
        # Religious & spiritual#
        'blank',#
        'CONNECTED_REL',#
        'ATTEND_SVCS',#
        'AFTER_DEATH',#
        'REL_EXPERIENC',#
        'SACRED_TEXTS',#
        'PRAY_MEDITATE',#
        'BELIEVE_GOD',#
        'LIFE_APPROACH',#
        'COMFORT_REL',#
        'LOVED_BY_GOD',#
        'GOD_PUNISH',#
        'CRITICAL',#
        'TELL_BELIEFS'#
#
      )#
      OUTCOME.VEC <- c(paste0(OUTCOME.VEC0, "_W2"))#
      # OUTCOME.VEC <- paste0(OUTCOME.VEC, "_W2")#
    } else {#
      OUTCOME.VEC = outcome.vec#
    }#
  }#
  ## DEFINE VECTOR OF labels to print#
  {#
    if(is.null(mylabels)){#
      #when outcome.vec contains 'blank' == 0, use label#
      MYLABEL <- c(#
        "Human Flourishing",#
        "Psychological Well-Being",#
        "Social Well-Being",#
        "Psychological Distress",#
        "Social Distress",#
        "Character & Prosocial Behavior",#
        "Physical Health & Health Behavior",#
        "Socioeconomic Outcomes",#
        "Family Factors",#
        "Personality Traits",#
        "Religion/Spirituality"#
      )#
    } else {#
      MYLABEL = mylabels#
    }#
  }
supp_doc <- read_docx() |>#
  body_add_par("GFS Online Supplement Part 1", style="centered") %>%#
  #body_add_par("...general caveats...")#
  body_end_section_continuous() %>%#
  body_add_break()#
# ========================= ##
#coun.wopc = LIST.RES1#
#coun.wpc = LIST.RES2#
#focal.better.name = FOCAL_PREDICTOR_BETTER_NAME
included.countries
if(is.null(included.countries)){#
    COUNTRY_LABELS <-#
      sort(#
        c(#
          "Australia",#
          "Hong Kong",#
          "India",#
          "Indonesia",#
          "Japan",#
          "Philippines",#
          "Egypt",#
          "Germany",#
          "Israel",#
          "Kenya",#
          "Nigeria",#
          "Poland",#
          "South Africa",#
          "Spain",#
          "Sweden",#
          "Tanzania",#
          "Turkey",#
          "United Kingdom",#
          "United States",#
          "Argentina",#
          "Brazil",#
          "Mexico"#
        )#
      )#
  } else {#
    COUNTRY_LABELS = included.countries#
  }
i = 1; tb.num.shift = 1
cat("\nCountry:\t", COUNTRY_LABELS[i])
tmp.vec <- c(paste0(OUTCOME.VEC0, "_W2"), paste0(OUTCOME.VEC0, "_W1"))#
  df.raw <- gfs_add_variable_labels(#
  	df=df.raw, #
  	vars=tmp.vec,#
  	include.wave = TRUE#
  )#
  df.w1 <- df.raw %>%#
    select(ID, COUNTRY, PSU_W1, STRATA_W1, ANNUAL_WEIGHT1_W1, RACE, contains("_W1")) %>%#
    select(-COUNTRY_W1)#
  colnames(df.w1) <- str_remove(colnames(df.w1), "_W1")#
  df.w1$WAVE0 <- "Wave 1"#
  df.w2 <- df.raw %>%#
    select(ID, COUNTRY, PSU_W1, STRATA_W1, ANNUAL_WEIGHT1_W1, RACE, contains("_W2")) %>%#
    select(-c(COUNTRY_W2, PSU_W2, STRATA_W2, ANNUAL_WEIGHT1_W2))#
  colnames(df.w2) <- str_remove(colnames(df.w2), "_W1")#
  colnames(df.w2) <- str_remove(colnames(df.w2), "_W2")#
  df.w2$WAVE0 <- "Wave 2"#
  df.raw.long <- full_join(df.w1, df.w2)#
#
  # will be used in country-specific loop#
  df.raw.long  <- df.raw.long  %>%#
    select(#
      COUNTRY,#
      PSU,#
      STRATA,#
      ANNUAL_WEIGHT1,#
      WAVE0,#
      {focal.predictor0},#
      AGE,#
      any_of(c(OUTCOME.VEC0)),#
      any_of(c(baseline.pred0)),#
      RACE#
    ) %>%#
    mutate(#
      across(any_of(c({focal.predictor0}, OUTCOME.VEC0, baseline.pred0)), \(x){#
        if ( is.factor(x) & str_detect(cur_column(), "AGE_GRP", negate = TRUE) ) {#
          lvls <- levels(x)#
          relvls <- lvls#
          for (i in 1:length(lvls)) {#
            if ( str_detect(lvls[i],"\\. ") ) {#
              relvls[i] = stringr::str_split_fixed(lvls[i], "\\. ", 2)[,2]#
            }#
          }#
          x = factor(x, levels = lvls, labels = relvls)#
        }#
        x#
      })#
    )
tmp.vec <- c(baseline.pred0, OUTCOME.VEC0)#
  df.raw.long <- gfs_add_variable_labels( df=df.raw.long, vars=tmp.vec )
temp.dat <- df.raw.long %>%#
        mutate(COUNTRY = str_trim(COUNTRY)) %>%#
        filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
        mutate(#
          RACE = factor(RACE ),#
          RACE = droplevels(RACE),#
          RACE = case_when(is.na(RACE) ~ "(Missing)", .default = RACE),#
          RACE = factor(RACE, levels = sort(unique(RACE))),#
          RACE = fct_relevel(RACE, "(Missing)", after = Inf),#
          #INCOME = droplevels(INCOME),#
          #INCOME = factor(INCOME, levels = sort(unique(INCOME))),#
          #INCOME = case_when(is.na(INCOME) ~ "    (Missing)", .default = INCOME),#
          #INCOME = fct_relevel(INCOME, "    (Missing)", after = Inf),#
        ) %>%#
        svydesign(#
          data = .,#
          id =  ~ PSU,#
          strata =  ~ STRATA,#
          weights = ~ ANNUAL_WEIGHT1#
        )
temp.dat <- df.raw.long %>%#
        mutate(COUNTRY = str_trim(COUNTRY)) %>%#
        filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
        svydesign(#
          data = .,#
          id =  ~ PSU,#
          strata =  ~ STRATA,#
          weights = ~ ANNUAL_WEIGHT1#
        )
vec.id <- c("prop.var", "Cumulative_Proportion_Explained")#
    vec.pc <- c("Percent Explained by each PC", "Cumulative Percent Explained")#
    cnames <- c(#
      "Outcome",#
      vec.pc#
    )#
    coun.pca <- as.data.frame(matrix(nrow = length(OUTCOME.VEC), ncol = length(cnames)))#
    colnames(coun.pca) <- cnames#
    j = ii = 1#
    for (j in 1:length(OUTCOME.VEC)) {#
      if (stringr::str_detect(OUTCOME.VEC[j], "blank") ) {#
        coun.pca[j, 1] <- MYLABEL[ii]#
        ii <- ii + 1#
      } else {#
        coun.pca[j, 1] = paste0("    ",get_outcome_better_name(OUTCOME.VEC[j], include.name = FALSE))#
        tmp.vec <- vec.id#
        tmp.name <- paste0(OUTCOME.VEC[j], "_", focal.predictor)#
        if(tmp.name %in% names(coun.fit.pca)){#
        	## ====== estimates WITH PCs ======================================= ###
        	tmp.pca <- coun.fit.pca[[tmp.name]] %>% ungroup() %>%#
      	  	dplyr::filter(  str_detect(COUNTRY, COUNTRY_LABELS[i]), PC <= 7 ) %>%#
          	dplyr::select(PC,tidyr::any_of(tmp.vec)) %>%#
          	dplyr::mutate(#
            	across(tidyr::any_of(tmp.vec),\(x) .round(x*100,1) )#
          	)#
        	tmp.pca2 <- tmp.pca %>% filter(PC == 7)#
        	tmp.pca2[tmp.vec[1]] <- str_remove(str_remove_all(as.character(tmp.pca[tmp.vec[1]]), '\\"'),"c")#
        	## ====== Add Results to output object ====================================================== ###
        	if(nrow(tmp.pca) > 0) coun.pca[j,vec.pc] <- tmp.pca2[tmp.vec]#
        }#
      }#
    }#
    #coun.pca <- na.omit(coun.pca)#
    # footnote information:#
    tb.note.pca <- as_paragraph("_Notes_. PCA was conducted using 'survey::svyprcomp(.)' function using all available contemporaneous (with focal predictor) exposures at wave 1. Composite indicators were excluded and items forming the composite were exluded if the focal predictor was a composite. All PCs were standardized prior to being used as predictors. The number of retained components for analysis was 7.")#
#
    coun.pca.toprint <- coun.pca %>%#
      flextable() %>%#
      #autofit() %>%#
      set_caption(#
        paste0("Table S", i+tb.num.shift,"c. Summary of principal components retain in ", COUNTRY_LABELS[i])#
      ) %>%#
      #uncomment when using all outcomes#
      italic(part = "body",#
             i = c(which(stringr::str_detect(OUTCOME.VEC, "blank"))),#
             j = 1) %>%#
      add_footer_row(#
        values = tb.note.pca, top = FALSE, colwidths = ncol(coun.pca)#
      ) %>%#
      width(j=1,width=2.5)%>%#
      format_flex_table(pg.width = 21 / 2.54 - 2) %>%#
      align(i = 1, j = NULL, align = "center", part = "header") %>%#
      align(part = "footer", align = "left", j = 1:ncol(coun.pca)) %>%#
      border_remove()  %>%#
      hline_bottom(part = "body") %>%#
      hline_top(part = "header") %>%#
      hline_bottom(part = "header")
vec.id <- c("id.Est", "id.SE", "id.CI","p.value")#
    vec.rr <- c("rr.Est", "logrr.SE", "rr.CI","p.value")#
    vec.wopc <- c("Est", "SE", "95% CI", "p-value")#
    vec.wpc <- c("Est\r", "SE\r", "95% CI\r", "p-value\r")#
    cnames <- c(#
      "Outcome",#
      "Reference",#
      vec.wopc,#
      "\r",#
      vec.wpc#
    )#
#
    coun.outcomewide <- as.data.frame(matrix(nrow = length(OUTCOME.VEC), ncol = length(cnames)))#
    colnames(coun.outcomewide) <- cnames#
    coun.outcomewide$"\r" <- ""#
    j = ii = 1#
    for (j in 1:length(OUTCOME.VEC)) {#
      if (stringr::str_detect(OUTCOME.VEC[j], "blank") ) {#
        coun.outcomewide[j, 1] <- MYLABEL[ii]#
        ii <- ii + 1#
      } else {#
        coun.outcomewide[j, 1] = paste0("    ",get_outcome_better_name(OUTCOME.VEC[j], include.name = FALSE))#
        coun.outcomewide[j, 2] = case_when(#
          get_outcome_scale(OUTCOME.VEC[i]) == "cont" ~ "0.00",#
          .default = "1.00"#
        )#
        tmp.vec <- case_when(#
          get_outcome_scale(OUTCOME.VEC[j]) == "cont" ~ vec.id,#
          .default = vec.rr#
        )#
		tmp.name <- paste0(OUTCOME.VEC[j], "_", focal.predictor)#
        ## ====== estimates withOUT PCs ======================================= ###
        if(tmp.name %in% names(coun.fit.pca)){#
        	tmp.wopc <- coun.wopc[[tmp.name]] %>% ungroup() %>%#
          dplyr::filter(OUTCOME0 == OUTCOME.VEC[j]) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x > 0.01 ~ .round(x,4),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.0001 ~ "<.0001***"#
              )#
            })#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wopc) > 0) coun.outcomewide[j,vec.wopc] <- tmp.wopc[tmp.vec]#
        }#
        ## ====== Random effects coun - estimates WITH PCs ======================================= ###
        if(tmp.name %in% names(coun.fit.pca)){#
        tmp.wpc <- coun.wpc[[tmp.name]] %>% ungroup() %>%#
          dplyr::filter(OUTCOME0 == OUTCOME.VEC[j]) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x > 0.01 ~ .round(x,4),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.0001 ~ "<.0001***"#
              )#
            })#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wpc) > 0) coun.outcomewide[j,vec.wpc] <- tmp.wpc[tmp.vec]#
        }#
      }#
    }#
    #coun.outcomewide <- na.omit(coun.outcomewide)#
#
    # footnote information:#
    tb.note.coun.outcomewide <-as_paragraph(paste0("_Notes_. Reference for focal predictor: ", focal.predictor.reference.value,". Est., standardized effect estimate; SE, standard error, the SE reported for binary/Likert-type outcomes where risk-ratios are on the log(RR) scale; CI, confidence interval; p-value, a Wald-type test of the null hypothesis that the effect of the focal predictor is zero.#
#
Multiple imputation was performed to impute missing data on the covariates, exposure, and outcomes. All models controlled for sociodemographic and family factors: Relationship with mother growing up; Relationship with father growing up; parent marital status around age 12; Experienced abuse growing up (except for Israel); Felt like an outsider in family growing up; Self-rated health growing up; Self-rated feelings about income growing up; Immigration status; Frequency of religious service attendance around age 12; year of birth; gender; religious affiliation at age 12; and racial/ethnic identity when available. For Models with PC (principal components), the first seven principal components of the full set of contemporaneous confounders were included as additional predictors of the outcomes at wave 2.#
#
An outcome-wide analytic approach was used, and a separate model was run for each outcome. A different type of model was run depending on the nature of the outcome: (1) for each binary outcome, a generalized linear model (with a log link and Poisson distribution) was used to estimate an RR; and (2) for each continuous outcome, a weighted linear regression model was used to estimate a B, where all continuous outcomes were standardized using the within country mean and standard deviation prior to estimating the model.#
#
P-value significance thresholds: p < 0.01*, p < 0.001**, p < 0.0001***, (Bonferroni) p < ",.round(p.bonferroni,4),"."))#
#
    coun.outcomewide.toprint <- coun.outcomewide %>%#
      flextable() %>%#
      set_caption(#
        paste0("Table S",i+tb.num.shift,"d. Associations of _", focal.better.name ,"_ with adult well-being and other outcomes at wave 2 in ", COUNTRY_LABELS[i])#
      ) %>%#
      #uncomment when using all outcomes#
      italic(part = "body",#
             i = c(which(stringr::str_detect(OUTCOME.VEC, "blank"))),#
             j = 1) %>%#
      add_header_row(#
        values = c("", "", "Model 1: Without PC", "", "Model 2: With PC"),#
        colwidths = c(1,1,length(vec.wopc), 1, length(vec.wpc))#
      ) %>%#
      add_footer_row(#
        values = tb.note.coun.outcomewide, top = FALSE, colwidths = ncol(coun.outcomewide)#
      ) %>%#
      width(j=1,width=1.75)%>%#
      width(j=7,width=0.20)%>%#
      format_flex_table(pg.width = 29.7/2.54 - 2) %>%#
      align(i = 1, j = NULL, align = "center", part = "header") %>%#
      align(part = "footer", align = "left", j = 1:ncol(coun.outcomewide)) %>%#
      border_remove()  %>%#
      hline_bottom(part = "body") %>%#
      hline_top(part = "header") %>%#
      hline_bottom(part = "header") %>%#
      hline(i=1,j=c(3:6,8:11), part="header")
coun.wpc[[tmp.name]] %>% ungroup()
vec.id <- c("id.Est", "id.SE", "id.CI","p.value")#
    vec.rr <- c("rr.Est", "logrr.SE", "rr.CI","p.value")#
    vec.wopc <- c("Est", "SE", "95% CI", "p-value")#
    vec.wpc <- c("Est\r", "SE\r", "95% CI\r", "p-value\r")#
    cnames <- c(#
      "Outcome",#
      "Reference",#
      vec.wopc,#
      "\r",#
      vec.wpc#
    )#
#
    coun.outcomewide <- as.data.frame(matrix(nrow = length(OUTCOME.VEC), ncol = length(cnames)))#
    colnames(coun.outcomewide) <- cnames#
    coun.outcomewide$"\r" <- ""#
    j = ii = 1#
    for (j in 1:length(OUTCOME.VEC)) {#
      if (stringr::str_detect(OUTCOME.VEC[j], "blank") ) {#
        coun.outcomewide[j, 1] <- MYLABEL[ii]#
        ii <- ii + 1#
      } else {#
        coun.outcomewide[j, 1] = paste0("    ",get_outcome_better_name(OUTCOME.VEC[j], include.name = FALSE))#
        coun.outcomewide[j, 2] = case_when(#
          get_outcome_scale(OUTCOME.VEC[i]) == "cont" ~ "0.00",#
          .default = "1.00"#
        )#
        tmp.vec <- case_when(#
          get_outcome_scale(OUTCOME.VEC[j]) == "cont" ~ vec.id,#
          .default = vec.rr#
        )#
		tmp.name <- paste0(OUTCOME.VEC[j], "_", focal.predictor)#
        ## ====== estimates withOUT PCs ======================================= ###
        if(tmp.name %in% names(coun.fit.pca)){#
        	tmp.wopc <- coun.wopc[[tmp.name]] %>% ungroup() %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x > 0.01 ~ .round(x,4),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.0001 ~ "<.0001***"#
              )#
            })#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wopc) > 0) coun.outcomewide[j,vec.wopc] <- tmp.wopc[tmp.vec]#
        }#
        ## ====== Random effects coun - estimates WITH PCs ======================================= ###
        if(tmp.name %in% names(coun.fit.pca)){#
        tmp.wpc <- coun.wpc[[tmp.name]] %>% ungroup() %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x > 0.01 ~ .round(x,4),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.0001 ~ "<.0001***"#
              )#
            })#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wpc) > 0) coun.outcomewide[j,vec.wpc] <- tmp.wpc[tmp.vec]#
        }#
      }#
    }
warnings()
coun.wpc[[tmp.name]] %>% ungroup()
vec.id <- c("id.Est", "id.SE", "id.CI","p.value")#
    vec.rr <- c("rr.Est", "logrr.SE", "rr.CI","p.value")#
    vec.wopc <- c("Est", "SE", "95% CI", "p-value")#
    vec.wpc <- c("Est\r", "SE\r", "95% CI\r", "p-value\r")#
    cnames <- c(#
      "Outcome",#
      "Reference",#
      vec.wopc,#
      "\r",#
      vec.wpc#
    )#
#
    coun.outcomewide <- as.data.frame(matrix(nrow = length(OUTCOME.VEC), ncol = length(cnames)))#
    colnames(coun.outcomewide) <- cnames#
    coun.outcomewide$"\r" <- ""#
    j = ii = 1#
    for (j in 1:length(OUTCOME.VEC)) {#
      if (stringr::str_detect(OUTCOME.VEC[j], "blank") ) {#
        coun.outcomewide[j, 1] <- MYLABEL[ii]#
        ii <- ii + 1#
      } else {#
        coun.outcomewide[j, 1] = paste0("    ",get_outcome_better_name(OUTCOME.VEC[j], include.name = FALSE))#
        coun.outcomewide[j, 2] = case_when(#
          get_outcome_scale(OUTCOME.VEC[i]) == "cont" ~ "0.00",#
          .default = "1.00"#
        )#
        tmp.vec <- case_when(#
          get_outcome_scale(OUTCOME.VEC[j]) == "cont" ~ vec.id,#
          .default = vec.rr#
        )#
		tmp.name <- paste0(OUTCOME.VEC[j], "_", focal.predictor)#
        ## ====== estimates withOUT PCs ======================================= ###
        if(tmp.name %in% names(coun.fit.pca)){#
        	tmp.wopc <- coun.wopc[[tmp.name]] %>% ungroup() %>%#
        	dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x > 0.01 ~ .round(x,4),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.0001 ~ "<.0001***"#
              )#
            })#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wopc) > 0) coun.outcomewide[j,vec.wopc] <- tmp.wopc[tmp.vec]#
        }#
        ## ====== Random effects coun - estimates WITH PCs ======================================= ###
        if(tmp.name %in% names(coun.fit.pca)){#
        tmp.wpc <- coun.wpc[[tmp.name]] %>% ungroup() %>%#
          dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x > 0.01 ~ .round(x,4),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.0001 ~ "<.0001***"#
              )#
            })#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wpc) > 0) coun.outcomewide[j,vec.wpc] <- tmp.wpc[tmp.vec]#
        }#
      }#
    }
coun.outcomewide
tmp.wpc <- coun.wpc[[tmp.name]] %>% ungroup() %>%#
          dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x > 0.01 ~ .round(x,4),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.0001 ~ "<.0001***"#
              )#
            })#
          )
tmp.wpc
j=2
tmp.name <- paste0(OUTCOME.VEC[j], "_", focal.predictor)
tmp.wopc <- coun.wopc[[tmp.name]] %>% ungroup() %>%#
        	dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x > 0.01 ~ .round(x,4),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.0001 ~ "<.0001***"#
              )#
            })#
          )
tmp.wopc
coun.wopc[[tmp.name]] %>% ungroup() %>%#
        	dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec))
tmp.wopc <- coun.wopc[[tmp.name]] %>% ungroup() %>%#
        	dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x < 0.0001 ~ "<.0001***",#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x > 0.01 ~ .round(x,4)#
              )#
            })#
          )
tmp.wopc
vec.id <- c("id.Est", "id.SE", "id.CI","p.value")#
    vec.rr <- c("rr.Est", "logrr.SE", "rr.CI","p.value")#
    vec.wopc <- c("Est", "SE", "95% CI", "p-value")#
    vec.wpc <- c("Est\r", "SE\r", "95% CI\r", "p-value\r")#
    cnames <- c(#
      "Outcome",#
      "Reference",#
      vec.wopc,#
      "\r",#
      vec.wpc#
    )#
#
    coun.outcomewide <- as.data.frame(matrix(nrow = length(OUTCOME.VEC), ncol = length(cnames)))#
    colnames(coun.outcomewide) <- cnames#
    coun.outcomewide$"\r" <- ""#
    j = ii = 1#
    for (j in 1:length(OUTCOME.VEC)) {#
      if (stringr::str_detect(OUTCOME.VEC[j], "blank") ) {#
        coun.outcomewide[j, 1] <- MYLABEL[ii]#
        ii <- ii + 1#
      } else {#
        coun.outcomewide[j, 1] = paste0("    ",get_outcome_better_name(OUTCOME.VEC[j], include.name = FALSE))#
        coun.outcomewide[j, 2] = case_when(#
          get_outcome_scale(OUTCOME.VEC[i]) == "cont" ~ "0.00",#
          .default = "1.00"#
        )#
        tmp.vec <- case_when(#
          get_outcome_scale(OUTCOME.VEC[j]) == "cont" ~ vec.id,#
          .default = vec.rr#
        )#
		tmp.name <- paste0(OUTCOME.VEC[j], "_", focal.predictor)#
        ## ====== estimates withOUT PCs ======================================= ###
        if(tmp.name %in% names(coun.fit.pca)){#
        	tmp.wopc <- coun.wopc[[tmp.name]] %>% ungroup() %>%#
        	dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x < 0.0001 ~ "<.0001***",#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x > 0.01 ~ .round(x,4)#
              )#
            })#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wopc) > 0) coun.outcomewide[j,vec.wopc] <- tmp.wopc[tmp.vec]#
        }#
        ## ====== Random effects coun - estimates WITH PCs ======================================= ###
        if(tmp.name %in% names(coun.fit.pca)){#
        tmp.wpc <- coun.wpc[[tmp.name]] %>% ungroup() %>%#
          dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(tidyr::any_of(c("p.value")),\(x){#
              case_when(#
                x < 0.0001 ~ "<.0001***",#
                x < 0.001 ~ paste0(.round(x,4),"**"),#
                x < 0.01 ~ paste0(.round(x,4),"*"),#
                x > 0.01 ~ .round(x,4)#
              )#
            })#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wpc) > 0) coun.outcomewide[j,vec.wpc] <- tmp.wpc[tmp.vec]#
        }#
      }#
    }
coun.outcomewide
# footnote information:#
    tb.note.coun.outcomewide <-as_paragraph(paste0("_Notes_. Reference for focal predictor: ", focal.predictor.reference.value,". Est., standardized effect estimate; SE, standard error, the SE reported for binary/Likert-type outcomes where risk-ratios are on the log(RR) scale; CI, confidence interval; p-value, a Wald-type test of the null hypothesis that the effect of the focal predictor is zero.#
#
Multiple imputation was performed to impute missing data on the covariates, exposure, and outcomes. All models controlled for sociodemographic and family factors: Relationship with mother growing up; Relationship with father growing up; parent marital status around age 12; Experienced abuse growing up (except for Israel); Felt like an outsider in family growing up; Self-rated health growing up; Self-rated feelings about income growing up; Immigration status; Frequency of religious service attendance around age 12; year of birth; gender; religious affiliation at age 12; and racial/ethnic identity when available. For Models with PC (principal components), the first seven principal components of the full set of contemporaneous confounders were included as additional predictors of the outcomes at wave 2.#
#
An outcome-wide analytic approach was used, and a separate model was run for each outcome. A different type of model was run depending on the nature of the outcome: (1) for each binary outcome, a generalized linear model (with a log link and Poisson distribution) was used to estimate an RR; and (2) for each continuous outcome, a weighted linear regression model was used to estimate a B, where all continuous outcomes were standardized using the within country mean and standard deviation prior to estimating the model.#
#
P-value significance thresholds: p < 0.01*, p < 0.001**, p < 0.0001***, (Bonferroni) p < ",.round(p.bonferroni,4),"."))#
#
    coun.outcomewide.toprint <- coun.outcomewide %>%#
      flextable() %>%#
      set_caption(#
        paste0("Table S",i+tb.num.shift,"d. Associations of _", focal.better.name ,"_ with adult well-being and other outcomes at wave 2 in ", COUNTRY_LABELS[i])#
      ) %>%#
      #uncomment when using all outcomes#
      italic(part = "body",#
             i = c(which(stringr::str_detect(OUTCOME.VEC, "blank"))),#
             j = 1) %>%#
      add_header_row(#
        values = c("", "", "Model 1: Without PC", "", "Model 2: With PC"),#
        colwidths = c(1,1,length(vec.wopc), 1, length(vec.wpc))#
      ) %>%#
      add_footer_row(#
        values = tb.note.coun.outcomewide, top = FALSE, colwidths = ncol(coun.outcomewide)#
      ) %>%#
      width(j=1,width=1.75)%>%#
      width(j=7,width=0.20)%>%#
      format_flex_table(pg.width = 29.7/2.54 - 2) %>%#
      align(i = 1, j = NULL, align = "center", part = "header") %>%#
      align(part = "footer", align = "left", j = 1:ncol(coun.outcomewide)) %>%#
      border_remove()  %>%#
      hline_bottom(part = "body") %>%#
      hline_top(part = "header") %>%#
      hline_bottom(part = "header") %>%#
      hline(i=1,j=c(3:6,8:11), part="header")
coun.wopc
vec.id <- c("EE", "ECI")#
    vec.wopc <- c("EE", "ECI")#
    vec.wpc <- c("EE\r", "ECI\r") # need to add whitespace to the end of these columns so that flextable doesn't through the "duplicate column keys" error (see https://stackoverflow.com/questions/50748232/same-column-names-in-flextable-in-r) for more details on other approaches.#
    cnames <- c(#
      "Outcome",#
      vec.wopc, "\r",#
      vec.wpc#
    )#
#
    coun.evalues <- as.data.frame(matrix(nrow = length(OUTCOME.VEC), ncol = length(cnames)))#
    colnames(coun.evalues) <- cnames#
    coun.evalues$"\r" <- ""#
    j = ii = 1#
    for (j in 1:length(OUTCOME.VEC)) {#
      if (stringr::str_detect(OUTCOME.VEC[j], "blank") ) {#
        coun.evalues[j, 1] <- MYLABEL[ii]#
        ii <- ii + 1#
      } else {#
        coun.evalues[j, 1] = paste0("    ",get_outcome_better_name(OUTCOME.VEC[j], include.name = FALSE))#
        tmp.vec <- vec.id#
        tmp.name <- paste0(OUTCOME.VEC[j], "_", focal.predictor)#
        ## ====== estimates withOUT PCs ======================================= ###
        if(tmp.name %in% names(coun.wopc)){#
        	tmp.wopc <- coun.wopc[[tmp.name]] %>% ungroup() %>%#
          dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(where(is.numeric),\(x) .round(x,2)),#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wopc) > 0) coun.evalues[j,vec.wopc] <- tmp.wopc[tmp.vec]#
        }#
        ## ====== estimates WITH PCs ======================================= ###
        if(tmp.name %in% names(coun.wpc)){#
        	tmp.wpc <- coun.wpc[[tmp.name]] %>% ungroup() %>%#
          dplyr::filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
          dplyr::select(tidyr::any_of(tmp.vec)) %>%#
          dplyr::mutate(#
            dplyr::across(where(is.numeric),\(x) .round(x,2)),#
          )#
          ## ====== Add Results to output object ====================================================== ###
          if(nrow(tmp.wpc) > 0) coun.evalues[j,vec.wpc] <- tmp.wpc[tmp.vec]#
        }#
      }#
    }
coun.evalues
# footnote information:#
    tb.note.evalues <-as_paragraph("_Notes_. EE, E-value for Estimate; ECI, E-value for the limit of the confidence interval. The formula for calculating E-values can be found in VanderWeele and Ding (2017). E-values for Estimate are the minimum strength of association on the risk ratio scale that an unmeasured confounder would need to have with both the exposure and the outcome to fully explain away the observed association between the exposure and outcome, conditional on the measured covariates. E-values for the 95% CI closest to the null denote the minimum strength of association on the risk ratio scale that an unmeasured confounder would need to have with both the exposure and the outcome to shift the CI to include the null value, conditional on the measured covariates.")#
#
    coun.evalues.toprint <- coun.evalues %>%#
      flextable() %>%#
      #autofit() %>%#
      set_caption(#
        paste0("Table S", i+tb.num.shift,"e. Sensitivity analysis of outcome-wide results to unmeasured confounding using E-values in ", COUNTRY_LABELS[i])#
      ) %>%#
      #uncomment when using all outcomes#
      italic(part = "body",#
             i = c(which(stringr::str_detect(OUTCOME.VEC, "blank"))),#
             j = 1) %>%#
      add_header_row(#
        values = c("", "Model 1: Without PC", "", "Model 2: With PC"),#
        colwidths = c(1, length(vec.wopc), 1, length(vec.wpc))#
      ) %>%#
      add_footer_row(#
        values = tb.note.evalues, top = FALSE, colwidths = ncol(coun.evalues)#
      ) %>%#
      width(j=1,width=2.5)%>%#
      format_flex_table(pg.width = 21 / 2.54 - 2) %>%#
      align(i = 1, j = NULL, align = "center", part = "header") %>%#
      align(part = "footer", align = "left", j = 1:ncol(coun.evalues)) %>%#
      border_remove()  %>%#
      hline_bottom(part = "body") %>%#
      hline_top(part = "header") %>%#
      hline_bottom(part = "header") %>%#
      hline(i=1,j=c(2:3,5:6), part="header")
supp_doc <- supp_doc |>#
    body_add_flextable(value = tbia.toprint) |>#
    body_add_break() |>#
    body_add_flextable(value = tbib.toprint) |>#
    body_add_break() |>#
    body_add_flextable(value = coun.pca.toprint) |>#
    body_end_block_section(value = normal_portrait) |>#
    body_add_break() |>#
    body_add_flextable(value = coun.outcomewide.toprint) |>#
    body_end_block_section(value = landscape_one_column) |>#
    body_add_break() |>#
    body_add_flextable(value = coun.evalues.toprint) |>#
    body_end_block_section(value = normal_portrait) |>#
    body_add_break()
supp_doc <- read_docx() |>#
    body_add_par("GFS Online Supplement Part 2", style="centered") %>%#
    #body_add_par("...general caveats...")#
    body_end_section_continuous() %>%#
    body_add_break()
temp.dat <- df.raw %>%#
        mutate(COUNTRY = str_trim(COUNTRY)) %>%#
        #filter(str_detect(COUNTRY, COUNTRY_LABELS[i])) %>%#
        svydesign(#
          data = .,#
          id =  ~ PSU_W1,#
          strata =  ~ STRATA_W1,#
          weights = ~ ANNUAL_WEIGHT1_W1#
        )
focal.predictor1 <- focal.predictor#
      focal.predictor2 <- paste0(str_remove(focal.predictor, "_W1"), "_W2")#
#
      focal.better.name1 <- paste0(focal.better.name, " (wave 1)")#
      focal.better.name2 <- paste0(focal.better.name, " (wave 2)")
meta.wopc
tmp.vec <- OUTCOME.VEC[str_detect(OUTCOME.VEC, "blank", negate=TRUE)]
tmp.vec
devtools::load_all()
df.raw <- gfs_get_labelled_raw_data(#
  here::here(data.dir, dataset.name),#
  list.composites = LIST.COMPOSITES,#
  add.whitespace = TRUE#
)#
#
COUN.RES.WOPC <- get_country_specific_regression_results("results-wopc", OUTCOME.VEC0, FOCAL_PREDICTOR)#
COUN.RES.WPC <- get_country_specific_regression_results("results-wpc", OUTCOME.VEC0, FOCAL_PREDICTOR)#
FIT.PCA.SUM <- get_country_specific_pca_summary("results-wpc", OUTCOME.VEC0, FOCAL_PREDICTOR)
gfs_generate_supplemental_docs(#
    df.raw = df.raw,#
	meta.wopc=META.RES1, meta.wpc=META.RES2,#
	 coun.wopc=COUN.RES.WOPC , coun.wpc=COUN.RES.WPC ,#
	 coun.fit.pca = FIT.PCA.SUM ,#
	focal.predictor=FOCAL_PREDICTOR,#
	focal.better.name=FOCAL_PREDICTOR_BETTER_NAME, #
	focal.predictor.reference.value=FOCAL_PREDICTOR_REFERENCE_VALE, #
	res.dir = "results")
