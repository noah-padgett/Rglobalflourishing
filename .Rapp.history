# Add the directory where the dataset is stored on your computer#
data.dir <- "/Users/noahp/Documents/GitHub/global-flourishing-study/data/wave2-data"#
dataset.name <- "gfs_all_countries_wave2.sav"#
#
# Specify where you want to output results#
# Can be left blank, and the results will output to the same directory as the data.#
out.dir <- getwd()#
#
# Here is YOUR wave 1 construct variable#
FOCAL_PREDICTOR <- c("PHYSICAL_HLTH_Y1")#
FOCAL_PREDICTOR_BETTER_NAME <- c("Self-rated physical health")#
FOCAL_PREDICTOR_REFERENCE_VALUE <- c("mean rating within country")#
#
# IF your predictor (focal exposure) is binary/categorical, use the code below to define how you#
#   want it to be categorized. Categorization must result in a binary variable 0/1 for#
#   consistency across studies.#
VALUES_DEFINING_UPPER_CATEGORY <- list(NA)#
VALUES_DEFINING_LOWER_CATEGORY <- list(NA)#
# Note 1: if your focal predictor is continuous (all items with 7+ response options), you can force the responses#
# 	to be categorized as 0/1 using the above with the below option changed to TRUE. This can be useful#
# 	when testing the sensitivity of results or for composite outcomes such as anxiety (sum of#
#   feel_anxious and control_worry)  or depression (sum of depressed and interest) that have a#
# 	history of being dichotomized.#
FORCE_BINARY <- c(FALSE)#
# Note 2: if your focal predictor is categorical/binary, you can use the responses as if they were continuous.#
# 	The provided (straightforward-ish) approach implemented is to reverse code all#
#   ordered-categorical variables (reverse code from what is reported in the codebook), and#
#   standardized as if continuous. This approach is not applicable for variables with nominal#
#   response categories such as employment. This is employed using the option below.#
FORCE_CONTINUOUS <- c(FALSE)#
# Note 3: if you need to define a subpopulation for domain analysis. (in-development)#
SUBPOPULATION <- list(NULL)#
#
names(FORCE_CONTINUOUS) <- names(FORCE_BINARY) <- names(VALUES_DEFINING_UPPER_CATEGORY)  <- names(VALUES_DEFINING_LOWER_CATEGORY) <- names(SUBPOPULATION) <- FOCAL_PREDICTOR#
# ================================================================================================ ##
# ================================================================================================ ##
# Data Prep#
#
if (is.null(out.dir)) {#
  out.dir <- data.dir#
}#
setwd(out.dir)#
# Note:#
# The following function loads the required packages for the remainder of the script to work.#
load_packages()#
# global options#
options(#
  survey.lonely.psu = "certainty"#
)#
# outcome vectors#
LIST.COMPOSITES <- get_variable_codes('LIST.COMPOSITES')#
RECODE.DEFAULTS <- list(#
  FOCAL_PREDICTOR = FOCAL_PREDICTOR,#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC = c(#
    get_variable_codes("GENDER.RACE", appnd=""),#
    get_variable_codes("DEMOGRAPHIC.VARS", appnd="_Y1"),#
    get_variable_codes("RETROSPECTIVE.VARS", appnd="_Y1")#
  ),#
  VARIABLES.VEC = c(get_variable_codes("VARS.Y1"), get_variable_codes("VARS.Y2")),#
  FORCE_BINARY = FORCE_BINARY,#
  FORCE_CONTINUOUS = FORCE_CONTINUOUS,#
  VALUES_DEFINING_UPPER_CATEGORY = VALUES_DEFINING_UPPER_CATEGORY,#
  VALUES_DEFINING_LOWER_CATEGORY = VALUES_DEFINING_LOWER_CATEGORY,#
  USE_DEFAULT = !(FORCE_BINARY | FORCE_CONTINUOUS)#
)
devtools::load_all()
# Add the directory where the dataset is stored on your computer#
data.dir <- "/Users/noahp/Documents/GitHub/global-flourishing-study/data/wave2-data"#
dataset.name <- "gfs_all_countries_wave2.sav"#
#
# Specify where you want to output results#
# Can be left blank, and the results will output to the same directory as the data.#
out.dir <- getwd()#
#
# Here is YOUR wave 1 construct variable#
FOCAL_PREDICTOR <- c("PHYSICAL_HLTH_Y1")#
FOCAL_PREDICTOR_BETTER_NAME <- c("Self-rated physical health")#
FOCAL_PREDICTOR_REFERENCE_VALUE <- c("mean rating within country")#
#
# IF your predictor (focal exposure) is binary/categorical, use the code below to define how you#
#   want it to be categorized. Categorization must result in a binary variable 0/1 for#
#   consistency across studies.#
VALUES_DEFINING_UPPER_CATEGORY <- list(NA)#
VALUES_DEFINING_LOWER_CATEGORY <- list(NA)#
# Note 1: if your focal predictor is continuous (all items with 7+ response options), you can force the responses#
# 	to be categorized as 0/1 using the above with the below option changed to TRUE. This can be useful#
# 	when testing the sensitivity of results or for composite outcomes such as anxiety (sum of#
#   feel_anxious and control_worry)  or depression (sum of depressed and interest) that have a#
# 	history of being dichotomized.#
FORCE_BINARY <- c(FALSE)#
# Note 2: if your focal predictor is categorical/binary, you can use the responses as if they were continuous.#
# 	The provided (straightforward-ish) approach implemented is to reverse code all#
#   ordered-categorical variables (reverse code from what is reported in the codebook), and#
#   standardized as if continuous. This approach is not applicable for variables with nominal#
#   response categories such as employment. This is employed using the option below.#
FORCE_CONTINUOUS <- c(FALSE)#
# Note 3: if you need to define a subpopulation for domain analysis. (in-development)#
SUBPOPULATION <- list(NULL)#
#
names(FORCE_CONTINUOUS) <- names(FORCE_BINARY) <- names(VALUES_DEFINING_UPPER_CATEGORY)  <- names(VALUES_DEFINING_LOWER_CATEGORY) <- names(SUBPOPULATION) <- FOCAL_PREDICTOR#
# ================================================================================================ ##
# ================================================================================================ ##
# Data Prep#
#
if (is.null(out.dir)) {#
  out.dir <- data.dir#
}#
setwd(out.dir)#
# Note:#
# The following function loads the required packages for the remainder of the script to work.#
load_packages()#
# global options#
options(#
  survey.lonely.psu = "certainty"#
)#
# outcome vectors#
LIST.COMPOSITES <- get_variable_codes('LIST.COMPOSITES')#
RECODE.DEFAULTS <- list(#
  FOCAL_PREDICTOR = FOCAL_PREDICTOR,#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC = c(#
    get_variable_codes("GENDER.RACE", appnd=""),#
    get_variable_codes("DEMOGRAPHIC.VARS", appnd="_Y1"),#
    get_variable_codes("RETROSPECTIVE.VARS", appnd="_Y1")#
  ),#
  VARIABLES.VEC = c(get_variable_codes("VARS.Y1"), get_variable_codes("VARS.Y2")),#
  FORCE_BINARY = FORCE_BINARY,#
  FORCE_CONTINUOUS = FORCE_CONTINUOUS,#
  VALUES_DEFINING_UPPER_CATEGORY = VALUES_DEFINING_UPPER_CATEGORY,#
  VALUES_DEFINING_LOWER_CATEGORY = VALUES_DEFINING_LOWER_CATEGORY,#
  USE_DEFAULT = !(FORCE_BINARY | FORCE_CONTINUOUS)#
)
getwd()
recode_imp_by_country(#
    data.dir,#
    nimp = 5,#
    list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES,#
    wgt = "ANNUAL_WEIGHT_R2"#
  )
devtools::load_all()
recode_imp_by_country(#
    data.dir,#
    nimp = 5,#
    list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES,#
    wgt = "ANNUAL_WEIGHT_R2"#
  )
nimp = 5
list.default = RECODE.DEFAULTS
list.composites = LIST.COMPOSITES
wgt = "ANNUAL_WEIGHT_R2"
imp.files <- list.files(data.dir)
imp.files
imp.files <- imp.files[str_detect(imp.files, "imputed_data_obj")]
imp.files <- imp.files[str_detect(imp.files, paste0("_nimp_",nimp))]
imp.files
x <- imp.files[1]
y <- 1
load(here::here(data.dir,x), ex <- new.env())
drop_created_vars <- c("AGE_GRP_Y1", "AGE_GRP_Y2", "RACE", "RACE_PLURALITY_Y1", "INCOME_QUINTILE_Y1", "INCOME_QUINTILE_Y2")
list.default
list.composites
wave = 2
method.income = "quintiles.top.random"
wgt = "ANNUAL_WEIGHT_R2"
strata = "STRATA"
psu = "PSU"
recode_imputed_data
tmp.imp <- recode_imputed_data(ex$fit.imp, m = y,  list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES)
drop_created_vars <- c("AGE_GRP_Y1", "AGE_GRP_Y2", "RACE", "RACE_PLURALITY_Y1", "INCOME_QUINTILE_Y1", "INCOME_QUINTILE_Y2")
df.imp < -ex$fit.imp
df.imp <- ex$fit.imp
df.imp.long <- complete(df.imp, action = m)
m
m = y
m
df.imp.long <- complete(df.imp, action = m) %>%#
    select(!any_of(drop_created_vars)) %>%#
    mutate(#
      across(where(is.factor), \(x){#
      	if(str_detect(cur_column(), "COUNTRY", negate=TRUE)){#
        	x <- sub("\\..*", "", x)#
        	x = case_when(x == "(Missing)" ~ NA, .default = x) |>#
          		as.numeric()#
        }#
        if(str_detect(cur_column(), "BORN_COUNTRY")){#
        	x <- sub("\\..*", "", x)#
        	x = case_when(x == "(Missing)" ~ NA, .default = x) |>#
          		as.numeric()#
        }#
        x#
      })#
    )
colnames(df.imp.long)
df.imp.long <- complete(df.imp, action = m) %>%#
    select(!any_of(drop_created_vars)) %>%#
    mutate(#
      .imp = ifelse(is.numeric(m), m, ifelse(!is.null(.imp), .imp, m)),#
      across(where(is.factor), \(x){#
      	if(str_detect(cur_column(), "COUNTRY", negate=TRUE)){#
        	x <- sub("\\..*", "", x)#
        	x = case_when(x == "(Missing)" ~ NA, .default = x) |>#
          		as.numeric()#
        }#
        if(str_detect(cur_column(), "BORN_COUNTRY")){#
        	x <- sub("\\..*", "", x)#
        	x = case_when(x == "(Missing)" ~ NA, .default = x) |>#
          		as.numeric()#
        }#
        x#
      })#
    )
colnames(df.imp.long)
table(df.imp.long$.imp)
devtools::load_all()
tmp.imp <- recode_imputed_data(ex$fit.imp, m = y,  list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES)
cur.country <- as.character(tmp.imp$COUNTRY[1])
c.file.name <- paste0("recoded_imputed_data_obj_",cur.country,"_imp",y,".rds")
c.file.name
x <- imp.files[1]#
  y <- 1#
  walk2(.x=imp.files, .y=1:nimp, \(x,y){#
    load(here::here(data.dir,x), ex <- new.env())#
    # ls.str(ex)#
    tmp.imp <- recode_imputed_data(ex$fit.imp, m = y,  list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES)#
    cur.country <- as.character(tmp.imp$COUNTRY[1])#
    c.file.name <- paste0("recoded_imputed_data_obj_",cur.country,"_imp",y,".rds")#
    readr::write_rds(tmp.imp, file = here::here(data.dir, c.file.name), compress = "gz")#
    rm(ex, tmp.imp)#
    gc(full=TRUE)#
  })
x <- imp.files[1]#
  y <- 1#
  walk(.x=imp.files, \(x){#
    load(here::here(data.dir,x), ex <- new.env())#
    # ls.str(ex)#
    walk(.y=1:nimp, \(y){#
    		tmp.imp <- recode_imputed_data(ex$fit.imp, m = y,  list.default = RECODE.DEFAULTS,#
    	list.composites = LIST.COMPOSITES)#
    		cur.country <- as.character(tmp.imp$COUNTRY[1])#
    		c.file.name <- paste0("recoded_imputed_data_obj_",cur.country,"_imp",y,".rds")#
    		readr::write_rds(tmp.imp, file = here::here(data.dir, c.file.name), compress = "gz")#
    })#
    rm(ex, tmp.imp)#
    gc(full=TRUE)#
  })
x <- imp.files[1]#
  y <- 1#
  walk(imp.files, \(x){#
    load(here::here(data.dir,x), ex <- new.env())#
    # ls.str(ex)#
    walk(1:nimp, \(y){#
    		tmp.imp <- recode_imputed_data(ex$fit.imp, m = y,  list.default = RECODE.DEFAULTS,#
    	list.composites = LIST.COMPOSITES)#
    		cur.country <- as.character(tmp.imp$COUNTRY[1])#
    		c.file.name <- paste0("recoded_imputed_data_obj_",cur.country,"_imp",y,".rds")#
    		readr::write_rds(tmp.imp, file = here::here(data.dir, c.file.name), compress = "gz")#
    })#
    rm(ex, tmp.imp)#
    gc(full=TRUE)#
  })
warnings()
devtools::load_all()
attr.pred = c(#
    "ANNUAL_WEIGHT_R2", "MODE_RECRUIT",#
    'COMPOSITE_HAPPI_LIFE_SAT_Y1', 'COMPOSITE_HEALTH_Y1', 'COMPOSITE_MEANING_PURPOSE_Y1',#
    'COMPOSITE_CHARACTER_Y1', 'COMPOSITE_SUBJECTIVE_SOC_CONN_Y1', 'COMPOSITE_FINL_MAT_WORRY_Y1',#
    'COMPOSITE_EXTRAVERSION_Y1', 'COMPOSITE_OPENNESS_Y1', 'COMPOSITE_AGREEABLENESS_Y1',#
    'COMPOSITE_CONSCIENTIOUSNESS_Y1', 'COMPOSITE_NEUROTICISM_Y1',#
    'COMPOSITE_DEPRESSION_Y1', 'COMPOSITE_ANXIETY_Y1', 'LONELY_Y1', 'DAYS_EXERCISE_Y1',#
    'COV_AGE_GRP_Y1', 'COV_GENDER', 'COV_MARITAL_STATUS_Y1', 'COV_EMPLOYMENT_Y1',#
    'COV_ATTEND_SVCS_Y1', 'COV_EDUCATION_3_Y1', 'COV_BORN_COUNTRY_Y1', "COV_RACE_PLURALITY",#
    "COV_URBAN_RURAL_Y1", 'COV_INCOME_Y1'#
  )
obs.id.var = "CASE_OBSERVED_Y2"
wgt = "ANNUAL_WEIGHT_R2"
strata = "STRATA"
psu = "PSU"
pooled.wgt = as.name("AVG.SAMP.ATTR.WGT")
composite.wgt.name = as.name("SAMP.ATTR.WGT")
df.files <- list.files(data.dir)
df.files
df.files <- df.files[str_detect(df.files, "recoded_imputed_data_obj")]
df.files
country.vec <- str_remove(df.files, "recoded_imputed_data_obj_") |>#
    stringr::word(1, sep = "\\_imp")
country.vec
country.vec <- str_remove(df.files, "recoded_imputed_data_obj_") |>#
    stringr::word(1, sep = "\\_imp") |>#
    unique() |> #
    sort()
country.vec
country.vec
x <- country.vec[1]
tmp.files <- df.files[str_detect(df.files,x)]
tmp.files
y <- tmp.files[1]
cur.imp <- str_remove(y, "recoded_imputed_data_obj_") |>#
        str_remove(stringr::word(1, sep = "\\_imp")) |>#
        str_remove("_imp") |>#
        str_remove(".rds")
cur.imp
str_remove(y, "recoded_imputed_data_obj_")
str_remove(y, "recoded_imputed_data_obj_") |>#
        str_remove(stringr::word(1, sep = "\\_imp"))
str_remove(y, "recoded_imputed_data_obj_") |>#
        str_remove(x) |>#
        str_remove("_imp") |>#
        str_remove(".rds")
df.tmp <- readr::read_rds(here::here(data.dir, y))
df.tmp
df.attr <- map(tmp.files, \(y){#
      df.tmp <- readr::read_rds(here::here(data.dir, y))#
      df.tmp %>%#
        dplyr::group_by(COUNTRY, .imp) %>%#
        tidyr::nest() %>%#
        dplyr::mutate(#
          fit.attr = purrr::map(data, \(tmp.dat){#
            fit_attrition_model(tmp.dat, ...)#
          }),#
          data = map(fit.attr, \(x){#
            create_attr_wgts(x, ...)#
          })#
        )#
    	})
df.attr <- map(tmp.files, \(y){#
      df.tmp <- readr::read_rds(here::here(data.dir, y))#
      df.tmp %>%#
        dplyr::group_by(COUNTRY, .imp) %>%#
        tidyr::nest() %>%#
        dplyr::mutate(#
          fit.attr = purrr::map(data, \(tmp.dat){#
            fit_attrition_model(tmp.dat)#
          }),#
          data = map(fit.attr, \(x){#
            create_attr_wgts(x)#
          })#
        )#
    	})
devtools::load_all()
df.attr <- map(tmp.files, \(y){#
      df.tmp <- readr::read_rds(here::here(data.dir, y))#
      df.tmp %>%#
        dplyr::group_by(COUNTRY, .imp) %>%#
        tidyr::nest() %>%#
        dplyr::mutate(#
          fit.attr = purrr::map(data, \(tmp.dat){#
            fit_attrition_model(tmp.dat)#
          }),#
          data = map(fit.attr, \(x){#
            create_attr_wgts(x)#
          })#
        )#
    	})
devtools::load_all()
df.attr <- map(tmp.files, \(y){#
      df.tmp <- readr::read_rds(here::here(data.dir, y))#
      df.tmp %>%#
        dplyr::group_by(COUNTRY, .imp) %>%#
        tidyr::nest() %>%#
        dplyr::mutate(#
          fit.attr = purrr::map(data, \(tmp.dat){#
            fit_attrition_model(tmp.dat)#
          }),#
          data = map(fit.attr, \(x){#
            create_attr_wgts(x)#
          })#
        )#
    	})
object.size(df.attr)
object.size(df.attr)/(1024^3)
object.size(df.attr)
colnames(df.attr)
names(df.attr)
df.attr
df.attr <- map(tmp.files, \(y){#
      df.tmp <- readr::read_rds(here::here(data.dir, y))#
      df.tmp %>%#
        dplyr::group_by(COUNTRY, .imp) %>%#
        tidyr::nest() %>%#
        dplyr::mutate(#
          fit.attr = purrr::map(data, \(tmp.dat){#
            fit_attrition_model(tmp.dat)#
          }),#
          data = map(fit.attr, \(x){#
            create_attr_wgts(x)#
          })#
        )#
    	}) |>#
    	bind_rows()
df.attr
object.size(df.attr)
object.size(df.attr)/(1024^3)
composite.wgt.name
pooled.wgt
df.wgts <- df.attr %>%#
      select(COUNTRY, .imp, data) %>%#
      tidyr::unnest(c(data)) %>%#
      group_by(COUNTRY, ID) %>%#
      mutate(#
        "{{pooled.wgt}}" := mean({{composite.wgt.name}}, na.rm=TRUE)#
      ) %>%#
      ungroup() %>%#
      select(ID, COUNTRY, .imp, PSU, STRATA, contains("WGT"))
myfile = paste0(cur.country, " fitted attrition model.RData")
cur.country
x
devtools::load_all()
run_attrition_model_by_country(#
  data.dir,#
  obs.id.var = "CASE_OBSERVED_Y2",#
  attr.pred = c(#
    "ANNUAL_WEIGHT_R2", "MODE_RECRUIT",#
    'COMPOSITE_HAPPI_LIFE_SAT_Y1', 'COMPOSITE_HEALTH_Y1', 'COMPOSITE_MEANING_PURPOSE_Y1',#
    'COMPOSITE_CHARACTER_Y1', 'COMPOSITE_SUBJECTIVE_SOC_CONN_Y1', 'COMPOSITE_FINL_MAT_WORRY_Y1',#
    'COMPOSITE_EXTRAVERSION_Y1', 'COMPOSITE_OPENNESS_Y1', 'COMPOSITE_AGREEABLENESS_Y1',#
    'COMPOSITE_CONSCIENTIOUSNESS_Y1', 'COMPOSITE_NEUROTICISM_Y1',#
    'COMPOSITE_DEPRESSION_Y1', 'COMPOSITE_ANXIETY_Y1', 'LONELY_Y1', 'DAYS_EXERCISE_Y1',#
    'COV_AGE_GRP_Y1', 'COV_GENDER', 'COV_MARITAL_STATUS_Y1', 'COV_EMPLOYMENT_Y1',#
    'COV_ATTEND_SVCS_Y1', 'COV_EDUCATION_3_Y1', 'COV_BORN_COUNTRY_Y1', "COV_RACE_PLURALITY",#
    "COV_URBAN_RURAL_Y1", 'COV_INCOME_Y1'#
  ),#
  wgt = "ANNUAL_WEIGHT_R2", strata = "STRATA", psu = "PSU"#
)
append_attr_wgts_to_imp_data(data.dir, attr.dir = "results-attr")
VARIABLES.VEC <- RECODE.DEFAULTS[['VARIABLES.VEC']]#
OUTCOME.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "_Y2")]#
CONTEMPORANEOUS.EXPOSURES.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "COMPOSITE", negate = TRUE)]#
CONTEMPORANEOUS.EXPOSURES.VEC <- CONTEMPORANEOUS.EXPOSURES.VEC[str_detect(CONTEMPORANEOUS.EXPOSURES.VEC, "_Y1")]#
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER_Y1",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)#
# Run country-specific regression analyses for ALL wave 2 outcomes#
OUTCOME.VEC0 <- OUTCOME.VEC # c(1, 8, 24)+76,#
your.outcome <- OUTCOME.VEC0[2]
y <- FOCAL_PREDICTOR[1]
your.outcome = x
your.pred = y
wgt = as.name("ANNUAL_WEIGHT_R2")
psu = as.name("PSU")
strata = as.name("STRATA")
covariates = DEMO.CHILDHOOD.PRED
contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC
list.composites = LIST.COMPOSITES[[1]]
standardize = TRUE
pc.rule = "omit"
res.dir = "results-primary"
appnd.txt.to.filename = "_primary_wopc"
subpopulation = NULL
covariates <- covariates[str_detect(str_remove(covariates, "COV_"), your.pred, negate = TRUE)]
covariates
var.cont.exposures <- contemporaneous.exposures[str_detect(contemporaneous.exposures, your.pred, negate = TRUE)]
var.cont.exposures
# construct "type" indicator#
      outcome.type <- case_when(#
        get_outcome_scale(your.outcome) %in% c("cont", "Continuous") ~ "linear",#
        get_outcome_scale(your.outcome) %in% c("bin", "likert") ~ "RR",#
        .default = "linear"#
      )#
      outcome.type <- case_when(#
        force.binary ~ "RR",#
        force.linear ~ "linear",#
        .default = outcome.type#
      )#
#
      df.files <- list.files(data.dir)#
      df.files <- df.files[str_detect(df.files, "recoded_imputed_data_obj")]#
      country.vec <- str_remove(df.files, "recoded_imputed_data_obj_") |>#
        stringr::word(1, sep = "\\_imp")
outcome.type
your.outcome
OUTCOME.VEC
OUTCOME.VEC0 <- OUTCOME.VEC # c(1, 8, 24)+76,
x <- OUTCOME.VEC0[2]
x
your.outcome = x
outcome.type
your.outcome
get_outcome_scale(your.outcome)
outcome.type <- case_when(#
        get_outcome_scale(your.outcome) %in% c("cont", "Continuous") ~ "linear",#
        get_outcome_scale(your.outcome) %in% c("bin", "likert") ~ "RR",#
        .default = "linear"#
      )
df.files <- list.files(data.dir)#
      df.files <- df.files[str_detect(df.files, "recoded_imputed_data_obj")]#
      country.vec <- str_remove(df.files, "recoded_imputed_data_obj_") |>#
        stringr::word(1, sep = "\\_imp")
country.vec
df.files <- list.files(data.dir)#
      df.files <- df.files[str_detect(df.files, "recoded_imputed_data_obj")]#
      country.vec <- str_remove(df.files, "recoded_imputed_data_obj_") |>#
        stringr::word(1, sep = "\\_imp") |>#
        unique() |>#
        sort()
country.vec
x <- country.vec[1]
country.files <- df.files[str_detect(df.files, x)]
country.files
.check_if_valid_comb <- function(){#
          out <- TRUE#
#
          if (str_detect(your.outcome,"APPROVE_GOVT") | str_detect(your.pred,"APPROVE_GOVT")) {#
            if(cur.country %in% c("China","Egypt") ){#
              out <- FALSE#
            }#
          }#
          if (str_detect(your.outcome,"ABUSED") | str_detect(your.pred,"ABUSED")) {#
#
            if(cur.country %in% c("Israel") ){#
              out <- FALSE#
            }#
#
          }#
          if(str_detect(your.outcome,"BELIEVE_GOD") | str_detect(your.pred,"BELIEVE_GOD")) {#
            if(cur.country %in% c("Egypt") ){#
              out <- FALSE#
            }#
          }#
          if (str_detect(your.outcome,"BELONGING") | str_detect(your.pred,"BELONGING")) {#
            if(cur.country %in% c("China") ){#
              out <- FALSE#
            }#
          }#
          if (str_detect(your.outcome,"SAY_IN_GOVT") | str_detect(your.pred,"SAY_IN_GOVT")) {#
            if(cur.country %in% c("China") ){#
              out <- FALSE#
            }#
          }#
#
          out#
        }
.get_data <- function(file){#
          data <- readr::read_rds(here::here(data.dir, file))#
          ## code for direct subset (NOT SUBPOPULATUON)#
          if(!is.null(direct.subset)){#
            data <- subset(data, eval(direct.subset))#
            data <- data %>%#
              mutate(#
                "{{wgt}}" := n() * {{wgt}} / sum( {{wgt}} , na.rm = TRUE)#
              )#
          }#
          # convert to nested survey object#
          svy.data.imp <- data %>%#
            mutate(#
              COUNTRY = COUNTRY2,#
              .imp00 = .imp#
            ) %>%#
            group_by(COUNTRY, .imp) %>%#
            nest() %>%#
            mutate(#
              data = map(data, \(x) {#
                x$PRIMARY_OUTCOME <- as.numeric(x[, your.outcome, drop = TRUE])#
                x#
              }),#
              data = map(data, \(x) {#
                x$FOCAL_PREDICTOR <- as.numeric(x[, your.pred, drop = TRUE])#
                x#
              }),#
              data = map(data, \(x) {#
                x %>% mutate(#
                  PRIMARY_OUTCOME = case_when(#
                    standardize == FALSE ~ PRIMARY_OUTCOME,#
                    outcome.type == "linear" & standardize == TRUE ~ svy_scale(PRIMARY_OUTCOME, {{wgt}}, {{psu}}, {{strata}}),#
                    .default = PRIMARY_OUTCOME#
                  ),#
                  FOCAL_PREDICTOR = case_when(#
                    standardize == FALSE ~ FOCAL_PREDICTOR,#
                    outcome.type == "linear" & standardize == TRUE ~ svy_scale(FOCAL_PREDICTOR, {{wgt}}, {{psu}}, {{strata}}),#
                    .default = FOCAL_PREDICTOR#
                  )#
                )#
              }),#
              data = map(data, \(tmp.dat){#
                tmp.dat %>%#
                  mutate(across(where(is.factor), \(x) droplevels(x)))#
              }),#
              svy.data = map(data, \(x) {#
                x %>%#
                  as_survey_design(#
                    ids = {{psu}},#
                    strata = {{strata}},#
                    weights = {{wgt}},#
                    calibrate.formula = ~1#
                  )#
              })#
            )#
          if(!is.null(domain.subset)){#
            svy.data.imp <- svy.data.imp %>%#
              mutate(#
                data = map(data, \(x){#
                  subset(x, eval(domain.subset))#
                }),#
                svy.data = map(svy.data, \(x){#
                  subset(x, eval(domain.subset))#
                })#
              )#
          }#
          svy.data.imp#
        }
domain.subset
domain.subset = NULL
direct.subset = NULL
direct.subset
force.linear = FALSE
force.binary = FALSE
.get_data <- function(file){#
          data <- readr::read_rds(here::here(data.dir, file))#
          ## code for direct subset (NOT SUBPOPULATUON)#
          if(!is.null(direct.subset)){#
            data <- subset(data, eval(direct.subset))#
            data <- data %>%#
              mutate(#
                "{{wgt}}" := n() * {{wgt}} / sum( {{wgt}} , na.rm = TRUE)#
              )#
          }#
          # convert to nested survey object#
          svy.data.imp <- data %>%#
            mutate(#
              COUNTRY = COUNTRY2,#
              .imp00 = .imp#
            ) %>%#
            group_by(COUNTRY, .imp) %>%#
            nest() %>%#
            mutate(#
              data = map(data, \(x) {#
                x$PRIMARY_OUTCOME <- as.numeric(x[, your.outcome, drop = TRUE])#
                x#
              }),#
              data = map(data, \(x) {#
                x$FOCAL_PREDICTOR <- as.numeric(x[, your.pred, drop = TRUE])#
                x#
              }),#
              data = map(data, \(x) {#
                x %>% mutate(#
                  PRIMARY_OUTCOME = case_when(#
                    standardize == FALSE ~ PRIMARY_OUTCOME,#
                    outcome.type == "linear" & standardize == TRUE ~ svy_scale(PRIMARY_OUTCOME, {{wgt}}, {{psu}}, {{strata}}),#
                    .default = PRIMARY_OUTCOME#
                  ),#
                  FOCAL_PREDICTOR = case_when(#
                    standardize == FALSE ~ FOCAL_PREDICTOR,#
                    outcome.type == "linear" & standardize == TRUE ~ svy_scale(FOCAL_PREDICTOR, {{wgt}}, {{psu}}, {{strata}}),#
                    .default = FOCAL_PREDICTOR#
                  )#
                )#
              }),#
              data = map(data, \(tmp.dat){#
                tmp.dat %>%#
                  mutate(across(where(is.factor), \(x) droplevels(x)))#
              }),#
              svy.data = map(data, \(x) {#
                x %>%#
                  as_survey_design(#
                    ids = {{psu}},#
                    strata = {{strata}},#
                    weights = {{wgt}},#
                    calibrate.formula = ~1#
                  )#
              })#
            )#
          if(!is.null(domain.subset)){#
            svy.data.imp <- svy.data.imp %>%#
              mutate(#
                data = map(data, \(x){#
                  subset(x, eval(domain.subset))#
                }),#
                svy.data = map(svy.data, \(x){#
                  subset(x, eval(domain.subset))#
                })#
              )#
          }#
          svy.data.imp#
        }
.check_if_valid_comb()
country.files
x <- country.files[1]
svy.data.imp <- .get_data(x)
head(svy.data.imp)
fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
            if( str_to_lower(pc.rule) != "omit"){#
              svy.data.imp <- svy.data.imp %>%#
                mutate(#
                  data = map(data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  svy.data = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  fit.pca = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    svyprcomp(#
                      reformulate(var.cont.exposures[keep.cont.exposures]),#
                      design = x,#
                      scale. = TRUE,#
                      scores = TRUE,#
                      center = TRUE#
                    )#
                  }),#
                  fit.eigen = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
                  })#
                )#
              # get summary of PCA results to save to output file#
              fit.pca.summary <- svy.data.imp %>%#
                mutate(#
                  pc.sdev = map(fit.pca, \(x) x$sdev),#
                  pc.rotation = map(fit.pca, \(x) x$rotation)#
                ) %>%#
                select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
                unnest(c(pc.sdev, fit.eigen)) %>%#
                mutate(#
                  PC = 1:n()#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY, PC) %>%#
                summarise(#
                  pc.var = mean(pc.sdev**2, na.rm = TRUE)#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY) %>%#
                mutate(#
                  prop.var = pc.var / sum(pc.var),#
                  prop.sum = cumsum(prop.var),#
                  Cumulative_Proportion_Explained = prop.sum#
                )#
#
              # check pc.cutoff to determine which PCs to use#
              if (pc.cutoff %% 1 == 0) {#
                keep.num.pc <- rep(pc.cutoff, length(unique(data$COUNTRY2)))#
                names(keep.num.pc) <- unique(data$COUNTRY2)#
              } else {#
                # number of PCs varies by counry based on the total or individual PC % of the variation in the confounders the set of PC account for.#
                if (str_to_lower(pc.rule) == "mintotal") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.sum >= pc.cutoff) %>%#
                    dplyr::filter(PC == min(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "mincomp") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.var >= pc.cutoff)#
                  if (nrow(keep.num.pc0) < 23) {#
                    # cutoff fails because too stringent, switching to a default of 0.02#
                    keep.num.pc0 <- fit.pca.summary %>%#
                      dplyr::filter(prop.var >= 0.02)#
                  }#
                  keep.num.pc0 <- keep.num.pc0 %>%#
                    dplyr::filter(PC == max(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "omit") {#
                  # this is just to avoid errors and is not used#
                  keep.num.pc <- rep(0, length(unique(data$COUNTRY2)))#
                  names(keep.num.pc) <- unique(data$COUNTRY2)#
                }#
              }#
              tmp.df.pca <- data.frame(#
                COUNTRY = names(keep.num.pc),#
                NumPCAkeep = keep.num.pc#
              )#
              tmp.df.pca$Rule <- pc.rule#
              tmp.df.pca$Cutoff <- pc.cutoff#
              fit.pca.summary <- dplyr::left_join(fit.pca.summary, tmp.df.pca)#
            }
svy.data.imp <- svy.data.imp %>%#
              dplyr::mutate(#
                svy.fit = purrr::map(svy.data, \(x) {#
                  tmp.fit <- NULL#
                  # first check if ANY variance on outomce#
                  run.analysis <- ifelse(var(x[["variables"]][["PRIMARY_OUTCOME"]], na.rm=TRUE) > 0, TRUE, FALSE)#
                  if (run.analysis) {#
                    cur.country <- x[["variables"]][["COUNTRY2"]][1]#
                    # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
                    keep.var <- keep_variable(covariates, data = x[["variables"]])#
                    if (str_to_lower(pc.rule) == "omit") {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
                      )#
                    } else {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[cur.country])))#
                      )#
                    }#
#
                    if (outcome.type == "linear") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::gaussian(),#
                        robust.huberM = robust.huberM,#
                        robust.tune = robust.tune#
                      )#
                    }#
                    if (outcome.type == "RR") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::quassipoisson(),#
                        robust.huberM = FALSE#
                      )#
                    }#
                    tmp.fit#
                  }#
                }),#
                fit.tidy = map(svy.fit, \(x) x$fit.tidy)#
              ) %>%#
              select(fit.tidy) %>%#
              ungroup()
out <- list(#
              fit.reg = svy.data.imp,#
              fit.pca = fit.pca.summary#
            )
out
fitted.reg.models <- map(country.files,\(x){#
            svy.data.imp <- .get_data(x)#
            # IF: pc.rule NOT omit#
            # Conduct PCA and add PCs to data.frames#
            fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
            if( str_to_lower(pc.rule) != "omit"){#
              svy.data.imp <- svy.data.imp %>%#
                mutate(#
                  data = map(data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  svy.data = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  fit.pca = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    svyprcomp(#
                      reformulate(var.cont.exposures[keep.cont.exposures]),#
                      design = x,#
                      scale. = TRUE,#
                      scores = TRUE,#
                      center = TRUE#
                    )#
                  }),#
                  fit.eigen = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
                  })#
                )#
              # get summary of PCA results to save to output file#
              fit.pca.summary <- svy.data.imp %>%#
                mutate(#
                  pc.sdev = map(fit.pca, \(x) x$sdev),#
                  pc.rotation = map(fit.pca, \(x) x$rotation)#
                ) %>%#
                select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
                unnest(c(pc.sdev, fit.eigen)) %>%#
                mutate(#
                  PC = 1:n()#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY, PC) %>%#
                summarise(#
                  pc.var = mean(pc.sdev**2, na.rm = TRUE)#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY) %>%#
                mutate(#
                  prop.var = pc.var / sum(pc.var),#
                  prop.sum = cumsum(prop.var),#
                  Cumulative_Proportion_Explained = prop.sum#
                )#
#
              # check pc.cutoff to determine which PCs to use#
              if (pc.cutoff %% 1 == 0) {#
                keep.num.pc <- rep(pc.cutoff, length(unique(data$COUNTRY2)))#
                names(keep.num.pc) <- unique(data$COUNTRY2)#
              } else {#
                # number of PCs varies by counry based on the total or individual PC % of the variation in the confounders the set of PC account for.#
                if (str_to_lower(pc.rule) == "mintotal") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.sum >= pc.cutoff) %>%#
                    dplyr::filter(PC == min(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "mincomp") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.var >= pc.cutoff)#
                  if (nrow(keep.num.pc0) < 23) {#
                    # cutoff fails because too stringent, switching to a default of 0.02#
                    keep.num.pc0 <- fit.pca.summary %>%#
                      dplyr::filter(prop.var >= 0.02)#
                  }#
                  keep.num.pc0 <- keep.num.pc0 %>%#
                    dplyr::filter(PC == max(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "omit") {#
                  # this is just to avoid errors and is not used#
                  keep.num.pc <- rep(0, length(unique(data$COUNTRY2)))#
                  names(keep.num.pc) <- unique(data$COUNTRY2)#
                }#
              }#
              tmp.df.pca <- data.frame(#
                COUNTRY = names(keep.num.pc),#
                NumPCAkeep = keep.num.pc#
              )#
              tmp.df.pca$Rule <- pc.rule#
              tmp.df.pca$Cutoff <- pc.cutoff#
              fit.pca.summary <- dplyr::left_join(fit.pca.summary, tmp.df.pca)#
            }#
            # ============================================================================================== ##
            # RUN REGRESSION ANALYSIS#
            # svy.data.imp is a nested df by country & .imp#
            svy.data.imp <- svy.data.imp %>%#
              dplyr::mutate(#
                svy.fit = purrr::map(svy.data, \(x) {#
                  tmp.fit <- NULL#
                  # first check if ANY variance on outomce#
                  run.analysis <- ifelse(var(x[["variables"]][["PRIMARY_OUTCOME"]], na.rm=TRUE) > 0, TRUE, FALSE)#
                  if (run.analysis) {#
                    cur.country <- x[["variables"]][["COUNTRY2"]][1]#
                    # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
                    keep.var <- keep_variable(covariates, data = x[["variables"]])#
                    if (str_to_lower(pc.rule) == "omit") {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
                      )#
                    } else {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[cur.country])))#
                      )#
                    }#
#
                    if (outcome.type == "linear") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::gaussian(),#
                        robust.huberM = robust.huberM,#
                        robust.tune = robust.tune#
                      )#
                    }#
                    if (outcome.type == "RR") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::quassipoisson(),#
                        robust.huberM = FALSE#
                      )#
                    }#
                    tmp.fit#
                  }#
                }),#
                fit.tidy = map(svy.fit, \(x) x$fit.tidy)#
              ) %>%#
              select(fit.tidy) %>%#
              ungroup()#
#
            out <- list(#
              fit.reg = svy.data.imp,#
              fit.pca = fit.pca.summary#
            )#
            out#
          })
# re-estimate basic model with the max number of PCs used to get the variable names#
          tmp.dat <- .get_data(country.files[1])#
          keep.var <- rep(FALSE, length(covariates))#
          for(i in 1:length(keep.var)){#
            if(covariates[i] %in% colnames(svy.data.imp$data[[1]])){#
              keep.var[i] <- keep_variable(covariates[i], data = svy.data.imp$data[[1]])#
            }#
          }#
          if (str_to_lower(pc.rule) == "omit") {#
            tmp.model <- reformulate(#
              response = "PRIMARY_OUTCOME",#
              termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
            )#
          } else {#
            tmp.country <- names(keep.num.pc)[which(keep.num.pc == max(keep.num.pc))[1]]#
            tmp.model <- reformulate(#
              response = "PRIMARY_OUTCOME",#
              termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[tmp.country])))#
            )#
          }#
          tmp.fit <- svy.data.imp$data[[1]] %>% glm(tmp.model, data = .)
warnings()
tmp.dat <- .get_data(country.files[1])
keep.var <- rep(FALSE, length(covariates))
# re-estimate basic model with the max number of PCs used to get the variable names#
          tmp.dat <- .get_data(country.files[1])#
          keep.var <- rep(FALSE, length(covariates))#
          for(i in 1:length(keep.var)){#
            if(covariates[i] %in% colnames(tmp.dat$data[[1]])){#
              keep.var[i] <- keep_variable(covariates[i], data = tmp.dat$data[[1]])#
            }#
          }#
          if (str_to_lower(pc.rule) == "omit") {#
            tmp.model <- reformulate(#
              response = "PRIMARY_OUTCOME",#
              termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
            )#
          } else {#
            tmp.country <- names(keep.num.pc)[which(keep.num.pc == max(keep.num.pc))[1]]#
            tmp.model <- reformulate(#
              response = "PRIMARY_OUTCOME",#
              termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[tmp.country])))#
            )#
          }#
          tmp.fit <- tmp.dat$data[[1]] %>% glm(tmp.model, data = .)
coef.order <- names(tmp.fit$coefficients)#
          coef.order <- c(#
            coef.order[!(stringr::str_detect(coef.order, "(Intercept)") | stringr::str_detect(coef.order, "COV_REL1"))],#
            "COV_GENDER_Y1Prefer not to answer",#
            "COV_REL1_Y1Islam", "COV_REL1_Y1Hinduism", "COV_REL1_Y1Judaism", "COV_REL1_Y1Buddhism",#
            "COV_REL1_Y1Primal,Animist, or Folk religion", "COV_REL1_Y1Chinesefolk/traditional religion",#
            "COV_REL1_Y1Christianity", "COV_REL1_Y1Combined",#
            "(Intercept)"#
          )
class(fitted.reg.models)
names(fitted.reg.models)
fitted.reg.models[['fit.reg']]
fit.pca.summary <- map(country.files,\(x){#
            svy.data.imp <- .get_data(x)#
            # IF: pc.rule NOT omit#
            # Conduct PCA and add PCs to data.frames#
            fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
            if( str_to_lower(pc.rule) != "omit"){#
              svy.data.imp <- svy.data.imp %>%#
                mutate(#
                  data = map(data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  svy.data = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  fit.pca = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    svyprcomp(#
                      reformulate(var.cont.exposures[keep.cont.exposures]),#
                      design = x,#
                      scale. = TRUE,#
                      scores = TRUE,#
                      center = TRUE#
                    )#
                  }),#
                  fit.eigen = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
                  })#
                )#
              # get summary of PCA results to save to output file#
              fit.pca.summary <- svy.data.imp %>%#
                mutate(#
                  pc.sdev = map(fit.pca, \(x) x$sdev),#
                  pc.rotation = map(fit.pca, \(x) x$rotation)#
                ) %>%#
                select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
                unnest(c(pc.sdev, fit.eigen)) %>%#
                mutate(#
                  PC = 1:n()#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY, PC) %>%#
                summarise(#
                  pc.var = mean(pc.sdev**2, na.rm = TRUE)#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY) %>%#
                mutate(#
                  prop.var = pc.var / sum(pc.var),#
                  prop.sum = cumsum(prop.var),#
                  Cumulative_Proportion_Explained = prop.sum#
                )#
                fit.pca.summary#
           }) |> bind_rows()
fit.pca.summary <- map(country.files,\(x){#
            svy.data.imp <- .get_data(x)#
            # IF: pc.rule NOT omit#
            # Conduct PCA and add PCs to data.frames#
            fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
            if( str_to_lower(pc.rule) != "omit"){#
              svy.data.imp <- svy.data.imp %>%#
                mutate(#
                  data = map(data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  svy.data = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  fit.pca = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    svyprcomp(#
                      reformulate(var.cont.exposures[keep.cont.exposures]),#
                      design = x,#
                      scale. = TRUE,#
                      scores = TRUE,#
                      center = TRUE#
                    )#
                  }),#
                  fit.eigen = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
                  })#
                )#
              # get summary of PCA results to save to output file#
              fit.pca.summary <- svy.data.imp %>%#
                mutate(#
                  pc.sdev = map(fit.pca, \(x) x$sdev),#
                  pc.rotation = map(fit.pca, \(x) x$rotation)#
                ) %>%#
                select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
                unnest(c(pc.sdev, fit.eigen)) %>%#
                mutate(#
                  PC = 1:n()#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY, PC) %>%#
                summarise(#
                  pc.var = mean(pc.sdev**2, na.rm = TRUE)#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY) %>%#
                mutate(#
                  prop.var = pc.var / sum(pc.var),#
                  prop.sum = cumsum(prop.var),#
                  Cumulative_Proportion_Explained = prop.sum#
                )#
              }#
                fit.pca.summary#
           }) |> bind_rows()
fit.pca.summary
fit.pca.summary <- map(country.files,\(x){#
            svy.data.imp <- .get_data(x)#
            # IF: pc.rule NOT omit#
            # Conduct PCA and add PCs to data.frames#
              svy.data.imp <- svy.data.imp %>%#
                mutate(#
                  data = map(data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  svy.data = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  fit.pca = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    svyprcomp(#
                      reformulate(var.cont.exposures[keep.cont.exposures]),#
                      design = x,#
                      scale. = TRUE,#
                      scores = TRUE,#
                      center = TRUE#
                    )#
                  }),#
                  fit.eigen = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
                  })#
                )#
              # get summary of PCA results to save to output file#
              fit.pca.summary <- svy.data.imp %>%#
                mutate(#
                  pc.sdev = map(fit.pca, \(x) x$sdev),#
                  pc.rotation = map(fit.pca, \(x) x$rotation)#
                ) %>%#
                select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
                unnest(c(pc.sdev, fit.eigen)) %>%#
                mutate(#
                  PC = 1:n()#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY, PC) %>%#
                summarise(#
                  pc.var = mean(pc.sdev**2, na.rm = TRUE)#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY) %>%#
                mutate(#
                  prop.var = pc.var / sum(pc.var),#
                  prop.sum = cumsum(prop.var),#
                  Cumulative_Proportion_Explained = prop.sum#
                )           #
                fit.pca.summary#
           }) |> bind_rows()
fit.pca.summary
svy.data.imp <- .get_data(x)#
            # IF: pc.rule NOT omit#
            # Conduct PCA and add PCs to data.frames#
            fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
            if( str_to_lower(pc.rule) != "omit"){#
              svy.data.imp <- svy.data.imp %>%#
                mutate(#
                  data = map(data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  svy.data = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  fit.pca = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    svyprcomp(#
                      reformulate(var.cont.exposures[keep.cont.exposures]),#
                      design = x,#
                      scale. = TRUE,#
                      scores = TRUE,#
                      center = TRUE#
                    )#
                  }),#
                  fit.eigen = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
                  })#
                )#
              # get summary of PCA results to save to output file#
              fit.pca.summary <- svy.data.imp %>%#
                mutate(#
                  pc.sdev = map(fit.pca, \(x) x$sdev),#
                  pc.rotation = map(fit.pca, \(x) x$rotation)#
                ) %>%#
                select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
                unnest(c(pc.sdev, fit.eigen)) %>%#
                mutate(#
                  PC = 1:n()#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY, PC) %>%#
                summarise(#
                  pc.var = mean(pc.sdev**2, na.rm = TRUE)#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY) %>%#
                mutate(#
                  prop.var = pc.var / sum(pc.var),#
                  prop.sum = cumsum(prop.var),#
                  Cumulative_Proportion_Explained = prop.sum#
                )#
#
              # check pc.cutoff to determine which PCs to use#
              if (pc.cutoff %% 1 == 0) {#
                keep.num.pc <- rep(pc.cutoff, length(unique(data$COUNTRY2)))#
                names(keep.num.pc) <- unique(data$COUNTRY2)#
              } else {#
                # number of PCs varies by counry based on the total or individual PC % of the variation in the confounders the set of PC account for.#
                if (str_to_lower(pc.rule) == "mintotal") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.sum >= pc.cutoff) %>%#
                    dplyr::filter(PC == min(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "mincomp") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.var >= pc.cutoff)#
                  if (nrow(keep.num.pc0) < 23) {#
                    # cutoff fails because too stringent, switching to a default of 0.02#
                    keep.num.pc0 <- fit.pca.summary %>%#
                      dplyr::filter(prop.var >= 0.02)#
                  }#
                  keep.num.pc0 <- keep.num.pc0 %>%#
                    dplyr::filter(PC == max(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "omit") {#
                  # this is just to avoid errors and is not used#
                  keep.num.pc <- rep(0, length(unique(data$COUNTRY2)))#
                  names(keep.num.pc) <- unique(data$COUNTRY2)#
                }#
              }#
              tmp.df.pca <- data.frame(#
                COUNTRY = names(keep.num.pc),#
                NumPCAkeep = keep.num.pc#
              )#
              tmp.df.pca$Rule <- pc.rule#
              tmp.df.pca$Cutoff <- pc.cutoff#
              fit.pca.summary <- dplyr::left_join(fit.pca.summary, tmp.df.pca)#
            }
svy.data.imp <- svy.data.imp %>%#
              dplyr::mutate(#
                svy.fit = purrr::map(svy.data, \(x) {#
                  tmp.fit <- NULL#
                  # first check if ANY variance on outomce#
                  run.analysis <- ifelse(var(x[["variables"]][["PRIMARY_OUTCOME"]], na.rm=TRUE) > 0, TRUE, FALSE)#
                  if (run.analysis) {#
                    cur.country <- x[["variables"]][["COUNTRY2"]][1]#
                    # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
                    keep.var <- keep_variable(covariates, data = x[["variables"]])#
                    if (str_to_lower(pc.rule) == "omit") {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
                      )#
                    } else {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[cur.country])))#
                      )#
                    }#
#
                    if (outcome.type == "linear") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::gaussian(),#
                        robust.huberM = robust.huberM,#
                        robust.tune = robust.tune#
                      )#
                    }#
                    if (outcome.type == "RR") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::quassipoisson(),#
                        robust.huberM = FALSE#
                      )#
                    }#
                    tmp.fit#
                  }#
                }),#
                fit.tidy = map(svy.fit, \(x) x$fit.tidy)#
              ) %>%#
              select(fit.tidy) %>%#
              ungroup()
fitted.reg.models <- map(country.files,\(x){#
            svy.data.imp <- .get_data(x)#
            # IF: pc.rule NOT omit#
            # Conduct PCA and add PCs to data.frames#
            fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
            if( str_to_lower(pc.rule) != "omit"){#
              svy.data.imp <- svy.data.imp %>%#
                mutate(#
                  data = map(data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  svy.data = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  fit.pca = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    svyprcomp(#
                      reformulate(var.cont.exposures[keep.cont.exposures]),#
                      design = x,#
                      scale. = TRUE,#
                      scores = TRUE,#
                      center = TRUE#
                    )#
                  }),#
                  fit.eigen = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
                  })#
                )#
              # get summary of PCA results to save to output file#
              fit.pca.summary <- svy.data.imp %>%#
                mutate(#
                  pc.sdev = map(fit.pca, \(x) x$sdev),#
                  pc.rotation = map(fit.pca, \(x) x$rotation)#
                ) %>%#
                select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
                unnest(c(pc.sdev, fit.eigen)) %>%#
                mutate(#
                  PC = 1:n()#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY, PC) %>%#
                summarise(#
                  pc.var = mean(pc.sdev**2, na.rm = TRUE)#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY) %>%#
                mutate(#
                  prop.var = pc.var / sum(pc.var),#
                  prop.sum = cumsum(prop.var),#
                  Cumulative_Proportion_Explained = prop.sum#
                )#
#
              # check pc.cutoff to determine which PCs to use#
              if (pc.cutoff %% 1 == 0) {#
                keep.num.pc <- rep(pc.cutoff, length(unique(data$COUNTRY2)))#
                names(keep.num.pc) <- unique(data$COUNTRY2)#
              } else {#
                # number of PCs varies by counry based on the total or individual PC % of the variation in the confounders the set of PC account for.#
                if (str_to_lower(pc.rule) == "mintotal") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.sum >= pc.cutoff) %>%#
                    dplyr::filter(PC == min(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "mincomp") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.var >= pc.cutoff)#
                  if (nrow(keep.num.pc0) < 23) {#
                    # cutoff fails because too stringent, switching to a default of 0.02#
                    keep.num.pc0 <- fit.pca.summary %>%#
                      dplyr::filter(prop.var >= 0.02)#
                  }#
                  keep.num.pc0 <- keep.num.pc0 %>%#
                    dplyr::filter(PC == max(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "omit") {#
                  # this is just to avoid errors and is not used#
                  keep.num.pc <- rep(0, length(unique(data$COUNTRY2)))#
                  names(keep.num.pc) <- unique(data$COUNTRY2)#
                }#
              }#
              tmp.df.pca <- data.frame(#
                COUNTRY = names(keep.num.pc),#
                NumPCAkeep = keep.num.pc#
              )#
              tmp.df.pca$Rule <- pc.rule#
              tmp.df.pca$Cutoff <- pc.cutoff#
              fit.pca.summary <- dplyr::left_join(fit.pca.summary, tmp.df.pca)#
            }#
            # ============================================================================================== ##
            # RUN REGRESSION ANALYSIS#
            # svy.data.imp is a nested df by country & .imp#
            svy.data.imp <- svy.data.imp %>%#
              dplyr::mutate(#
                svy.fit = purrr::map(svy.data, \(x) {#
                  tmp.fit <- NULL#
                  # first check if ANY variance on outomce#
                  run.analysis <- ifelse(var(x[["variables"]][["PRIMARY_OUTCOME"]], na.rm=TRUE) > 0, TRUE, FALSE)#
                  if (run.analysis) {#
                    cur.country <- x[["variables"]][["COUNTRY2"]][1]#
                    # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
                    keep.var <- keep_variable(covariates, data = x[["variables"]])#
                    if (str_to_lower(pc.rule) == "omit") {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
                      )#
                    } else {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[cur.country])))#
                      )#
                    }#
#
                    if (outcome.type == "linear") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::gaussian(),#
                        robust.huberM = robust.huberM,#
                        robust.tune = robust.tune#
                      )#
                    }#
                    if (outcome.type == "RR") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::quassipoisson(),#
                        robust.huberM = FALSE#
                      )#
                    }#
                    tmp.fit#
                  }#
                }),#
                fit.tidy = map(svy.fit, \(x) x$fit.tidy)#
              ) %>%#
              select(fit.tidy) %>%#
              ungroup()#
#
            svy.data.imp#
          })
fitted.reg.models
fitted.reg.models <- map(country.files,\(x){#
            svy.data.imp <- .get_data(x)#
            # IF: pc.rule NOT omit#
            # Conduct PCA and add PCs to data.frames#
            fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
            if( str_to_lower(pc.rule) != "omit"){#
              svy.data.imp <- svy.data.imp %>%#
                mutate(#
                  data = map(data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  svy.data = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
                  }),#
                  fit.pca = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    svyprcomp(#
                      reformulate(var.cont.exposures[keep.cont.exposures]),#
                      design = x,#
                      scale. = TRUE,#
                      scores = TRUE,#
                      center = TRUE#
                    )#
                  }),#
                  fit.eigen = map(svy.data, \(x) {#
                    keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
                    get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
                  })#
                )#
              # get summary of PCA results to save to output file#
              fit.pca.summary <- svy.data.imp %>%#
                mutate(#
                  pc.sdev = map(fit.pca, \(x) x$sdev),#
                  pc.rotation = map(fit.pca, \(x) x$rotation)#
                ) %>%#
                select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
                unnest(c(pc.sdev, fit.eigen)) %>%#
                mutate(#
                  PC = 1:n()#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY, PC) %>%#
                summarise(#
                  pc.var = mean(pc.sdev**2, na.rm = TRUE)#
                ) %>%#
                ungroup() %>%#
                group_by(COUNTRY) %>%#
                mutate(#
                  prop.var = pc.var / sum(pc.var),#
                  prop.sum = cumsum(prop.var),#
                  Cumulative_Proportion_Explained = prop.sum#
                )#
#
              # check pc.cutoff to determine which PCs to use#
              if (pc.cutoff %% 1 == 0) {#
                keep.num.pc <- rep(pc.cutoff, length(unique(data$COUNTRY2)))#
                names(keep.num.pc) <- unique(data$COUNTRY2)#
              } else {#
                # number of PCs varies by counry based on the total or individual PC % of the variation in the confounders the set of PC account for.#
                if (str_to_lower(pc.rule) == "mintotal") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.sum >= pc.cutoff) %>%#
                    dplyr::filter(PC == min(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "mincomp") {#
                  keep.num.pc0 <- fit.pca.summary %>%#
                    dplyr::filter(prop.var >= pc.cutoff)#
                  if (nrow(keep.num.pc0) < 23) {#
                    # cutoff fails because too stringent, switching to a default of 0.02#
                    keep.num.pc0 <- fit.pca.summary %>%#
                      dplyr::filter(prop.var >= 0.02)#
                  }#
                  keep.num.pc0 <- keep.num.pc0 %>%#
                    dplyr::filter(PC == max(PC, na.rm = TRUE))#
                  keep.num.pc <- keep.num.pc0$PC#
                  names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
                }#
                if (str_to_lower(pc.rule) == "omit") {#
                  # this is just to avoid errors and is not used#
                  keep.num.pc <- rep(0, length(unique(data$COUNTRY2)))#
                  names(keep.num.pc) <- unique(data$COUNTRY2)#
                }#
              }#
              tmp.df.pca <- data.frame(#
                COUNTRY = names(keep.num.pc),#
                NumPCAkeep = keep.num.pc#
              )#
              tmp.df.pca$Rule <- pc.rule#
              tmp.df.pca$Cutoff <- pc.cutoff#
              fit.pca.summary <- dplyr::left_join(fit.pca.summary, tmp.df.pca)#
            }#
            # ============================================================================================== ##
            # RUN REGRESSION ANALYSIS#
            # svy.data.imp is a nested df by country & .imp#
            svy.data.imp <- svy.data.imp %>%#
              dplyr::mutate(#
                svy.fit = purrr::map(svy.data, \(x) {#
                  tmp.fit <- NULL#
                  # first check if ANY variance on outomce#
                  run.analysis <- ifelse(var(x[["variables"]][["PRIMARY_OUTCOME"]], na.rm=TRUE) > 0, TRUE, FALSE)#
                  if (run.analysis) {#
                    cur.country <- x[["variables"]][["COUNTRY2"]][1]#
                    # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
                    keep.var <- keep_variable(covariates, data = x[["variables"]])#
                    if (str_to_lower(pc.rule) == "omit") {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
                      )#
                    } else {#
                      tmp.model <- reformulate(#
                        response = "PRIMARY_OUTCOME",#
                        termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[cur.country])))#
                      )#
                    }#
#
                    if (outcome.type == "linear") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::gaussian(),#
                        robust.huberM = robust.huberM,#
                        robust.tune = robust.tune#
                      )#
                    }#
                    if (outcome.type == "RR") {#
                      tmp.fit <- gfs_svyglm(#
                        tmp.model,#
                        svy.design = x,#
                        family = stats::quassipoisson(),#
                        robust.huberM = FALSE#
                      )#
                    }#
                    tmp.fit#
                  }#
                }),#
                fit.tidy = map(svy.fit, \(x) x$fit.tidy)#
              ) %>%#
              select(fit.tidy) %>%#
              ungroup()#
#
            svy.data.imp#
          }) |> bind_rows()
tmp.dat <- .get_data(country.files[1])#
          keep.var <- rep(FALSE, length(covariates))#
          for(i in 1:length(keep.var)){#
            if(covariates[i] %in% colnames(tmp.dat$data[[1]])){#
              keep.var[i] <- keep_variable(covariates[i], data = tmp.dat$data[[1]])#
            }#
          }#
          if (str_to_lower(pc.rule) == "omit") {#
            tmp.model <- reformulate(#
              response = "PRIMARY_OUTCOME",#
              termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
            )#
          } else {#
            tmp.country <- names(keep.num.pc)[which(keep.num.pc == max(keep.num.pc))[1]]#
            tmp.model <- reformulate(#
              response = "PRIMARY_OUTCOME",#
              termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[tmp.country])))#
            )#
          }#
          tmp.fit <- tmp.dat$data[[1]] %>% glm(tmp.model, data = .)
tmp.fit
coef.order <- names(tmp.fit$coefficients)#
          coef.order <- c(#
            coef.order[!(stringr::str_detect(coef.order, "(Intercept)") | stringr::str_detect(coef.order, "COV_REL1"))],#
            "COV_GENDER_Y1Prefer not to answer",#
            "COV_REL1_Y1Islam", "COV_REL1_Y1Hinduism", "COV_REL1_Y1Judaism", "COV_REL1_Y1Buddhism",#
            "COV_REL1_Y1Primal,Animist, or Folk religion", "COV_REL1_Y1Chinesefolk/traditional religion",#
            "COV_REL1_Y1Christianity", "COV_REL1_Y1Combined",#
            "(Intercept)"#
          )
fitted.reg.models
results.pooled <- fitted.reg.models %>%#
            unnest(c(fit.tidy)) %>%#
            ungroup() %>%#
            group_by(term, COUNTRY) %>%#
            nest() %>%#
            mutate(#
              pooled.est = map(data, \(x){#
                gfs_pool_estimates(x)#
              }),#
              estimates.by.imp = data#
            ) %>%#
            unnest(c(pooled.est)) %>%#
            select(-c(data)) %>%#
            unique() %>%#
            mutate(#
              term = factor(term)#
            ) %>%#
            arrange(COUNTRY, term) %>%#
            ungroup()
results.pooled
sd.pooled <- map(country.files,\(x){#
            svy.data.imp <- .get_data(x)#
#
            svy.data.imp %>%#
                mutate(#
                  est = purrr::map_dbl(svy.data, \(x) {#
                    survey::svyvar(~PRIMARY_OUTCOME, design = x, na.rm=TRUE)#
                  }),#
                  pred.var = purrr::map_dbl(svy.data, \(x) {#
                    survey::svyvar(~FOCAL_PREDICTOR, design = x, na.rm=TRUE)#
                  })#
                ) %>%#
                select(est, pred.var) %>%#
                ungroup()#
          }) |> bind_rows()
sd.pooled
# - require approx outcome standard deviation#
          sd.pooled <- map(country.files,\(x){#
            svy.data.imp <- .get_data(x)#
#
            svy.data.imp %>%#
                mutate(#
                  est = purrr::map_dbl(svy.data, \(x) {#
                    survey::svyvar(~PRIMARY_OUTCOME, design = x, na.rm=TRUE)#
                  }),#
                  pred.var = purrr::map_dbl(svy.data, \(x) {#
                    survey::svyvar(~FOCAL_PREDICTOR, design = x, na.rm=TRUE)#
                  })#
                ) %>%#
                select(est, pred.var) %>%#
                ungroup()#
          }) |> bind_rows()#
#
          sd.pooled <- sd.pooled %>%#
            select(COUNTRY, .imp, est, pred.var) %>%#
            group_by(COUNTRY) %>%#
            summarize(#
              outcome.sd = sqrt(mean(est, na.rm=TRUE)),#
              predictor.sd = sqrt(mean(pred.var, na.rm=TRUE))#
            ) %>%#
            select(COUNTRY, outcome.sd, predictor.sd)#
#
          # Now, IF the outcome and predictor were first standardized, this the above isn't necessary... and needs to be overwritten by a vector of 1s#
          if (standardize) {#
            sd.pooled$outcome.sd <- 1#
            sd.pooled$predictor.sd <- 1#
          }
sd.pooled
## Relabel output#
          varlist <- stringr::str_split_1(paste0(tmp.fit$formula)[[3]], " \\+ ")#
          termlist <- as.character(unique(results.pooled$term))[-1]#
#
          base_variable <- sapply(termlist, function(b) {#
            match <- sapply(varlist, function(a) {#
              startsWith(b, a)#
            })#
            varlist[which(match)]#
          })#
          base_variable <- base_variable %>%#
            as.data.frame() %>%#
            pull(.)#
          levels <- gsub(paste(unlist(base_variable), collapse = "|"), "", termlist)#
          termlabels <- data.frame(#
            original = c(rep("(Ref:)", length(termlist)), termlist, "(Intercept)"),#
            Variable = c(rep(base_variable, 2), "(Intercept)"),#
            Category = c(rep(levels, 2), "(Intercept)")#
          )#
#
          termlabels <- termlabels %>%#
            mutate(#
              Variable = stringr::str_remove(Variable, "COV_"),#
              Category = case_when(#
                stringr::str_detect(Variable, "PC_") ~ stringr::str_remove(stringr::str_sub(Variable, -2, -1), "_"),#
                Variable == "MOTHER_RELATN_Y1" ~ "Very good/somewhat good",#
                Variable == "FATHER_RELATN_Y1" ~ "Very good/somewhat good",#
                Variable == "RACE_PLURALITY" ~ "Non-plurality groups",#
                Variable == "MOTHER_NA" ~ "Mother NA flag",#
                Variable == "FATHER_NA" ~ "Father NA flag",#
                .default = Category#
              )#
            )#
          # Compute Evalues#
          tmp.output <- results.pooled %>%#
            left_join(sd.pooled, by = "COUNTRY") %>%#
            ungroup()
tmp.output$EE <- 0#
          tmp.output$ECI <- 0#
          i <- 1#
          for (i in 1:nrow(tmp.output)) {#
            tmp.output$EE[i] <- gfs_compute_evalue(#
              est = tmp.output$estimate.pooled[i],#
              se = tmp.output$se.pooled[i],#
              sd = tmp.output$outcome.sd[i],#
              ci.low = tmp.output$ci.low[i],#
              ci.up = tmp.output$ci.up[i],#
              type = outcome.type,#
              what = "EE"#
            )#
            tmp.output$ECI[i] <- gfs_compute_evalue(#
              est = tmp.output$estimate.pooled[i],#
              se = tmp.output$se.pooled[i],#
              sd = tmp.output$outcome.sd[i],#
              ci.low = tmp.output$ci.low[i],#
              ci.up = tmp.output$ci.up[i],#
              type = outcome.type,#
              what = "ECI"#
            )#
          }
output <- tmp.output %>%#
            left_join(termlabels,#
                      by = c("term" = "original"),#
                      relationship = "many-to-many"#
            ) %>%#
            arrange(Variable)
metainput <- output %>%#
            select(#
              COUNTRY,#
              Variable,#
              Category,#
              estimate.pooled,#
              se.pooled,#
              p.value,#
              ci.low,#
              ci.up,#
              df.approx,#
              outcome.sd#
            ) %>%#
            group_by(COUNTRY, Variable) %>%#
            dplyr::filter(!(Category == "(Ref:)")) %>%#
            dplyr::filter(Variable == "FOCAL_PREDICTOR")#
          colnames(metainput) <-#
            c("Country", "Variable", "Category", "Est", "SE", "pvalue", "ci.lb", "ci.ub", "df", "outcome.sd")#
          metainput <- metainput %>%#
            mutate(#
              OUTCOME = your.outcome,#
              FOCAL_PREDICTOR = your.pred,#
              .before = Variable#
            )
metainput
output <- output %>%#
            group_by(Variable) %>%#
            fill(Variable) %>%#
            ungroup() %>%#
            mutate(#
              Variable = case_when(Variable == "AGE_GRP" ~ "Year of birth", .default = Variable),#
              Category = case_when(#
                Variable == "REL1" &#
                  str_detect(Category, "Combined") ~ "Collapsed affiliations with prevalence<3%",#
                Category == "25-29" ~ "1993-1998; age 25-29",#
                Category == "30-39" ~ "1983-1993; age 30-39",#
                Category == "40-49" ~ "1973-1983; age 40-49",#
                Category == "50-59" ~ "1963-1973; age 50-59",#
                Category == "60-69" ~ "1953-1963; age 60-69",#
                Category == "70-79" ~ "1943-1953; age 70-79",#
                Category == "80 or older" ~ "1943 or earlier; age 80+",#
                Category == "(Ref:)" &#
                  Variable == "AGE_GRP" ~ "(Ref: 1998-2005; current age: 18-24)",#
                Category == "(Ref:)" &#
                  Variable == "GENDER" ~ "(Ref: Male)",#
                Category == "(Ref:)" &#
                  Variable == "PARENTS_12YRS" ~ "(Ref: Parents married)",#
                Category == "(Ref:)" &#
                  Variable == "SVCS_12YRS" ~ "(Ref: Never)",#
                # Category == "(Ref:)" & Variable == "SVCS_MOTHER" ~ "(Ref: Never)",#
                # Category == "(Ref:)" & Variable == "SVCS_FATHER" ~ "(Ref: Never)",#
                Category == "(Ref:)" &#
                  Variable == "MOTHER_RELATN" ~ "(Ref: Very bad/somewhat bad)",#
                Category == "(Ref:)" &#
                  Variable == "FATHER_RELATN" ~ "(Ref: Very bad/somewhat bad)",#
                # Category == "(Ref:)" & Variable == "MOTHER_LOVED" ~ "(Ref: No)",#
                # Category == "(Ref:)" & Variable == "FATHER_LOVED" ~ "(Ref: No)",#
                Category == "(Ref:)" &#
                  Variable == "OUTSIDER" ~ "(Ref: No)",#
                Category == "(Ref:)" &#
                  Variable == "ABUSED" ~ "(Ref: No)",#
                Category == "(Ref:)" &#
                  Variable == "HEALTH_GROWUP" ~ "(Ref: Good)",#
                Category == "(Ref:)" &#
                  Variable == "BORN_COUNTRY" ~ "(Ref: Born in this country)",#
                Category == "(Ref:)" &#
                  Variable == "INCOME_12YRS" ~ "(Ref: Got by)",#
                Category == "(Ref:)" &#
                  Variable == "RACE_PLURALITY" ~ "(Ref: Plurality group)",#
                Category == "(Ref:)" &#
                  Variable == "MOTHER_NA" ~ "(Ref: Non-missing Mother Flags)",#
                Category == "(Ref:)" &#
                  Variable == "FATHER_NA" ~ "(Ref: Non-missing Father Flags)",#
                Category == "(Ref:)" &#
                  COUNTRY %in% c(#
                    "Argentina",#
                    "Australia",#
                    "Brazil",#
                    "China",#
                    "Germany",#
                    "Hong Kong",#
                    "Japan",#
                    "Mexico",#
                    "Poland",#
                    "South Africa",#
                    "Spain",#
                    "Sweden",#
                    "Tanzania",#
                    "United Kingdom",#
                    "United States"#
                  ) &#
                  Variable == "REL1" ~ "(Ref: No religion/Atheist/Agnostic)",#
                Category == "(Ref:)" &#
                  COUNTRY %in% c("Egypt", "Indonesia", "Turkey") &#
                  Variable == "REL1" ~ "(Ref: Islam)",#
                Category == "(Ref:)" &#
                  COUNTRY %in% c("India") &#
                  Variable == "REL1" ~ "(Ref: Hinduism)",#
                Category == "(Ref:)" &#
                  COUNTRY %in% c("Israel") &#
                  Variable == "REL1" ~ "(Ref: Judaism)",#
                Category == "(Ref:)" &#
                  COUNTRY %in% c("Kenya", "Nigeria", "Philippines") &#
                  Variable == "REL1" ~ "(Ref: Christianity)",#
                .default = Category#
              )#
            ) %>%#
            dplyr::mutate(#
              OUTCOME = your.outcome,#
              FOCAL_PREDICTOR = your.pred,#
              .before = Variable#
            ) %>%#
            dplyr::mutate(#
              id.Est = .round(estimate.pooled),#
              id.SE = .round(se.pooled),#
              id.CI = paste0("(", .round(ci.low), ",", .round(ci.up), ")"),#
              ## make sure to apply RR approximation is outcome is actually linear#
              rr.Est = case_when(#
                outcome.type == "RR" ~ .round(exp(estimate.pooled)),#
                outcome.type == "linear" ~ .round(exp(0.91*estimate.pooled))#
              ),#
              logrr.SE = .round(se.pooled),#
              rr.CI = case_when(#
                outcome.type == "RR" ~ paste0("(", .round(exp(ci.low)), ",", .round(exp(ci.up)), ")"),#
                outcome.type == "linear" ~ paste0("(", .round(exp(0.91*ci.low)), ",", .round(exp(0.91*ci.up)), ")")#
              )#
            )#
#
          outfile <- here::here(#
            res.dir,#
            paste0(your.pred,  "_regressed_on_", your.outcome, "_saved_results",appnd.txt.to.filename,".RData")#
          )
fit.pca.summary
devtools::load_all()
