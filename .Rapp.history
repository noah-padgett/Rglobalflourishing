0.1**2
data.dir <- "/Users/noahp/Documents/GitHub/global-flourishing-study/data/wave2-data"#
dataset.name <- "gfs_all_countries_wave2.sav"#
#
# Specify where you want to output results#
# Can be left blank, and the results will output to the same directory as the data.#
out.dir <- getwd()#
#
# Here is YOUR wave 1 construct variable#
FOCAL_PREDICTOR <- c("LONELY_Y1")#
FOCAL_PREDICTOR_BETTER_NAME <- c("Self-rated physical health")#
FOCAL_PREDICTOR_REFERENCE_VALUE <- c("mean rating within country")#
#
# IF your predictor (focal exposure) is binary/categorical, use the code below to define how you#
#   want it to be categorized. Categorization must result in a binary variable 0/1 for#
#   consistency across studies.#
VALUES_DEFINING_UPPER_CATEGORY <- list(NA)#
VALUES_DEFINING_LOWER_CATEGORY <- list(NA)#
# Note 1: if your focal predictor is continuous (all items with 7+ response options), you can force the responses#
# 	to be categorized as 0/1 using the above with the below option changed to TRUE. This can be useful#
# 	when testing the sensitivity of results or for composite outcomes such as anxiety (sum of#
#   feel_anxious and control_worry)  or depression (sum of depressed and interest) that have a#
# 	history of being dichotomized.#
FORCE_BINARY <- c(FALSE)#
# Note 2: if your focal predictor is categorical/binary, you can use the responses as if they were continuous.#
# 	The provided (straightforward-ish) approach implemented is to reverse code all#
#   ordered-categorical variables (reverse code from what is reported in the codebook), and#
#   standardized as if continuous. This approach is not applicable for variables with nominal#
#   response categories such as employment. This is employed using the option below.#
FORCE_CONTINUOUS <- c(FALSE)#
# Note 3: if you need to define a subpopulation for domain analysis. (in-development)#
SUBPOPULATION <- list(NULL)#
#
names(FORCE_CONTINUOUS) <- names(FORCE_BINARY) <- names(VALUES_DEFINING_UPPER_CATEGORY)  <- names(VALUES_DEFINING_LOWER_CATEGORY) <- names(SUBPOPULATION) <- FOCAL_PREDICTOR#
# ================================================================================================ ##
# ================================================================================================ ##
# Data Prep#
#
if (is.null(out.dir)) {#
  out.dir <- data.dir#
}#
setwd(out.dir)#
# Note:#
# The following function loads the required packages for the remainder of the script to work.#
load_packages()#
# global options#
options(#
  survey.lonely.psu = "certainty"#
)#
# outcome vectors#
LIST.COMPOSITES <- get_variable_codes('LIST.COMPOSITES')#
RECODE.DEFAULTS <- list(#
  FOCAL_PREDICTOR = FOCAL_PREDICTOR,#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC = c(#
    get_variable_codes("GENDER.RACE", appnd=""),#
    get_variable_codes("DEMOGRAPHIC.VARS", appnd="_Y1"),#
    get_variable_codes("RETROSPECTIVE.VARS", appnd="_Y1")#
  ),#
  VARIABLES.VEC = c(get_variable_codes("VARS.Y1"), get_variable_codes("VARS.Y2")),#
  FORCE_BINARY = FORCE_BINARY,#
  FORCE_CONTINUOUS = FORCE_CONTINUOUS,#
  VALUES_DEFINING_UPPER_CATEGORY = VALUES_DEFINING_UPPER_CATEGORY,#
  VALUES_DEFINING_LOWER_CATEGORY = VALUES_DEFINING_LOWER_CATEGORY,#
  USE_DEFAULT = !(FORCE_BINARY | FORCE_CONTINUOUS)#
)
devtools::load_all()
data.dir <- "/Users/noahp/Documents/GitHub/global-flourishing-study/data/wave2-data"#
dataset.name <- "gfs_all_countries_wave2.sav"#
#
# Specify where you want to output results#
# Can be left blank, and the results will output to the same directory as the data.#
out.dir <- getwd()#
#
# Here is YOUR wave 1 construct variable#
FOCAL_PREDICTOR <- c("LONELY_Y1")#
FOCAL_PREDICTOR_BETTER_NAME <- c("Self-rated physical health")#
FOCAL_PREDICTOR_REFERENCE_VALUE <- c("mean rating within country")#
#
# IF your predictor (focal exposure) is binary/categorical, use the code below to define how you#
#   want it to be categorized. Categorization must result in a binary variable 0/1 for#
#   consistency across studies.#
VALUES_DEFINING_UPPER_CATEGORY <- list(NA)#
VALUES_DEFINING_LOWER_CATEGORY <- list(NA)#
# Note 1: if your focal predictor is continuous (all items with 7+ response options), you can force the responses#
# 	to be categorized as 0/1 using the above with the below option changed to TRUE. This can be useful#
# 	when testing the sensitivity of results or for composite outcomes such as anxiety (sum of#
#   feel_anxious and control_worry)  or depression (sum of depressed and interest) that have a#
# 	history of being dichotomized.#
FORCE_BINARY <- c(FALSE)#
# Note 2: if your focal predictor is categorical/binary, you can use the responses as if they were continuous.#
# 	The provided (straightforward-ish) approach implemented is to reverse code all#
#   ordered-categorical variables (reverse code from what is reported in the codebook), and#
#   standardized as if continuous. This approach is not applicable for variables with nominal#
#   response categories such as employment. This is employed using the option below.#
FORCE_CONTINUOUS <- c(FALSE)#
# Note 3: if you need to define a subpopulation for domain analysis. (in-development)#
SUBPOPULATION <- list(NULL)#
#
names(FORCE_CONTINUOUS) <- names(FORCE_BINARY) <- names(VALUES_DEFINING_UPPER_CATEGORY)  <- names(VALUES_DEFINING_LOWER_CATEGORY) <- names(SUBPOPULATION) <- FOCAL_PREDICTOR#
# ================================================================================================ ##
# ================================================================================================ ##
# Data Prep#
#
if (is.null(out.dir)) {#
  out.dir <- data.dir#
}#
setwd(out.dir)#
# Note:#
# The following function loads the required packages for the remainder of the script to work.#
load_packages()#
# global options#
options(#
  survey.lonely.psu = "certainty"#
)#
# outcome vectors#
LIST.COMPOSITES <- get_variable_codes('LIST.COMPOSITES')#
RECODE.DEFAULTS <- list(#
  FOCAL_PREDICTOR = FOCAL_PREDICTOR,#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC = c(#
    get_variable_codes("GENDER.RACE", appnd=""),#
    get_variable_codes("DEMOGRAPHIC.VARS", appnd="_Y1"),#
    get_variable_codes("RETROSPECTIVE.VARS", appnd="_Y1")#
  ),#
  VARIABLES.VEC = c(get_variable_codes("VARS.Y1"), get_variable_codes("VARS.Y2")),#
  FORCE_BINARY = FORCE_BINARY,#
  FORCE_CONTINUOUS = FORCE_CONTINUOUS,#
  VALUES_DEFINING_UPPER_CATEGORY = VALUES_DEFINING_UPPER_CATEGORY,#
  VALUES_DEFINING_LOWER_CATEGORY = VALUES_DEFINING_LOWER_CATEGORY,#
  USE_DEFAULT = !(FORCE_BINARY | FORCE_CONTINUOUS)#
)
VARIABLES.VEC <- RECODE.DEFAULTS[['VARIABLES.VEC']]#
OUTCOME.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "_Y2")]#
CONTEMPORANEOUS.EXPOSURES.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "COMPOSITE", negate = TRUE)]#
CONTEMPORANEOUS.EXPOSURES.VEC <- CONTEMPORANEOUS.EXPOSURES.VEC[str_detect(CONTEMPORANEOUS.EXPOSURES.VEC, "_Y1")]#
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER_Y1",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)#
# Run country-specific regression analyses for ALL wave 2 outcomes#
OUTCOME.VEC0 <- OUTCOME.VEC # c(1, 8, 24)+76,#
your.outcome <- OUTCOME.VEC0[2]
df.files <- list.files(data.dir)#
      df.files <- df.files[str_detect(df.files, "recoded_imputed_data_obj")]
df.files
x <- df.files[1]
data <- readr::read_rds(x)
x <- df.files[1]
data <- readr::read_rds(here::here(data.dir,x))
head(data)
data <- readr::read_rds(here::here(data.dir,x))#
      ## check which country is being analyzed#
      cur.country <- data$COUNTRY[1]
cur.country
cur.country <- as.character(data$COUNTRY[1])
cur.country
VARIABLES.VEC <- RECODE.DEFAULTS[['VARIABLES.VEC']]#
OUTCOME.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "_Y2")]#
CONTEMPORANEOUS.EXPOSURES.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "COMPOSITE", negate = TRUE)]#
CONTEMPORANEOUS.EXPOSURES.VEC <- CONTEMPORANEOUS.EXPOSURES.VEC[str_detect(CONTEMPORANEOUS.EXPOSURES.VEC, "_Y1")]#
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER_Y1",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)#
# Run country-specific regression analyses for ALL wave 2 outcomes#
OUTCOME.VEC0 <- OUTCOME.VEC # c(1, 8, 24)+76,#
your.outcome <- OUTCOME.VEC0[2]
wgt = as.name("ANNUAL_WEIGHT_R2")
psu = as.name("PSU")
strata = as.name("STRATA")
covariates = DEMO.CHILDHOOD.PRED
contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC
list.composites = LIST.COMPOSITES[[1]]
standardize = TRUE
pc.rule = "omit"
res.dir = "results-primary"
appnd.txt.to.filename = "_primary_wopc"
pc.cutoff = 7
pc.rule = "omit"
force.linear = FALSE
force.binary = FALSE
robust.huberM = FALSE
robust.tune = 1
subpopulation = NULL
compute.vif = FALSE
covariates <- covariates[str_detect(str_remove(covariates, "COV_"), your.pred, negate = TRUE)]#
      var.cont.exposures <- contemporaneous.exposures[str_detect(contemporaneous.exposures, your.pred, negate = TRUE)]#
#
      # additionally remove variables that are components of the focal predictor#
      #   e.g., if your.pred == "COMPOSITE_FLOURISHING_SECURE", then we need to remove all the#
      #   items that make up that score.#
      if (str_detect(your.pred, "COMPOSITE")) {#
        var.cont.exposures <- var.cont.exposures[!(var.cont.exposures %in% c(list.composites[[your.pred]]))]#
      }#
#
      if (is.null(res.dir)) {#
        res.dir <- here::here(getwd(),"results")#
      }#
      if (!dir.exists(res.dir)) {#
        dir.create(res.dir)#
      }
your.pred <- FOCAL_PREDICTOR[1]
your.pred
FOCAL_PREDICTOR <- c("PHYSICAL_HLTH_Y1")
your.pred <- FOCAL_PREDICTOR[1]
your.pred
LIST.COMPOSITES <- get_variable_codes('LIST.COMPOSITES')#
RECODE.DEFAULTS <- list(#
  FOCAL_PREDICTOR = FOCAL_PREDICTOR,#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC = c(#
    get_variable_codes("GENDER.RACE", appnd=""),#
    get_variable_codes("DEMOGRAPHIC.VARS", appnd="_Y1"),#
    get_variable_codes("RETROSPECTIVE.VARS", appnd="_Y1")#
  ),#
  VARIABLES.VEC = c(get_variable_codes("VARS.Y1"), get_variable_codes("VARS.Y2")),#
  FORCE_BINARY = FORCE_BINARY,#
  FORCE_CONTINUOUS = FORCE_CONTINUOUS,#
  VALUES_DEFINING_UPPER_CATEGORY = VALUES_DEFINING_UPPER_CATEGORY,#
  VALUES_DEFINING_LOWER_CATEGORY = VALUES_DEFINING_LOWER_CATEGORY,#
  USE_DEFAULT = !(FORCE_BINARY | FORCE_CONTINUOUS)#
)
VARIABLES.VEC <- RECODE.DEFAULTS[['VARIABLES.VEC']]#
OUTCOME.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "_Y2")]#
CONTEMPORANEOUS.EXPOSURES.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "COMPOSITE", negate = TRUE)]#
CONTEMPORANEOUS.EXPOSURES.VEC <- CONTEMPORANEOUS.EXPOSURES.VEC[str_detect(CONTEMPORANEOUS.EXPOSURES.VEC, "_Y1")]#
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER_Y1",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)#
# Run country-specific regression analyses for ALL wave 2 outcomes#
OUTCOME.VEC0 <- OUTCOME.VEC # c(1, 8, 24)+76,#
your.outcome <- OUTCOME.VEC0[2]
your.outcome
your.outcome <- "COMPOSITE_FLOURISHING_SECURE_Y2"
colnames(data)
covariates <- covariates[str_detect(str_remove(covariates, "COV_"), your.pred, negate = TRUE)]#
      var.cont.exposures <- contemporaneous.exposures[str_detect(contemporaneous.exposures, your.pred, negate = TRUE)]#
#
      # additionally remove variables that are components of the focal predictor#
      #   e.g., if your.pred == "COMPOSITE_FLOURISHING_SECURE", then we need to remove all the#
      #   items that make up that score.#
      if (str_detect(your.pred, "COMPOSITE")) {#
        var.cont.exposures <- var.cont.exposures[!(var.cont.exposures %in% c(list.composites[[your.pred]]))]#
      }#
#
      if (is.null(res.dir)) {#
        res.dir <- here::here(getwd(),"results")#
      }#
      if (!dir.exists(res.dir)) {#
        dir.create(res.dir)#
      }
covariates
var.cont.exposures
outcome.type <- case_when(#
        get_outcome_scale(your.outcome) %in% c("cont", "Continuous") ~ "linear",#
        get_outcome_scale(your.outcome) %in% c("bin", "likert") ~ "RR",#
        .default = "linear"#
      )#
      outcome.type <- case_when(#
        force.binary ~ "RR",#
        force.linear ~ "linear",#
        .default = outcome.type#
      )
outcome.type
outcome.type
df.files <- list.files(data.dir)#
      df.files <- df.files[str_detect(df.files, "recoded_imputed_data_obj")]
.run_internal_func <- function(x){#
      	data <- readr::read_rds(here::here(data.dir,x))#
      ## check which country is being analyzed#
      cur.country <- as.character(data$COUNTRY[1])#
      # outcomes/predictor combinations in which the countries must be subset...#
      {#
        if (str_detect(your.outcome,"APPROVE_GOVT") | str_detect(your.pred,"APPROVE_GOVT")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China","Egypt")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China","Egypt"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if (str_detect(your.outcome,"ABUSED") | str_detect(your.pred,"ABUSED")) {#
          data <- data %>%#
            dplyr::filter(str_detect(COUNTRY,"Israel", negate=TRUE)) %>%#
            dplyr::filter(str_detect(COUNTRY2,"Israel", negate=TRUE)) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if(str_detect(your.outcome,"BELIEVE_GOD") | str_detect(your.pred,"BELIEVE_GOD")) {#
          data <- data %>%#
            dplyr::filter(str_detect(COUNTRY,"Egypt", negate=TRUE)) %>%#
            dplyr::filter(str_detect(COUNTRY2,"Egypt", negate=TRUE)) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
         }#
         if (str_detect(your.outcome,"BELONGING") | str_detect(your.pred,"BELONGING")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if (str_detect(your.outcome,"SAY_IN_GOVT") | str_detect(your.pred,"SAY_IN_GOVT")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
      }#
#
      # convert to nested survey object#
      svy.data.imp <- data %>%#
        mutate(#
          COUNTRY = COUNTRY2,#
          .imp00 = .imp#
        ) %>%#
        group_by(COUNTRY, .imp) %>%#
        nest() %>%#
        mutate(#
          data = map(data, \(x) {#
            x$PRIMARY_OUTCOME <- as.numeric(x[, your.outcome, drop = TRUE])#
            x#
          }),#
          data = map(data, \(x) {#
            x$FOCAL_PREDICTOR <- as.numeric(x[, your.pred, drop = TRUE])#
            x#
          }),#
          data = map(data, \(x) {#
            x %>% mutate(#
              PRIMARY_OUTCOME = case_when(#
                standardize == FALSE ~ PRIMARY_OUTCOME,#
                outcome.type == "linear" & standardize == TRUE ~ svy_scale(PRIMARY_OUTCOME, {{wgt}}, {{psu}}, {{strata}}),#
                .default = PRIMARY_OUTCOME#
              ),#
              FOCAL_PREDICTOR = case_when(#
                standardize == FALSE ~ FOCAL_PREDICTOR,#
                outcome.type == "linear" & standardize == TRUE ~ svy_scale(FOCAL_PREDICTOR, {{wgt}}, {{psu}}, {{strata}}),#
                .default = FOCAL_PREDICTOR#
              )#
            )#
          }),#
          data = map(data, \(tmp.dat){#
            tmp.dat %>%#
              mutate(across(where(is.factor), \(x) droplevels(x)))#
          }),#
          svy.data = map(data, \(x) {#
                x %>%#
                as_survey_design(#
                  ids = {{psu}},#
                  strata = {{strata}},#
                  weights = {{wgt}},#
                  calibrate.formula = ~1#
                )#
            # svydesign(#
            #   data = x,#
            #   ids = ~{{psu}},#
            #   strata = ~{{strata}},#
            #   weights = ~{{wgt}},#
            #   calibrate.formula = ~1#
            # )#
          })#
        )#
#
      if(!is.null(subpopulation)){#
#
        sub.var <- sym(subpopulation[[1]])#
        sub.cat <- subpopulation[[2]]#
        subpop.expr <- expr(!!sub.var %in% !!sub.cat)#
#
        svy.data.imp <- svy.data.imp %>%#
          mutate(#
            data = map(data, \(x){#
              subset(x, eval(subpop.expr))#
            }),#
            svy.data = map(svy.data, \(x){#
              subset(x, eval(subpop.expr))#
            })#
          )#
#
        if(!is.null(subpopulation[[3]])){#
          svy.data.imp <- svy.data.imp %>%#
            filter((COUNTRY %in% c(subpopulation[[3]]) )) %>%#
            mutate(COUNTRY = fct_drop(COUNTRY))#
        }#
      }#
      # IF: pc.rule NOT omit#
      # Conduct PCA and add PCs to data.frames#
      fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
      if( str_to_lower(pc.rule) != "omit"){#
        svy.data.imp <- svy.data.imp %>%#
          mutate(#
            data = map(data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
              append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
            }),#
            svy.data = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
            }),#
            fit.pca = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              svyprcomp(#
                reformulate(var.cont.exposures[keep.cont.exposures]),#
                design = x,#
                scale. = TRUE,#
                scores = TRUE,#
                center = TRUE#
              )#
            }),#
            fit.eigen = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
            })#
          )#
        # get summary of PCA results to save to output file#
        fit.pca.summary <- svy.data.imp %>%#
          mutate(#
            pc.sdev = map(fit.pca, \(x) x$sdev),#
            pc.rotation = map(fit.pca, \(x) x$rotation)#
          ) %>%#
          select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
          unnest(c(pc.sdev, fit.eigen)) %>%#
          mutate(#
            PC = 1:n()#
          ) %>%#
          ungroup() %>%#
          group_by(COUNTRY, PC) %>%#
          summarise(#
            pc.var = mean(pc.sdev**2, na.rm = TRUE)#
          ) %>%#
          ungroup() %>%#
          group_by(COUNTRY) %>%#
          mutate(#
            prop.var = pc.var / sum(pc.var),#
            prop.sum = cumsum(prop.var),#
            Cumulative_Proportion_Explained = prop.sum#
          )#
#
        # check pc.cutoff to determine which PCs to use#
        if (pc.cutoff %% 1 == 0) {#
          keep.num.pc <- rep(pc.cutoff, length(unique(data$COUNTRY2)))#
          names(keep.num.pc) <- unique(data$COUNTRY2)#
        } else {#
          # number of PCs varies by counry based on the total or individual PC % of the variation in the confounders the set of PC account for.#
          if (str_to_lower(pc.rule) == "mintotal") {#
            keep.num.pc0 <- fit.pca.summary %>%#
              dplyr::filter(prop.sum >= pc.cutoff) %>%#
              dplyr::filter(PC == min(PC, na.rm = TRUE))#
            keep.num.pc <- keep.num.pc0$PC#
            names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
          }#
          if (str_to_lower(pc.rule) == "mincomp") {#
            keep.num.pc0 <- fit.pca.summary %>%#
              dplyr::filter(prop.var >= pc.cutoff)#
            if (nrow(keep.num.pc0) < 23) {#
              # cutoff fails because too stringent, switching to a default of 0.02#
              keep.num.pc0 <- fit.pca.summary %>%#
                dplyr::filter(prop.var >= 0.02)#
            }#
            keep.num.pc0 <- keep.num.pc0 %>%#
              dplyr::filter(PC == max(PC, na.rm = TRUE))#
            keep.num.pc <- keep.num.pc0$PC#
            names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
          }#
          if (str_to_lower(pc.rule) == "omit") {#
            # this is just to avoid errors and is not used#
            keep.num.pc <- rep(0, length(unique(data$COUNTRY2)))#
            names(keep.num.pc) <- unique(data$COUNTRY2)#
          }#
        }#
        tmp.df.pca <- data.frame(#
          COUNTRY = names(keep.num.pc),#
          NumPCAkeep = keep.num.pc#
        )#
        tmp.df.pca$Rule <- pc.rule#
        tmp.df.pca$Cutoff <- pc.cutoff#
        fit.pca.summary <- dplyr::left_join(fit.pca.summary, tmp.df.pca)#
      }#
#
      # # test:#
      # tmp.data <- svy.data.imp %>%#
      # filter(COUNTRY == "United States", .imp == 1)#
#
      # get_aicc_by_pc <- function(keep.num.pc, x){#
      # #x = tmp.data$svy.data[[1]]#
      # #keep.num.pc = 1#
      # # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
      # keep.var <- unlist(lapply(covariates, check.var, dat = x[['variables']]))#
      # tmp.model <- reformulate(#
      # response = "PRIMARY_OUTCOME",#
      # termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_",1:keep.num.pc))#
      # )#
      # tmp.fit <-  svyglm(tmp.model, design = x)#
      # k <- tmp.fit$rank +1 # number of dimensions of design matrix plus residual variance#
      # n <- sum(tmp.fit$weights)#
      # # AICC#
      # tmp.fit$aic + n*(n+k)/(n-k-2)#
#
      # }#
#
      # est.aicc <- map(1:(length(var.cont.exposures)-1), \(y){#
      # get_aicc_by_pc(y, tmp.data$svy.data[[1]])#
      # })#
      # plot.dat <- data.frame(PC = 1:(length(var.cont.exposures)-1), AICC = unlist(est.aicc))#
#
      # ggplot(plot.dat, aes(x=PC, y=AICC))+#
      # geom_point()+#
      # geom_line()#
#
      # ============================================================================================== ##
      # RUN REGRESSION ANALYSIS#
      # svy.data.imp is a nested df by country & .imp#
      svy.data.imp <- svy.data.imp %>%#
        dplyr::mutate(#
          svy.fit = purrr::map(svy.data, \(x) {#
            tmp.fit <- NULL#
            # first check if ANY variance on outomce#
            run.analysis <- ifelse(var(x[["variables"]][["PRIMARY_OUTCOME"]], na.rm=TRUE) > 0, TRUE, FALSE)#
            if (run.analysis) {#
              cur.country <- x[["variables"]][["COUNTRY2"]][1]#
              # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
              keep.var <- keep_variable(covariates, data = x[["variables"]])#
              if (str_to_lower(pc.rule) == "omit") {#
                tmp.model <- reformulate(#
                  response = "PRIMARY_OUTCOME",#
                  termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
                )#
              } else {#
                tmp.model <- reformulate(#
                  response = "PRIMARY_OUTCOME",#
                  termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[cur.country])))#
                )#
              }#
#
              if (outcome.type == "linear") {#
                tmp.fit <- gfs_svyglm(#
                  tmp.model,#
                  svy.design = x,#
                  family = stats::gaussian(),#
                  robust.huberM = robust.huberM,#
                  robust.tune = robust.tune#
                )#
              }#
              if (outcome.type == "RR") {#
                tmp.fit <- gfs_svyglm(#
                  tmp.model,#
                  svy.design = x,#
                  family = stats::quassipoisson(),#
                  robust.huberM = FALSE#
                )#
              }#
              tmp.fit#
            }#
          }),#
          fit.tidy = map(svy.fit, \(x) x$fit.tidy),#
          fit.vif = map(svy.fit, \(x){#
          	out = NULL#
          	if(compute.vif){#
          		mm <- model.matrix(x$fit)#
          		tmp = svydiags::svyvif(mobj = x$fit, X=mm[,-1], w=x$fit$weights)#
           		out = as.data.frame(tmp[['Intercept adjusted']]) %>% rowid_to_column(var="Predictor")#
          	}#
          	out#
          })#
        ) %>%#
        ungroup()#
#
      # re-estimate basic model with the max number of PCs used to get the variable names#
      tmp.dat <- svy.data.imp %>% dplyr::filter(str_detect(COUNTRY, "United States"))#
      keep.var <- keep_variable(covariates, data = tmp.dat$data[[1]])#
      if (str_to_lower(pc.rule) == "omit") {#
        tmp.model <- reformulate(#
          response = "PRIMARY_OUTCOME",#
          termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
        )#
      } else {#
        tmp.country <- names(keep.num.pc)[which(keep.num.pc == max(keep.num.pc))[1]]#
        tmp.model <- reformulate(#
          response = "PRIMARY_OUTCOME",#
          termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[tmp.country])))#
        )#
      }#
      tmp.fit <- tmp.dat$data[[1]] %>% glm(tmp.model, data = .)#
      # which model doesn't matter for this step, we only need the variable names#
#
      coef.order <- names(tmp.fit$coefficients)#
      coef.order <- c(#
        coef.order[!(stringr::str_detect(coef.order, "(Intercept)") | stringr::str_detect(coef.order, "COV_REL1"))],#
        "COV_GENDER_Y1Prefer not to answer",#
        "COV_REL1_Y1Islam", "COV_REL1_Y1Hinduism", "COV_REL1_Y1Judaism", "COV_REL1_Y1Buddhism",#
        "COV_REL1_Y1Primal,Animist, or Folk religion", "COV_REL1_Y1Chinesefolk/traditional religion",#
        "COV_REL1_Y1Christianity", "COV_REL1_Y1Combined",#
        "(Intercept)"#
      )#
#
      results.pooled <- svy.data.imp %>%#
        select(COUNTRY, .imp, fit.tidy) %>%#
        unnest(c(fit.tidy)) %>%#
        ungroup() %>%#
        group_by(term, COUNTRY) %>%#
        nest() %>%#
        mutate(#
          pooled.est = map(data, \(x){#
            gfs_pool_estimates(x)#
          }),#
          estimates.by.imp = data#
        ) %>%#
        unnest(c(pooled.est)) %>%#
        select(-c(data)) %>%#
        unique() %>%#
        mutate(#
          term = factor(term)#
        ) %>%#
        arrange(COUNTRY, term) %>%#
        ungroup()#
#
      ## Relabel output#
      varlist <- stringr::str_split_1(paste0(tmp.fit$formula)[[3]], " \\+ ")#
      termlist <- as.character(unique(results.pooled$term))[-1]#
#
      base_variable <- sapply(termlist, function(b) {#
        match <- sapply(varlist, function(a) {#
          startsWith(b, a)#
        })#
        varlist[which(match)]#
      })#
      base_variable <- base_variable %>%#
        as.data.frame() %>%#
        pull(.)#
      levels <- gsub(paste(unlist(base_variable), collapse = "|"), "", termlist)#
      termlabels <- data.frame(#
        original = c(rep("(Ref:)", length(termlist)), termlist, "(Intercept)"),#
        Variable = c(rep(base_variable, 2), "(Intercept)"),#
        Category = c(rep(levels, 2), "(Intercept)")#
      )#
#
      termlabels <- termlabels %>%#
        mutate(#
          Variable = stringr::str_remove(Variable, "COV_"),#
          Category = case_when(#
            stringr::str_detect(Variable, "PC_") ~ stringr::str_remove(stringr::str_sub(Variable, -2, -1), "_"),#
            Variable == "MOTHER_RELATN_Y1" ~ "Very good/somewhat good",#
            Variable == "FATHER_RELATN_Y1" ~ "Very good/somewhat good",#
            Variable == "RACE_PLURALITY" ~ "Non-plurality groups",#
            Variable == "MOTHER_NA" ~ "Mother NA flag",#
            Variable == "FATHER_NA" ~ "Father NA flag",#
            .default = Category#
          )#
        )#
#
      # compute outcome & predictor SD Only used for continuous/forced continuous models#
      # - For continuous outcomes, need to use evalue.OLS(.)#
      # - require approx outcome standard deviation#
      sd.pooled <- svy.data.imp %>%#
        mutate(#
          est = purrr::map_dbl(svy.data, \(x) {#
          	survey::svyvar(~PRIMARY_OUTCOME, design = x, na.rm=TRUE)#
          }),#
          pred.var = purrr::map_dbl(svy.data, \(x) {#
          	survey::svyvar(~FOCAL_PREDICTOR, design = x, na.rm=TRUE)#
          })#
        ) %>%#
        ungroup() %>%#
        select(COUNTRY, .imp, est, pred.var) %>%#
        group_by(COUNTRY) %>%#
        summarize(#
          outcome.sd = sqrt(mean(est, na.rm=TRUE)),#
          predictor.sd = sqrt(mean(pred.var, na.rm=TRUE))#
        ) %>%#
        select(COUNTRY, outcome.sd, predictor.sd)#
#
      # Now, IF the outcome and predictor were first standardized, this the above isn't necessary... and needs to be overwritten by a vector of 1s#
      if (standardize) {#
        sd.pooled$outcome.sd <- 1#
        sd.pooled$predictor.sd <- 1#
      }#
      # Compute Evalues#
      tmp.output <- results.pooled %>%#
        left_join(sd.pooled, by = "COUNTRY") %>%#
        ungroup()#
#
      # Note: I could not get the following mutate(.) to work, not sure what is wrong, but the for loop works...#
      # mutate(#
      #   EE  = gfs_compute_evalue(#
      #    est = estimate.pooled,#
      #    se = se.pooled,#
      #    sd = sd.pooled,#
      #    ci.low = ci.low,#
      #    ci.up = ci.up,#
      #    type = outcome.type,#
      #    what = "EE"#
      #  ),#
      #  ECI =  gfs_compute_evalue(#
      #    est = estimate.pooled,#
      #    se = se.pooled,#
      #    sd = sd.pooled,#
      #    ci.low = ci.low,#
      #    ci.up = ci.up,#
      #    type = outcome.type,#
      #    what = "ECI"#
      #   )#
      # )#
      # working version:#
      tmp.output$EE <- 0#
      tmp.output$ECI <- 0#
      i <- 1#
      for (i in 1:nrow(tmp.output)) {#
        tmp.output$EE[i] <- gfs_compute_evalue(#
          est = tmp.output$estimate.pooled[i],#
          se = tmp.output$se.pooled[i],#
          sd = tmp.output$outcome.sd[i],#
          ci.low = tmp.output$ci.low[i],#
          ci.up = tmp.output$ci.up[i],#
          type = outcome.type,#
          what = "EE"#
        )#
        tmp.output$ECI[i] <- gfs_compute_evalue(#
          est = tmp.output$estimate.pooled[i],#
          se = tmp.output$se.pooled[i],#
          sd = tmp.output$outcome.sd[i],#
          ci.low = tmp.output$ci.low[i],#
          ci.up = tmp.output$ci.up[i],#
          type = outcome.type,#
          what = "ECI"#
        )#
      }#
      output <- tmp.output %>%#
        left_join(termlabels,#
                  by = c("term" = "original"),#
                  relationship = "many-to-many"#
        ) %>%#
        arrange(Variable)#
      # Meta analysis input - is a simplified data.frame with only:#
      # 		country, variable, category, estimate, standard error, and global p-value#
      # 		This reduced file is helpful for the meta-analysis app OR internal meta-analysis code#
      metainput <- output %>%#
        select(#
          COUNTRY,#
          Variable,#
          Category,#
          estimate.pooled,#
          se.pooled,#
          p.value,#
          ci.low,#
          ci.up,#
          df.approx,#
          outcome.sd#
        ) %>%#
        group_by(COUNTRY, Variable) %>%#
        dplyr::filter(!(Category == "(Ref:)")) %>%#
        dplyr::filter(Variable == "FOCAL_PREDICTOR")#
      colnames(metainput) <-#
        c("Country", "Variable", "Category", "Est", "SE", "pvalue", "ci.lb", "ci.ub", "df", "outcome.sd")#
      metainput <- metainput %>%#
        mutate(#
          OUTCOME = your.outcome,#
          FOCAL_PREDICTOR = your.pred,#
          .before = Variable#
        )#
#
      # ============================================================================ ##
      # ============================================================================ ##
      # Online Supplement Analyses - variable specific#
#
      output <- output %>%#
        group_by(Variable) %>%#
        fill(Variable) %>%#
        ungroup() %>%#
        mutate(#
          Variable = case_when(Variable == "AGE_GRP" ~ "Year of birth", .default = Variable),#
          Category = case_when(#
            Variable == "REL1" &#
              str_detect(Category, "Combined") ~ "Collapsed affiliations with prevalence<3%",#
            Category == "25-29" ~ "1993-1998; age 25-29",#
            Category == "30-39" ~ "1983-1993; age 30-39",#
            Category == "40-49" ~ "1973-1983; age 40-49",#
            Category == "50-59" ~ "1963-1973; age 50-59",#
            Category == "60-69" ~ "1953-1963; age 60-69",#
            Category == "70-79" ~ "1943-1953; age 70-79",#
            Category == "80 or older" ~ "1943 or earlier; age 80+",#
            Category == "(Ref:)" &#
              Variable == "AGE_GRP" ~ "(Ref: 1998-2005; current age: 18-24)",#
            Category == "(Ref:)" &#
              Variable == "GENDER" ~ "(Ref: Male)",#
            Category == "(Ref:)" &#
              Variable == "PARENTS_12YRS" ~ "(Ref: Parents married)",#
            Category == "(Ref:)" &#
              Variable == "SVCS_12YRS" ~ "(Ref: Never)",#
            # Category == "(Ref:)" & Variable == "SVCS_MOTHER" ~ "(Ref: Never)",#
            # Category == "(Ref:)" & Variable == "SVCS_FATHER" ~ "(Ref: Never)",#
            Category == "(Ref:)" &#
              Variable == "MOTHER_RELATN" ~ "(Ref: Very bad/somewhat bad)",#
            Category == "(Ref:)" &#
              Variable == "FATHER_RELATN" ~ "(Ref: Very bad/somewhat bad)",#
            # Category == "(Ref:)" & Variable == "MOTHER_LOVED" ~ "(Ref: No)",#
            # Category == "(Ref:)" & Variable == "FATHER_LOVED" ~ "(Ref: No)",#
            Category == "(Ref:)" &#
              Variable == "OUTSIDER" ~ "(Ref: No)",#
            Category == "(Ref:)" &#
              Variable == "ABUSED" ~ "(Ref: No)",#
            Category == "(Ref:)" &#
              Variable == "HEALTH_GROWUP" ~ "(Ref: Good)",#
            Category == "(Ref:)" &#
              Variable == "BORN_COUNTRY" ~ "(Ref: Born in this country)",#
            Category == "(Ref:)" &#
              Variable == "INCOME_12YRS" ~ "(Ref: Got by)",#
            Category == "(Ref:)" &#
              Variable == "RACE_PLURALITY" ~ "(Ref: Plurality group)",#
            Category == "(Ref:)" &#
              Variable == "MOTHER_NA" ~ "(Ref: Non-missing Mother Flags)",#
            Category == "(Ref:)" &#
              Variable == "FATHER_NA" ~ "(Ref: Non-missing Father Flags)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c(#
                "Argentina",#
                "Australia",#
                "Brazil",#
                "China",#
                "Germany",#
                "Hong Kong",#
                "Japan",#
                "Mexico",#
                "Poland",#
                "South Africa",#
                "Spain",#
                "Sweden",#
                "Tanzania",#
                "United Kingdom",#
                "United States"#
              ) &#
              Variable == "REL1" ~ "(Ref: No religion/Atheist/Agnostic)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("Egypt", "Indonesia", "Turkey") &#
              Variable == "REL1" ~ "(Ref: Islam)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("India") &#
              Variable == "REL1" ~ "(Ref: Hinduism)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("Israel") &#
              Variable == "REL1" ~ "(Ref: Judaism)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("Kenya", "Nigeria", "Philippines") &#
              Variable == "REL1" ~ "(Ref: Christianity)",#
            .default = Category#
          )#
        ) %>%#
        dplyr::mutate(#
          OUTCOME = your.outcome,#
          FOCAL_PREDICTOR = your.pred,#
          .before = Variable#
        ) %>%#
        dplyr::mutate(#
          id.Est = .round(estimate.pooled),#
          id.SE = .round(se.pooled),#
          id.CI = paste0("(", .round(ci.low), ",", .round(ci.up), ")"),#
          ## make sure to apply RR approximation is outcome is actually linear#
          rr.Est = case_when(#
          	outcome.type == "RR" ~ .round(exp(estimate.pooled)),#
          	outcome.type == "linear" ~ .round(exp(0.91*estimate.pooled))#
          ),#
          logrr.SE = .round(se.pooled),#
          rr.CI = case_when(#
          	outcome.type == "RR" ~ paste0("(", .round(exp(ci.low)), ",", .round(exp(ci.up)), ")"),#
          	outcome.type == "linear" ~ paste0("(", .round(exp(0.91*ci.low)), ",", .round(exp(0.91*ci.up)), ")")#
          )#
        )#
#
      outfile <- here::here(#
          res.dir,#
          paste0(your.pred,  "_regressed_on_", your.outcome, "_saved_results",appnd.txt.to.filename,".RData")#
        )#
#
      results.vif  <- NULL#
      if(compute.vif){#
      	results.vif <- svy.data.imp %>%#
        select(COUNTRY, .imp, fit.vif) %>%#
        unnest(c(fit.vif)) %>%#
        ungroup()#
      }#
      ## load the previously "saved" result and append results for the next country#
      if(cur.country == "Argentina"){#
      	load(outfile, env.res <- new.env())#
      	output <- rbind(output, env.res$output)#
      	metainput <- rbind(metainput, env.res$metainput)#
      	fit.pca.summary <- rbind(fit.pca.summary, env.res$fit.pca.summary)#
      	if( (!is.null(results.vif)) & (!is.null(env.res$results.vif))){#
      	   results.vif <- rbind(results.vif, env.res$results.vif)#
      	}#
      }#
      ## save/overwrite existing saved results file so everything is in one object#
      save(#
        output,#
        metainput,#
        fit.pca.summary,#
        results.vif,#
        file = outfile#
      )#
      	return(metainput)#
#
      }
df.files
metares <- map(df.files, \(x){#
      	 .run_internal_func(x)#
      }) |>#
      bind_rows()
.run_internal_func <- function(x){#
      	data <- readr::read_rds(here::here(data.dir,x))#
      ## check which country is being analyzed#
      cur.country <- as.character(data$COUNTRY[1])#
      # outcomes/predictor combinations in which the countries must be subset...#
      {#
        if (str_detect(your.outcome,"APPROVE_GOVT") | str_detect(your.pred,"APPROVE_GOVT")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China","Egypt")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China","Egypt"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if (str_detect(your.outcome,"ABUSED") | str_detect(your.pred,"ABUSED")) {#
          data <- data %>%#
            dplyr::filter(str_detect(COUNTRY,"Israel", negate=TRUE)) %>%#
            dplyr::filter(str_detect(COUNTRY2,"Israel", negate=TRUE)) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if(str_detect(your.outcome,"BELIEVE_GOD") | str_detect(your.pred,"BELIEVE_GOD")) {#
          data <- data %>%#
            dplyr::filter(str_detect(COUNTRY,"Egypt", negate=TRUE)) %>%#
            dplyr::filter(str_detect(COUNTRY2,"Egypt", negate=TRUE)) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
         }#
         if (str_detect(your.outcome,"BELONGING") | str_detect(your.pred,"BELONGING")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if (str_detect(your.outcome,"SAY_IN_GOVT") | str_detect(your.pred,"SAY_IN_GOVT")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
      }#
#
      # convert to nested survey object#
      svy.data.imp <- data %>%#
        mutate(#
          COUNTRY = COUNTRY2,#
          .imp00 = .imp#
        ) %>%#
        group_by(COUNTRY, .imp) %>%#
        nest() %>%#
        mutate(#
          data = map(data, \(x) {#
            x$PRIMARY_OUTCOME <- as.numeric(x[, your.outcome, drop = TRUE])#
            x#
          }),#
          data = map(data, \(x) {#
            x$FOCAL_PREDICTOR <- as.numeric(x[, your.pred, drop = TRUE])#
            x#
          }),#
          data = map(data, \(x) {#
            x %>% mutate(#
              PRIMARY_OUTCOME = case_when(#
                standardize == FALSE ~ PRIMARY_OUTCOME,#
                outcome.type == "linear" & standardize == TRUE ~ svy_scale(PRIMARY_OUTCOME, {{wgt}}, {{psu}}, {{strata}}),#
                .default = PRIMARY_OUTCOME#
              ),#
              FOCAL_PREDICTOR = case_when(#
                standardize == FALSE ~ FOCAL_PREDICTOR,#
                outcome.type == "linear" & standardize == TRUE ~ svy_scale(FOCAL_PREDICTOR, {{wgt}}, {{psu}}, {{strata}}),#
                .default = FOCAL_PREDICTOR#
              )#
            )#
          }),#
          data = map(data, \(tmp.dat){#
            tmp.dat %>%#
              mutate(across(where(is.factor), \(x) droplevels(x)))#
          }),#
          svy.data = map(data, \(x) {#
                x %>%#
                as_survey_design(#
                  ids = {{psu}},#
                  strata = {{strata}},#
                  weights = {{wgt}},#
                  calibrate.formula = ~1#
                )#
            # svydesign(#
            #   data = x,#
            #   ids = ~{{psu}},#
            #   strata = ~{{strata}},#
            #   weights = ~{{wgt}},#
            #   calibrate.formula = ~1#
            # )#
          })#
        )#
#
      if(!is.null(subpopulation)){#
#
        sub.var <- sym(subpopulation[[1]])#
        sub.cat <- subpopulation[[2]]#
        subpop.expr <- expr(!!sub.var %in% !!sub.cat)#
#
        svy.data.imp <- svy.data.imp %>%#
          mutate(#
            data = map(data, \(x){#
              subset(x, eval(subpop.expr))#
            }),#
            svy.data = map(svy.data, \(x){#
              subset(x, eval(subpop.expr))#
            })#
          )#
#
        if(!is.null(subpopulation[[3]])){#
          svy.data.imp <- svy.data.imp %>%#
            filter((COUNTRY %in% c(subpopulation[[3]]) )) %>%#
            mutate(COUNTRY = fct_drop(COUNTRY))#
        }#
      }#
      # IF: pc.rule NOT omit#
      # Conduct PCA and add PCs to data.frames#
      fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
      if( str_to_lower(pc.rule) != "omit"){#
        svy.data.imp <- svy.data.imp %>%#
          mutate(#
            data = map(data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
              append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
            }),#
            svy.data = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
            }),#
            fit.pca = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              svyprcomp(#
                reformulate(var.cont.exposures[keep.cont.exposures]),#
                design = x,#
                scale. = TRUE,#
                scores = TRUE,#
                center = TRUE#
              )#
            }),#
            fit.eigen = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
            })#
          )#
        # get summary of PCA results to save to output file#
        fit.pca.summary <- svy.data.imp %>%#
          mutate(#
            pc.sdev = map(fit.pca, \(x) x$sdev),#
            pc.rotation = map(fit.pca, \(x) x$rotation)#
          ) %>%#
          select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
          unnest(c(pc.sdev, fit.eigen)) %>%#
          mutate(#
            PC = 1:n()#
          ) %>%#
          ungroup() %>%#
          group_by(COUNTRY, PC) %>%#
          summarise(#
            pc.var = mean(pc.sdev**2, na.rm = TRUE)#
          ) %>%#
          ungroup() %>%#
          group_by(COUNTRY) %>%#
          mutate(#
            prop.var = pc.var / sum(pc.var),#
            prop.sum = cumsum(prop.var),#
            Cumulative_Proportion_Explained = prop.sum#
          )#
#
        # check pc.cutoff to determine which PCs to use#
        if (pc.cutoff %% 1 == 0) {#
          keep.num.pc <- rep(pc.cutoff, length(unique(data$COUNTRY2)))#
          names(keep.num.pc) <- unique(data$COUNTRY2)#
        } else {#
          # number of PCs varies by counry based on the total or individual PC % of the variation in the confounders the set of PC account for.#
          if (str_to_lower(pc.rule) == "mintotal") {#
            keep.num.pc0 <- fit.pca.summary %>%#
              dplyr::filter(prop.sum >= pc.cutoff) %>%#
              dplyr::filter(PC == min(PC, na.rm = TRUE))#
            keep.num.pc <- keep.num.pc0$PC#
            names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
          }#
          if (str_to_lower(pc.rule) == "mincomp") {#
            keep.num.pc0 <- fit.pca.summary %>%#
              dplyr::filter(prop.var >= pc.cutoff)#
            if (nrow(keep.num.pc0) < 23) {#
              # cutoff fails because too stringent, switching to a default of 0.02#
              keep.num.pc0 <- fit.pca.summary %>%#
                dplyr::filter(prop.var >= 0.02)#
            }#
            keep.num.pc0 <- keep.num.pc0 %>%#
              dplyr::filter(PC == max(PC, na.rm = TRUE))#
            keep.num.pc <- keep.num.pc0$PC#
            names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
          }#
          if (str_to_lower(pc.rule) == "omit") {#
            # this is just to avoid errors and is not used#
            keep.num.pc <- rep(0, length(unique(data$COUNTRY2)))#
            names(keep.num.pc) <- unique(data$COUNTRY2)#
          }#
        }#
        tmp.df.pca <- data.frame(#
          COUNTRY = names(keep.num.pc),#
          NumPCAkeep = keep.num.pc#
        )#
        tmp.df.pca$Rule <- pc.rule#
        tmp.df.pca$Cutoff <- pc.cutoff#
        fit.pca.summary <- dplyr::left_join(fit.pca.summary, tmp.df.pca)#
      }#
#
      # # test:#
      # tmp.data <- svy.data.imp %>%#
      # filter(COUNTRY == "United States", .imp == 1)#
#
      # get_aicc_by_pc <- function(keep.num.pc, x){#
      # #x = tmp.data$svy.data[[1]]#
      # #keep.num.pc = 1#
      # # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
      # keep.var <- unlist(lapply(covariates, check.var, dat = x[['variables']]))#
      # tmp.model <- reformulate(#
      # response = "PRIMARY_OUTCOME",#
      # termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_",1:keep.num.pc))#
      # )#
      # tmp.fit <-  svyglm(tmp.model, design = x)#
      # k <- tmp.fit$rank +1 # number of dimensions of design matrix plus residual variance#
      # n <- sum(tmp.fit$weights)#
      # # AICC#
      # tmp.fit$aic + n*(n+k)/(n-k-2)#
#
      # }#
#
      # est.aicc <- map(1:(length(var.cont.exposures)-1), \(y){#
      # get_aicc_by_pc(y, tmp.data$svy.data[[1]])#
      # })#
      # plot.dat <- data.frame(PC = 1:(length(var.cont.exposures)-1), AICC = unlist(est.aicc))#
#
      # ggplot(plot.dat, aes(x=PC, y=AICC))+#
      # geom_point()+#
      # geom_line()#
#
      # ============================================================================================== ##
      # RUN REGRESSION ANALYSIS#
      # svy.data.imp is a nested df by country & .imp#
      svy.data.imp <- svy.data.imp %>%#
        dplyr::mutate(#
          svy.fit = purrr::map(svy.data, \(x) {#
            tmp.fit <- NULL#
            # first check if ANY variance on outomce#
            run.analysis <- ifelse(var(x[["variables"]][["PRIMARY_OUTCOME"]], na.rm=TRUE) > 0, TRUE, FALSE)#
            if (run.analysis) {#
              cur.country <- x[["variables"]][["COUNTRY2"]][1]#
              # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
              keep.var <- keep_variable(covariates, data = x[["variables"]])#
              if (str_to_lower(pc.rule) == "omit") {#
                tmp.model <- reformulate(#
                  response = "PRIMARY_OUTCOME",#
                  termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
                )#
              } else {#
                tmp.model <- reformulate(#
                  response = "PRIMARY_OUTCOME",#
                  termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[cur.country])))#
                )#
              }#
#
              if (outcome.type == "linear") {#
                tmp.fit <- gfs_svyglm(#
                  tmp.model,#
                  svy.design = x,#
                  family = stats::gaussian(),#
                  robust.huberM = robust.huberM,#
                  robust.tune = robust.tune#
                )#
              }#
              if (outcome.type == "RR") {#
                tmp.fit <- gfs_svyglm(#
                  tmp.model,#
                  svy.design = x,#
                  family = stats::quassipoisson(),#
                  robust.huberM = FALSE#
                )#
              }#
              tmp.fit#
            }#
          }),#
          fit.tidy = map(svy.fit, \(x) x$fit.tidy),#
          fit.vif = map(svy.fit, \(x){#
          	out = NULL#
          	if(compute.vif){#
          		mm <- model.matrix(x$fit)#
          		tmp = svydiags::svyvif(mobj = x$fit, X=mm[,-1], w=x$fit$weights)#
           		out = as.data.frame(tmp[['Intercept adjusted']]) %>% rowid_to_column(var="Predictor")#
          	}#
          	out#
          })#
        ) %>%#
        ungroup()#
#
      # re-estimate basic model with the max number of PCs used to get the variable names#
      tmp.dat <- svy.data.imp#
      keep.var <- keep_variable(covariates, data = tmp.dat$data[[1]])#
      if (str_to_lower(pc.rule) == "omit") {#
        tmp.model <- reformulate(#
          response = "PRIMARY_OUTCOME",#
          termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
        )#
      } else {#
        tmp.country <- names(keep.num.pc)[which(keep.num.pc == max(keep.num.pc))[1]]#
        tmp.model <- reformulate(#
          response = "PRIMARY_OUTCOME",#
          termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[tmp.country])))#
        )#
      }#
      tmp.fit <- tmp.dat$data[[1]] %>% glm(tmp.model, data = .)#
      # which model doesn't matter for this step, we only need the variable names#
#
      coef.order <- names(tmp.fit$coefficients)#
      coef.order <- c(#
        coef.order[!(stringr::str_detect(coef.order, "(Intercept)") | stringr::str_detect(coef.order, "COV_REL1"))],#
        "COV_GENDER_Y1Prefer not to answer",#
        "COV_REL1_Y1Islam", "COV_REL1_Y1Hinduism", "COV_REL1_Y1Judaism", "COV_REL1_Y1Buddhism",#
        "COV_REL1_Y1Primal,Animist, or Folk religion", "COV_REL1_Y1Chinesefolk/traditional religion",#
        "COV_REL1_Y1Christianity", "COV_REL1_Y1Combined",#
        "(Intercept)"#
      )#
#
      results.pooled <- svy.data.imp %>%#
        select(COUNTRY, .imp, fit.tidy) %>%#
        unnest(c(fit.tidy)) %>%#
        ungroup() %>%#
        group_by(term, COUNTRY) %>%#
        nest() %>%#
        mutate(#
          pooled.est = map(data, \(x){#
            gfs_pool_estimates(x)#
          }),#
          estimates.by.imp = data#
        ) %>%#
        unnest(c(pooled.est)) %>%#
        select(-c(data)) %>%#
        unique() %>%#
        mutate(#
          term = factor(term)#
        ) %>%#
        arrange(COUNTRY, term) %>%#
        ungroup()#
#
      ## Relabel output#
      varlist <- stringr::str_split_1(paste0(tmp.fit$formula)[[3]], " \\+ ")#
      termlist <- as.character(unique(results.pooled$term))[-1]#
#
      base_variable <- sapply(termlist, function(b) {#
        match <- sapply(varlist, function(a) {#
          startsWith(b, a)#
        })#
        varlist[which(match)]#
      })#
      base_variable <- base_variable %>%#
        as.data.frame() %>%#
        pull(.)#
      levels <- gsub(paste(unlist(base_variable), collapse = "|"), "", termlist)#
      termlabels <- data.frame(#
        original = c(rep("(Ref:)", length(termlist)), termlist, "(Intercept)"),#
        Variable = c(rep(base_variable, 2), "(Intercept)"),#
        Category = c(rep(levels, 2), "(Intercept)")#
      )#
#
      termlabels <- termlabels %>%#
        mutate(#
          Variable = stringr::str_remove(Variable, "COV_"),#
          Category = case_when(#
            stringr::str_detect(Variable, "PC_") ~ stringr::str_remove(stringr::str_sub(Variable, -2, -1), "_"),#
            Variable == "MOTHER_RELATN_Y1" ~ "Very good/somewhat good",#
            Variable == "FATHER_RELATN_Y1" ~ "Very good/somewhat good",#
            Variable == "RACE_PLURALITY" ~ "Non-plurality groups",#
            Variable == "MOTHER_NA" ~ "Mother NA flag",#
            Variable == "FATHER_NA" ~ "Father NA flag",#
            .default = Category#
          )#
        )#
#
      # compute outcome & predictor SD Only used for continuous/forced continuous models#
      # - For continuous outcomes, need to use evalue.OLS(.)#
      # - require approx outcome standard deviation#
      sd.pooled <- svy.data.imp %>%#
        mutate(#
          est = purrr::map_dbl(svy.data, \(x) {#
          	survey::svyvar(~PRIMARY_OUTCOME, design = x, na.rm=TRUE)#
          }),#
          pred.var = purrr::map_dbl(svy.data, \(x) {#
          	survey::svyvar(~FOCAL_PREDICTOR, design = x, na.rm=TRUE)#
          })#
        ) %>%#
        ungroup() %>%#
        select(COUNTRY, .imp, est, pred.var) %>%#
        group_by(COUNTRY) %>%#
        summarize(#
          outcome.sd = sqrt(mean(est, na.rm=TRUE)),#
          predictor.sd = sqrt(mean(pred.var, na.rm=TRUE))#
        ) %>%#
        select(COUNTRY, outcome.sd, predictor.sd)#
#
      # Now, IF the outcome and predictor were first standardized, this the above isn't necessary... and needs to be overwritten by a vector of 1s#
      if (standardize) {#
        sd.pooled$outcome.sd <- 1#
        sd.pooled$predictor.sd <- 1#
      }#
      # Compute Evalues#
      tmp.output <- results.pooled %>%#
        left_join(sd.pooled, by = "COUNTRY") %>%#
        ungroup()#
#
      # Note: I could not get the following mutate(.) to work, not sure what is wrong, but the for loop works...#
      # mutate(#
      #   EE  = gfs_compute_evalue(#
      #    est = estimate.pooled,#
      #    se = se.pooled,#
      #    sd = sd.pooled,#
      #    ci.low = ci.low,#
      #    ci.up = ci.up,#
      #    type = outcome.type,#
      #    what = "EE"#
      #  ),#
      #  ECI =  gfs_compute_evalue(#
      #    est = estimate.pooled,#
      #    se = se.pooled,#
      #    sd = sd.pooled,#
      #    ci.low = ci.low,#
      #    ci.up = ci.up,#
      #    type = outcome.type,#
      #    what = "ECI"#
      #   )#
      # )#
      # working version:#
      tmp.output$EE <- 0#
      tmp.output$ECI <- 0#
      i <- 1#
      for (i in 1:nrow(tmp.output)) {#
        tmp.output$EE[i] <- gfs_compute_evalue(#
          est = tmp.output$estimate.pooled[i],#
          se = tmp.output$se.pooled[i],#
          sd = tmp.output$outcome.sd[i],#
          ci.low = tmp.output$ci.low[i],#
          ci.up = tmp.output$ci.up[i],#
          type = outcome.type,#
          what = "EE"#
        )#
        tmp.output$ECI[i] <- gfs_compute_evalue(#
          est = tmp.output$estimate.pooled[i],#
          se = tmp.output$se.pooled[i],#
          sd = tmp.output$outcome.sd[i],#
          ci.low = tmp.output$ci.low[i],#
          ci.up = tmp.output$ci.up[i],#
          type = outcome.type,#
          what = "ECI"#
        )#
      }#
      output <- tmp.output %>%#
        left_join(termlabels,#
                  by = c("term" = "original"),#
                  relationship = "many-to-many"#
        ) %>%#
        arrange(Variable)#
      # Meta analysis input - is a simplified data.frame with only:#
      # 		country, variable, category, estimate, standard error, and global p-value#
      # 		This reduced file is helpful for the meta-analysis app OR internal meta-analysis code#
      metainput <- output %>%#
        select(#
          COUNTRY,#
          Variable,#
          Category,#
          estimate.pooled,#
          se.pooled,#
          p.value,#
          ci.low,#
          ci.up,#
          df.approx,#
          outcome.sd#
        ) %>%#
        group_by(COUNTRY, Variable) %>%#
        dplyr::filter(!(Category == "(Ref:)")) %>%#
        dplyr::filter(Variable == "FOCAL_PREDICTOR")#
      colnames(metainput) <-#
        c("Country", "Variable", "Category", "Est", "SE", "pvalue", "ci.lb", "ci.ub", "df", "outcome.sd")#
      metainput <- metainput %>%#
        mutate(#
          OUTCOME = your.outcome,#
          FOCAL_PREDICTOR = your.pred,#
          .before = Variable#
        )#
#
      # ============================================================================ ##
      # ============================================================================ ##
      # Online Supplement Analyses - variable specific#
#
      output <- output %>%#
        group_by(Variable) %>%#
        fill(Variable) %>%#
        ungroup() %>%#
        mutate(#
          Variable = case_when(Variable == "AGE_GRP" ~ "Year of birth", .default = Variable),#
          Category = case_when(#
            Variable == "REL1" &#
              str_detect(Category, "Combined") ~ "Collapsed affiliations with prevalence<3%",#
            Category == "25-29" ~ "1993-1998; age 25-29",#
            Category == "30-39" ~ "1983-1993; age 30-39",#
            Category == "40-49" ~ "1973-1983; age 40-49",#
            Category == "50-59" ~ "1963-1973; age 50-59",#
            Category == "60-69" ~ "1953-1963; age 60-69",#
            Category == "70-79" ~ "1943-1953; age 70-79",#
            Category == "80 or older" ~ "1943 or earlier; age 80+",#
            Category == "(Ref:)" &#
              Variable == "AGE_GRP" ~ "(Ref: 1998-2005; current age: 18-24)",#
            Category == "(Ref:)" &#
              Variable == "GENDER" ~ "(Ref: Male)",#
            Category == "(Ref:)" &#
              Variable == "PARENTS_12YRS" ~ "(Ref: Parents married)",#
            Category == "(Ref:)" &#
              Variable == "SVCS_12YRS" ~ "(Ref: Never)",#
            # Category == "(Ref:)" & Variable == "SVCS_MOTHER" ~ "(Ref: Never)",#
            # Category == "(Ref:)" & Variable == "SVCS_FATHER" ~ "(Ref: Never)",#
            Category == "(Ref:)" &#
              Variable == "MOTHER_RELATN" ~ "(Ref: Very bad/somewhat bad)",#
            Category == "(Ref:)" &#
              Variable == "FATHER_RELATN" ~ "(Ref: Very bad/somewhat bad)",#
            # Category == "(Ref:)" & Variable == "MOTHER_LOVED" ~ "(Ref: No)",#
            # Category == "(Ref:)" & Variable == "FATHER_LOVED" ~ "(Ref: No)",#
            Category == "(Ref:)" &#
              Variable == "OUTSIDER" ~ "(Ref: No)",#
            Category == "(Ref:)" &#
              Variable == "ABUSED" ~ "(Ref: No)",#
            Category == "(Ref:)" &#
              Variable == "HEALTH_GROWUP" ~ "(Ref: Good)",#
            Category == "(Ref:)" &#
              Variable == "BORN_COUNTRY" ~ "(Ref: Born in this country)",#
            Category == "(Ref:)" &#
              Variable == "INCOME_12YRS" ~ "(Ref: Got by)",#
            Category == "(Ref:)" &#
              Variable == "RACE_PLURALITY" ~ "(Ref: Plurality group)",#
            Category == "(Ref:)" &#
              Variable == "MOTHER_NA" ~ "(Ref: Non-missing Mother Flags)",#
            Category == "(Ref:)" &#
              Variable == "FATHER_NA" ~ "(Ref: Non-missing Father Flags)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c(#
                "Argentina",#
                "Australia",#
                "Brazil",#
                "China",#
                "Germany",#
                "Hong Kong",#
                "Japan",#
                "Mexico",#
                "Poland",#
                "South Africa",#
                "Spain",#
                "Sweden",#
                "Tanzania",#
                "United Kingdom",#
                "United States"#
              ) &#
              Variable == "REL1" ~ "(Ref: No religion/Atheist/Agnostic)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("Egypt", "Indonesia", "Turkey") &#
              Variable == "REL1" ~ "(Ref: Islam)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("India") &#
              Variable == "REL1" ~ "(Ref: Hinduism)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("Israel") &#
              Variable == "REL1" ~ "(Ref: Judaism)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("Kenya", "Nigeria", "Philippines") &#
              Variable == "REL1" ~ "(Ref: Christianity)",#
            .default = Category#
          )#
        ) %>%#
        dplyr::mutate(#
          OUTCOME = your.outcome,#
          FOCAL_PREDICTOR = your.pred,#
          .before = Variable#
        ) %>%#
        dplyr::mutate(#
          id.Est = .round(estimate.pooled),#
          id.SE = .round(se.pooled),#
          id.CI = paste0("(", .round(ci.low), ",", .round(ci.up), ")"),#
          ## make sure to apply RR approximation is outcome is actually linear#
          rr.Est = case_when(#
          	outcome.type == "RR" ~ .round(exp(estimate.pooled)),#
          	outcome.type == "linear" ~ .round(exp(0.91*estimate.pooled))#
          ),#
          logrr.SE = .round(se.pooled),#
          rr.CI = case_when(#
          	outcome.type == "RR" ~ paste0("(", .round(exp(ci.low)), ",", .round(exp(ci.up)), ")"),#
          	outcome.type == "linear" ~ paste0("(", .round(exp(0.91*ci.low)), ",", .round(exp(0.91*ci.up)), ")")#
          )#
        )#
#
      outfile <- here::here(#
          res.dir,#
          paste0(your.pred,  "_regressed_on_", your.outcome, "_saved_results",appnd.txt.to.filename,".RData")#
        )#
#
      results.vif  <- NULL#
      if(compute.vif){#
      	results.vif <- svy.data.imp %>%#
        select(COUNTRY, .imp, fit.vif) %>%#
        unnest(c(fit.vif)) %>%#
        ungroup()#
      }#
      ## load the previously "saved" result and append results for the next country#
      if(cur.country == "Argentina"){#
      	load(outfile, env.res <- new.env())#
      	output <- rbind(output, env.res$output)#
      	metainput <- rbind(metainput, env.res$metainput)#
      	fit.pca.summary <- rbind(fit.pca.summary, env.res$fit.pca.summary)#
      	if( (!is.null(results.vif)) & (!is.null(env.res$results.vif))){#
      	   results.vif <- rbind(results.vif, env.res$results.vif)#
      	}#
      }#
      ## save/overwrite existing saved results file so everything is in one object#
      save(#
        output,#
        metainput,#
        fit.pca.summary,#
        results.vif,#
        file = outfile#
      )#
      	return(metainput)#
#
      }
metares <- map(df.files, \(x){#
      	 .run_internal_func(x)#
      }) |>#
      bind_rows()
metares
print(metares, n=100)
print(metares, n=100)
df.files
x <- df.files[1]
x
data <- readr::read_rds(here::here(data.dir,x))
cur.country <- as.character(data$COUNTRY[1])
cur.country
{#
        if (str_detect(your.outcome,"APPROVE_GOVT") | str_detect(your.pred,"APPROVE_GOVT")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China","Egypt")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China","Egypt"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if (str_detect(your.outcome,"ABUSED") | str_detect(your.pred,"ABUSED")) {#
          data <- data %>%#
            dplyr::filter(str_detect(COUNTRY,"Israel", negate=TRUE)) %>%#
            dplyr::filter(str_detect(COUNTRY2,"Israel", negate=TRUE)) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if(str_detect(your.outcome,"BELIEVE_GOD") | str_detect(your.pred,"BELIEVE_GOD")) {#
          data <- data %>%#
            dplyr::filter(str_detect(COUNTRY,"Egypt", negate=TRUE)) %>%#
            dplyr::filter(str_detect(COUNTRY2,"Egypt", negate=TRUE)) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
         }#
         if (str_detect(your.outcome,"BELONGING") | str_detect(your.pred,"BELONGING")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if (str_detect(your.outcome,"SAY_IN_GOVT") | str_detect(your.pred,"SAY_IN_GOVT")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
      }#
#
      # convert to nested survey object#
      svy.data.imp <- data %>%#
        mutate(#
          COUNTRY = COUNTRY2,#
          .imp00 = .imp#
        ) %>%#
        group_by(COUNTRY, .imp) %>%#
        nest() %>%#
        mutate(#
          data = map(data, \(x) {#
            x$PRIMARY_OUTCOME <- as.numeric(x[, your.outcome, drop = TRUE])#
            x#
          }),#
          data = map(data, \(x) {#
            x$FOCAL_PREDICTOR <- as.numeric(x[, your.pred, drop = TRUE])#
            x#
          }),#
          data = map(data, \(x) {#
            x %>% mutate(#
              PRIMARY_OUTCOME = case_when(#
                standardize == FALSE ~ PRIMARY_OUTCOME,#
                outcome.type == "linear" & standardize == TRUE ~ svy_scale(PRIMARY_OUTCOME, {{wgt}}, {{psu}}, {{strata}}),#
                .default = PRIMARY_OUTCOME#
              ),#
              FOCAL_PREDICTOR = case_when(#
                standardize == FALSE ~ FOCAL_PREDICTOR,#
                outcome.type == "linear" & standardize == TRUE ~ svy_scale(FOCAL_PREDICTOR, {{wgt}}, {{psu}}, {{strata}}),#
                .default = FOCAL_PREDICTOR#
              )#
            )#
          }),#
          data = map(data, \(tmp.dat){#
            tmp.dat %>%#
              mutate(across(where(is.factor), \(x) droplevels(x)))#
          }),#
          svy.data = map(data, \(x) {#
                x %>%#
                as_survey_design(#
                  ids = {{psu}},#
                  strata = {{strata}},#
                  weights = {{wgt}},#
                  calibrate.formula = ~1#
                )#
            # svydesign(#
            #   data = x,#
            #   ids = ~{{psu}},#
            #   strata = ~{{strata}},#
            #   weights = ~{{wgt}},#
            #   calibrate.formula = ~1#
            # )#
          })#
        )#
#
      if(!is.null(subpopulation)){#
#
        sub.var <- sym(subpopulation[[1]])#
        sub.cat <- subpopulation[[2]]#
        subpop.expr <- expr(!!sub.var %in% !!sub.cat)#
#
        svy.data.imp <- svy.data.imp %>%#
          mutate(#
            data = map(data, \(x){#
              subset(x, eval(subpop.expr))#
            }),#
            svy.data = map(svy.data, \(x){#
              subset(x, eval(subpop.expr))#
            })#
          )#
#
        if(!is.null(subpopulation[[3]])){#
          svy.data.imp <- svy.data.imp %>%#
            filter((COUNTRY %in% c(subpopulation[[3]]) )) %>%#
            mutate(COUNTRY = fct_drop(COUNTRY))#
        }#
      }#
      # IF: pc.rule NOT omit#
      # Conduct PCA and add PCs to data.frames#
      fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
      if( str_to_lower(pc.rule) != "omit"){#
        svy.data.imp <- svy.data.imp %>%#
          mutate(#
            data = map(data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
              append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
            }),#
            svy.data = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
            }),#
            fit.pca = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              svyprcomp(#
                reformulate(var.cont.exposures[keep.cont.exposures]),#
                design = x,#
                scale. = TRUE,#
                scores = TRUE,#
                center = TRUE#
              )#
            }),#
            fit.eigen = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
            })#
          )#
        # get summary of PCA results to save to output file#
        fit.pca.summary <- svy.data.imp %>%#
          mutate(#
            pc.sdev = map(fit.pca, \(x) x$sdev),#
            pc.rotation = map(fit.pca, \(x) x$rotation)#
          ) %>%#
          select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
          unnest(c(pc.sdev, fit.eigen)) %>%#
          mutate(#
            PC = 1:n()#
          ) %>%#
          ungroup() %>%#
          group_by(COUNTRY, PC) %>%#
          summarise(#
            pc.var = mean(pc.sdev**2, na.rm = TRUE)#
          ) %>%#
          ungroup() %>%#
          group_by(COUNTRY) %>%#
          mutate(#
            prop.var = pc.var / sum(pc.var),#
            prop.sum = cumsum(prop.var),#
            Cumulative_Proportion_Explained = prop.sum#
          )#
#
        # check pc.cutoff to determine which PCs to use#
        if (pc.cutoff %% 1 == 0) {#
          keep.num.pc <- rep(pc.cutoff, length(unique(data$COUNTRY2)))#
          names(keep.num.pc) <- unique(data$COUNTRY2)#
        } else {#
          # number of PCs varies by counry based on the total or individual PC % of the variation in the confounders the set of PC account for.#
          if (str_to_lower(pc.rule) == "mintotal") {#
            keep.num.pc0 <- fit.pca.summary %>%#
              dplyr::filter(prop.sum >= pc.cutoff) %>%#
              dplyr::filter(PC == min(PC, na.rm = TRUE))#
            keep.num.pc <- keep.num.pc0$PC#
            names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
          }#
          if (str_to_lower(pc.rule) == "mincomp") {#
            keep.num.pc0 <- fit.pca.summary %>%#
              dplyr::filter(prop.var >= pc.cutoff)#
            if (nrow(keep.num.pc0) < 23) {#
              # cutoff fails because too stringent, switching to a default of 0.02#
              keep.num.pc0 <- fit.pca.summary %>%#
                dplyr::filter(prop.var >= 0.02)#
            }#
            keep.num.pc0 <- keep.num.pc0 %>%#
              dplyr::filter(PC == max(PC, na.rm = TRUE))#
            keep.num.pc <- keep.num.pc0$PC#
            names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
          }#
          if (str_to_lower(pc.rule) == "omit") {#
            # this is just to avoid errors and is not used#
            keep.num.pc <- rep(0, length(unique(data$COUNTRY2)))#
            names(keep.num.pc) <- unique(data$COUNTRY2)#
          }#
        }#
        tmp.df.pca <- data.frame(#
          COUNTRY = names(keep.num.pc),#
          NumPCAkeep = keep.num.pc#
        )#
        tmp.df.pca$Rule <- pc.rule#
        tmp.df.pca$Cutoff <- pc.cutoff#
        fit.pca.summary <- dplyr::left_join(fit.pca.summary, tmp.df.pca)#
      }#
#
      # # test:#
      # tmp.data <- svy.data.imp %>%#
      # filter(COUNTRY == "United States", .imp == 1)#
#
      # get_aicc_by_pc <- function(keep.num.pc, x){#
      # #x = tmp.data$svy.data[[1]]#
      # #keep.num.pc = 1#
      # # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
      # keep.var <- unlist(lapply(covariates, check.var, dat = x[['variables']]))#
      # tmp.model <- reformulate(#
      # response = "PRIMARY_OUTCOME",#
      # termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_",1:keep.num.pc))#
      # )#
      # tmp.fit <-  svyglm(tmp.model, design = x)#
      # k <- tmp.fit$rank +1 # number of dimensions of design matrix plus residual variance#
      # n <- sum(tmp.fit$weights)#
      # # AICC#
      # tmp.fit$aic + n*(n+k)/(n-k-2)#
#
      # }#
#
      # est.aicc <- map(1:(length(var.cont.exposures)-1), \(y){#
      # get_aicc_by_pc(y, tmp.data$svy.data[[1]])#
      # })#
      # plot.dat <- data.frame(PC = 1:(length(var.cont.exposures)-1), AICC = unlist(est.aicc))#
#
      # ggplot(plot.dat, aes(x=PC, y=AICC))+#
      # geom_point()+#
      # geom_line()
svy.data.imp <- svy.data.imp %>%#
        dplyr::mutate(#
          svy.fit = purrr::map(svy.data, \(x) {#
            tmp.fit <- NULL#
            # first check if ANY variance on outomce#
            run.analysis <- ifelse(var(x[["variables"]][["PRIMARY_OUTCOME"]], na.rm=TRUE) > 0, TRUE, FALSE)#
            if (run.analysis) {#
              cur.country <- x[["variables"]][["COUNTRY2"]][1]#
              # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
              keep.var <- keep_variable(covariates, data = x[["variables"]])#
              if (str_to_lower(pc.rule) == "omit") {#
                tmp.model <- reformulate(#
                  response = "PRIMARY_OUTCOME",#
                  termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
                )#
              } else {#
                tmp.model <- reformulate(#
                  response = "PRIMARY_OUTCOME",#
                  termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[cur.country])))#
                )#
              }#
#
              if (outcome.type == "linear") {#
                tmp.fit <- gfs_svyglm(#
                  tmp.model,#
                  svy.design = x,#
                  family = stats::gaussian(),#
                  robust.huberM = robust.huberM,#
                  robust.tune = robust.tune#
                )#
              }#
              if (outcome.type == "RR") {#
                tmp.fit <- gfs_svyglm(#
                  tmp.model,#
                  svy.design = x,#
                  family = stats::quassipoisson(),#
                  robust.huberM = FALSE#
                )#
              }#
              tmp.fit#
            }#
          }),#
          fit.tidy = map(svy.fit, \(x) x$fit.tidy),#
          fit.vif = map(svy.fit, \(x){#
          	out = NULL#
          	if(compute.vif){#
          		mm <- model.matrix(x$fit)#
          		tmp = svydiags::svyvif(mobj = x$fit, X=mm[,-1], w=x$fit$weights)#
           		out = as.data.frame(tmp[['Intercept adjusted']]) %>% rowid_to_column(var="Predictor")#
          	}#
          	out#
          })#
        ) %>%#
        ungroup()
tmp.dat <- svy.data.imp#
      keep.var <- keep_variable(covariates, data = tmp.dat$data[[1]])#
      if (str_to_lower(pc.rule) == "omit") {#
        tmp.model <- reformulate(#
          response = "PRIMARY_OUTCOME",#
          termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
        )#
      } else {#
        tmp.country <- names(keep.num.pc)[which(keep.num.pc == max(keep.num.pc))[1]]#
        tmp.model <- reformulate(#
          response = "PRIMARY_OUTCOME",#
          termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[tmp.country])))#
        )#
      }#
      tmp.fit <- tmp.dat$data[[1]] %>% glm(tmp.model, data = .)#
      # which model doesn't matter for this step, we only need the variable names#
#
      coef.order <- names(tmp.fit$coefficients)#
      coef.order <- c(#
        coef.order[!(stringr::str_detect(coef.order, "(Intercept)") | stringr::str_detect(coef.order, "COV_REL1"))],#
        "COV_GENDER_Y1Prefer not to answer",#
        "COV_REL1_Y1Islam", "COV_REL1_Y1Hinduism", "COV_REL1_Y1Judaism", "COV_REL1_Y1Buddhism",#
        "COV_REL1_Y1Primal,Animist, or Folk religion", "COV_REL1_Y1Chinesefolk/traditional religion",#
        "COV_REL1_Y1Christianity", "COV_REL1_Y1Combined",#
        "(Intercept)"#
      )
results.pooled <- svy.data.imp %>%#
        select(COUNTRY, .imp, fit.tidy) %>%#
        unnest(c(fit.tidy)) %>%#
        ungroup() %>%#
        group_by(term, COUNTRY) %>%#
        nest() %>%#
        mutate(#
          pooled.est = map(data, \(x){#
            gfs_pool_estimates(x)#
          }),#
          estimates.by.imp = data#
        ) %>%#
        unnest(c(pooled.est)) %>%#
        select(-c(data)) %>%#
        unique() %>%#
        mutate(#
          term = factor(term)#
        ) %>%#
        arrange(COUNTRY, term) %>%#
        ungroup()
results.pooled
print(results.pooled, n=100)
varlist <- stringr::str_split_1(paste0(tmp.fit$formula)[[3]], " \\+ ")#
      termlist <- as.character(unique(results.pooled$term))[-1]#
#
      base_variable <- sapply(termlist, function(b) {#
        match <- sapply(varlist, function(a) {#
          startsWith(b, a)#
        })#
        varlist[which(match)]#
      })#
      base_variable <- base_variable %>%#
        as.data.frame() %>%#
        pull(.)#
      levels <- gsub(paste(unlist(base_variable), collapse = "|"), "", termlist)#
      termlabels <- data.frame(#
        original = c(rep("(Ref:)", length(termlist)), termlist, "(Intercept)"),#
        Variable = c(rep(base_variable, 2), "(Intercept)"),#
        Category = c(rep(levels, 2), "(Intercept)")#
      )
termlabels <- termlabels %>%#
        mutate(#
          Variable = stringr::str_remove(Variable, "COV_"),#
          Category = case_when(#
            stringr::str_detect(Variable, "PC_") ~ stringr::str_remove(stringr::str_sub(Variable, -2, -1), "_"),#
            Variable == "MOTHER_RELATN_Y1" ~ "Very good/somewhat good",#
            Variable == "FATHER_RELATN_Y1" ~ "Very good/somewhat good",#
            Variable == "RACE_PLURALITY" ~ "Non-plurality groups",#
            Variable == "MOTHER_NA" ~ "Mother NA flag",#
            Variable == "FATHER_NA" ~ "Father NA flag",#
            .default = Category#
          )#
        )
sd.pooled <- svy.data.imp %>%#
        mutate(#
          est = purrr::map_dbl(svy.data, \(x) {#
          	survey::svyvar(~PRIMARY_OUTCOME, design = x, na.rm=TRUE)#
          }),#
          pred.var = purrr::map_dbl(svy.data, \(x) {#
          	survey::svyvar(~FOCAL_PREDICTOR, design = x, na.rm=TRUE)#
          })#
        ) %>%#
        ungroup() %>%#
        select(COUNTRY, .imp, est, pred.var) %>%#
        group_by(COUNTRY) %>%#
        summarize(#
          outcome.sd = sqrt(mean(est, na.rm=TRUE)),#
          predictor.sd = sqrt(mean(pred.var, na.rm=TRUE))#
        ) %>%#
        select(COUNTRY, outcome.sd, predictor.sd)
if (standardize) {#
        sd.pooled$outcome.sd <- 1#
        sd.pooled$predictor.sd <- 1#
      }
# Compute Evalues#
      tmp.output <- results.pooled %>%#
        left_join(sd.pooled, by = "COUNTRY") %>%#
        ungroup()
tmp.output$EE <- 0#
      tmp.output$ECI <- 0#
      i <- 1#
      for (i in 1:nrow(tmp.output)) {#
        tmp.output$EE[i] <- gfs_compute_evalue(#
          est = tmp.output$estimate.pooled[i],#
          se = tmp.output$se.pooled[i],#
          sd = tmp.output$outcome.sd[i],#
          ci.low = tmp.output$ci.low[i],#
          ci.up = tmp.output$ci.up[i],#
          type = outcome.type,#
          what = "EE"#
        )#
        tmp.output$ECI[i] <- gfs_compute_evalue(#
          est = tmp.output$estimate.pooled[i],#
          se = tmp.output$se.pooled[i],#
          sd = tmp.output$outcome.sd[i],#
          ci.low = tmp.output$ci.low[i],#
          ci.up = tmp.output$ci.up[i],#
          type = outcome.type,#
          what = "ECI"#
        )#
      }
output <- tmp.output %>%#
        left_join(termlabels,#
                  by = c("term" = "original"),#
                  relationship = "many-to-many"#
        ) %>%#
        arrange(Variable)
output
metainput <- output %>%#
        select(#
          COUNTRY,#
          Variable,#
          Category,#
          estimate.pooled,#
          se.pooled,#
          p.value,#
          ci.low,#
          ci.up,#
          df.approx,#
          outcome.sd#
        ) %>%#
        group_by(COUNTRY, Variable) %>%#
        dplyr::filter(!(Category == "(Ref:)")) %>%#
        dplyr::filter(Variable == "FOCAL_PREDICTOR")#
      colnames(metainput) <-#
        c("Country", "Variable", "Category", "Est", "SE", "pvalue", "ci.lb", "ci.ub", "df", "outcome.sd")
metainput <- metainput %>%#
        mutate(#
          OUTCOME = your.outcome,#
          FOCAL_PREDICTOR = your.pred,#
          .before = Variable#
        )
metainput
output <- output %>%#
        group_by(Variable) %>%#
        fill(Variable) %>%#
        ungroup() %>%#
        mutate(#
          Variable = case_when(Variable == "AGE_GRP" ~ "Year of birth", .default = Variable),#
          Category = case_when(#
            Variable == "REL1" &#
              str_detect(Category, "Combined") ~ "Collapsed affiliations with prevalence<3%",#
            Category == "25-29" ~ "1993-1998; age 25-29",#
            Category == "30-39" ~ "1983-1993; age 30-39",#
            Category == "40-49" ~ "1973-1983; age 40-49",#
            Category == "50-59" ~ "1963-1973; age 50-59",#
            Category == "60-69" ~ "1953-1963; age 60-69",#
            Category == "70-79" ~ "1943-1953; age 70-79",#
            Category == "80 or older" ~ "1943 or earlier; age 80+",#
            Category == "(Ref:)" &#
              Variable == "AGE_GRP" ~ "(Ref: 1998-2005; current age: 18-24)",#
            Category == "(Ref:)" &#
              Variable == "GENDER" ~ "(Ref: Male)",#
            Category == "(Ref:)" &#
              Variable == "PARENTS_12YRS" ~ "(Ref: Parents married)",#
            Category == "(Ref:)" &#
              Variable == "SVCS_12YRS" ~ "(Ref: Never)",#
            # Category == "(Ref:)" & Variable == "SVCS_MOTHER" ~ "(Ref: Never)",#
            # Category == "(Ref:)" & Variable == "SVCS_FATHER" ~ "(Ref: Never)",#
            Category == "(Ref:)" &#
              Variable == "MOTHER_RELATN" ~ "(Ref: Very bad/somewhat bad)",#
            Category == "(Ref:)" &#
              Variable == "FATHER_RELATN" ~ "(Ref: Very bad/somewhat bad)",#
            # Category == "(Ref:)" & Variable == "MOTHER_LOVED" ~ "(Ref: No)",#
            # Category == "(Ref:)" & Variable == "FATHER_LOVED" ~ "(Ref: No)",#
            Category == "(Ref:)" &#
              Variable == "OUTSIDER" ~ "(Ref: No)",#
            Category == "(Ref:)" &#
              Variable == "ABUSED" ~ "(Ref: No)",#
            Category == "(Ref:)" &#
              Variable == "HEALTH_GROWUP" ~ "(Ref: Good)",#
            Category == "(Ref:)" &#
              Variable == "BORN_COUNTRY" ~ "(Ref: Born in this country)",#
            Category == "(Ref:)" &#
              Variable == "INCOME_12YRS" ~ "(Ref: Got by)",#
            Category == "(Ref:)" &#
              Variable == "RACE_PLURALITY" ~ "(Ref: Plurality group)",#
            Category == "(Ref:)" &#
              Variable == "MOTHER_NA" ~ "(Ref: Non-missing Mother Flags)",#
            Category == "(Ref:)" &#
              Variable == "FATHER_NA" ~ "(Ref: Non-missing Father Flags)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c(#
                "Argentina",#
                "Australia",#
                "Brazil",#
                "China",#
                "Germany",#
                "Hong Kong",#
                "Japan",#
                "Mexico",#
                "Poland",#
                "South Africa",#
                "Spain",#
                "Sweden",#
                "Tanzania",#
                "United Kingdom",#
                "United States"#
              ) &#
              Variable == "REL1" ~ "(Ref: No religion/Atheist/Agnostic)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("Egypt", "Indonesia", "Turkey") &#
              Variable == "REL1" ~ "(Ref: Islam)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("India") &#
              Variable == "REL1" ~ "(Ref: Hinduism)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("Israel") &#
              Variable == "REL1" ~ "(Ref: Judaism)",#
            Category == "(Ref:)" &#
              COUNTRY %in% c("Kenya", "Nigeria", "Philippines") &#
              Variable == "REL1" ~ "(Ref: Christianity)",#
            .default = Category#
          )#
        ) %>%#
        dplyr::mutate(#
          OUTCOME = your.outcome,#
          FOCAL_PREDICTOR = your.pred,#
          .before = Variable#
        ) %>%#
        dplyr::mutate(#
          id.Est = .round(estimate.pooled),#
          id.SE = .round(se.pooled),#
          id.CI = paste0("(", .round(ci.low), ",", .round(ci.up), ")"),#
          ## make sure to apply RR approximation is outcome is actually linear#
          rr.Est = case_when(#
          	outcome.type == "RR" ~ .round(exp(estimate.pooled)),#
          	outcome.type == "linear" ~ .round(exp(0.91*estimate.pooled))#
          ),#
          logrr.SE = .round(se.pooled),#
          rr.CI = case_when(#
          	outcome.type == "RR" ~ paste0("(", .round(exp(ci.low)), ",", .round(exp(ci.up)), ")"),#
          	outcome.type == "linear" ~ paste0("(", .round(exp(0.91*ci.low)), ",", .round(exp(0.91*ci.up)), ")")#
          )#
        )#
#
      outfile <- here::here(#
          res.dir,#
          paste0(your.pred,  "_regressed_on_", your.outcome, "_saved_results",appnd.txt.to.filename,".RData")#
        )
devtools::load_all()
VARIABLES.VEC <- RECODE.DEFAULTS[['VARIABLES.VEC']]#
OUTCOME.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "_Y2")]#
CONTEMPORANEOUS.EXPOSURES.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "COMPOSITE", negate = TRUE)]#
CONTEMPORANEOUS.EXPOSURES.VEC <- CONTEMPORANEOUS.EXPOSURES.VEC[str_detect(CONTEMPORANEOUS.EXPOSURES.VEC, "_Y1")]#
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER_Y1",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)#
# Run country-specific regression analyses for ALL wave 2 outcomes#
OUTCOME.VEC0 <- OUTCOME.VEC # c(1, 8, 24)+76,#
your.outcome <- OUTCOME.VEC0[2]#
#
# Model 1: Run without principal components#
LIST.RES <- map(OUTCOME.VEC0, \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      wgt = ANNUAL_WEIGHT_R2, # wgt = as.name("ANNUAL_WEIGHT_R2")#
      psu = PSU, #psu = as.name("PSU")#
      strata = STRATA, # strata = as.name("STRATA")#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.rule = "omit",#
      res.dir = "results-primary",#
      appnd.txt.to.filename = "_primary_wopc"#
    )#
  }) }, .progress = TRUE)
rlang::last_trace()
covariates
tmp.dat
keep_variable(covariates, data = tmp.dat$data[[1]])
rlang::last_trace(drop = FALSE)
tmp.dat <- svy.data.imp#
      keep.var <- rep(FALSE, length(covariates))#
      for(i in 1:length(keep.var)){#
      	if(keep.var %in% colnames(tmp.dat$data[[1]])){#
      		keep.var[i] <- keep_variable(covariates[i], data = tmp.dat$data[[1]])#
      	} #
      }
tmp.dat <- svy.data.imp#
      keep.var <- rep(FALSE, length(covariates))#
      for(i in 1:length(keep.var)){#
      	if(keep.var[i] %in% colnames(tmp.dat$data[[1]])){#
      		keep.var[i] <- keep_variable(covariates[i], data = tmp.dat$data[[1]])#
      	} #
      }
keep.var
colnames(tmp.dat$data[[1]])
tmp.dat <- svy.data.imp#
      keep.var <- rep(FALSE, length(covariates))#
      for(i in 1:length(keep.var)){#
      	if(covariates[i] %in% colnames(tmp.dat$data[[1]])){#
      		keep.var[i] <- keep_variable(covariates[i], data = tmp.dat$data[[1]])#
      	} #
      }
keep.var
df.files
x <- df.files[4]
data <- readr::read_rds(here::here(data.dir,x))#
      ## check which country is being analyzed#
      cur.country <- as.character(data$COUNTRY[1])#
      # outcomes/predictor combinations in which the countries must be subset...#
      {#
        if (str_detect(your.outcome,"APPROVE_GOVT") | str_detect(your.pred,"APPROVE_GOVT")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China","Egypt")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China","Egypt"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if (str_detect(your.outcome,"ABUSED") | str_detect(your.pred,"ABUSED")) {#
          data <- data %>%#
            dplyr::filter(str_detect(COUNTRY,"Israel", negate=TRUE)) %>%#
            dplyr::filter(str_detect(COUNTRY2,"Israel", negate=TRUE)) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if(str_detect(your.outcome,"BELIEVE_GOD") | str_detect(your.pred,"BELIEVE_GOD")) {#
          data <- data %>%#
            dplyr::filter(str_detect(COUNTRY,"Egypt", negate=TRUE)) %>%#
            dplyr::filter(str_detect(COUNTRY2,"Egypt", negate=TRUE)) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
         }#
         if (str_detect(your.outcome,"BELONGING") | str_detect(your.pred,"BELONGING")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
        if (str_detect(your.outcome,"SAY_IN_GOVT") | str_detect(your.pred,"SAY_IN_GOVT")) {#
          data <- data %>%#
            dplyr::filter( !(COUNTRY %in% c("China")) ) %>%#
            dplyr::filter( !(COUNTRY2 %in% c("China"))) %>%#
            mutate(#
              COUNTRY = fct_drop(COUNTRY),#
              COUNTRY2 = fct_drop(COUNTRY2)#
            )#
        }#
      }#
#
      # convert to nested survey object#
      svy.data.imp <- data %>%#
        mutate(#
          COUNTRY = COUNTRY2,#
          .imp00 = .imp#
        ) %>%#
        group_by(COUNTRY, .imp) %>%#
        nest() %>%#
        mutate(#
          data = map(data, \(x) {#
            x$PRIMARY_OUTCOME <- as.numeric(x[, your.outcome, drop = TRUE])#
            x#
          }),#
          data = map(data, \(x) {#
            x$FOCAL_PREDICTOR <- as.numeric(x[, your.pred, drop = TRUE])#
            x#
          }),#
          data = map(data, \(x) {#
            x %>% mutate(#
              PRIMARY_OUTCOME = case_when(#
                standardize == FALSE ~ PRIMARY_OUTCOME,#
                outcome.type == "linear" & standardize == TRUE ~ svy_scale(PRIMARY_OUTCOME, {{wgt}}, {{psu}}, {{strata}}),#
                .default = PRIMARY_OUTCOME#
              ),#
              FOCAL_PREDICTOR = case_when(#
                standardize == FALSE ~ FOCAL_PREDICTOR,#
                outcome.type == "linear" & standardize == TRUE ~ svy_scale(FOCAL_PREDICTOR, {{wgt}}, {{psu}}, {{strata}}),#
                .default = FOCAL_PREDICTOR#
              )#
            )#
          }),#
          data = map(data, \(tmp.dat){#
            tmp.dat %>%#
              mutate(across(where(is.factor), \(x) droplevels(x)))#
          }),#
          svy.data = map(data, \(x) {#
                x %>%#
                as_survey_design(#
                  ids = {{psu}},#
                  strata = {{strata}},#
                  weights = {{wgt}},#
                  calibrate.formula = ~1#
                )#
            # svydesign(#
            #   data = x,#
            #   ids = ~{{psu}},#
            #   strata = ~{{strata}},#
            #   weights = ~{{wgt}},#
            #   calibrate.formula = ~1#
            # )#
          })#
        )#
#
      if(!is.null(subpopulation)){#
#
        sub.var <- sym(subpopulation[[1]])#
        sub.cat <- subpopulation[[2]]#
        subpop.expr <- expr(!!sub.var %in% !!sub.cat)#
#
        svy.data.imp <- svy.data.imp %>%#
          mutate(#
            data = map(data, \(x){#
              subset(x, eval(subpop.expr))#
            }),#
            svy.data = map(svy.data, \(x){#
              subset(x, eval(subpop.expr))#
            })#
          )#
#
        if(!is.null(subpopulation[[3]])){#
          svy.data.imp <- svy.data.imp %>%#
            filter((COUNTRY %in% c(subpopulation[[3]]) )) %>%#
            mutate(COUNTRY = fct_drop(COUNTRY))#
        }#
      }#
      # IF: pc.rule NOT omit#
      # Conduct PCA and add PCs to data.frames#
      fit.pca.summary = NULL # need to initialize object to not throw error when saving data#
      if( str_to_lower(pc.rule) != "omit"){#
        svy.data.imp <- svy.data.imp %>%#
          mutate(#
            data = map(data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x)#
              append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
            }),#
            svy.data = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              append_pc_to_df(x, var = var.cont.exposures[keep.cont.exposures], std = TRUE)#
            }),#
            fit.pca = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              svyprcomp(#
                reformulate(var.cont.exposures[keep.cont.exposures]),#
                design = x,#
                scale. = TRUE,#
                scores = TRUE,#
                center = TRUE#
              )#
            }),#
            fit.eigen = map(svy.data, \(x) {#
              keep.cont.exposures <- keep_variable(var.cont.exposures, data = x[["variables"]])#
              get_eigenvalues(x, var.cont.exposures[keep.cont.exposures])#
            })#
          )#
        # get summary of PCA results to save to output file#
        fit.pca.summary <- svy.data.imp %>%#
          mutate(#
            pc.sdev = map(fit.pca, \(x) x$sdev),#
            pc.rotation = map(fit.pca, \(x) x$rotation)#
          ) %>%#
          select(.imp, COUNTRY, pc.sdev, fit.eigen) %>%#
          unnest(c(pc.sdev, fit.eigen)) %>%#
          mutate(#
            PC = 1:n()#
          ) %>%#
          ungroup() %>%#
          group_by(COUNTRY, PC) %>%#
          summarise(#
            pc.var = mean(pc.sdev**2, na.rm = TRUE)#
          ) %>%#
          ungroup() %>%#
          group_by(COUNTRY) %>%#
          mutate(#
            prop.var = pc.var / sum(pc.var),#
            prop.sum = cumsum(prop.var),#
            Cumulative_Proportion_Explained = prop.sum#
          )#
#
        # check pc.cutoff to determine which PCs to use#
        if (pc.cutoff %% 1 == 0) {#
          keep.num.pc <- rep(pc.cutoff, length(unique(data$COUNTRY2)))#
          names(keep.num.pc) <- unique(data$COUNTRY2)#
        } else {#
          # number of PCs varies by counry based on the total or individual PC % of the variation in the confounders the set of PC account for.#
          if (str_to_lower(pc.rule) == "mintotal") {#
            keep.num.pc0 <- fit.pca.summary %>%#
              dplyr::filter(prop.sum >= pc.cutoff) %>%#
              dplyr::filter(PC == min(PC, na.rm = TRUE))#
            keep.num.pc <- keep.num.pc0$PC#
            names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
          }#
          if (str_to_lower(pc.rule) == "mincomp") {#
            keep.num.pc0 <- fit.pca.summary %>%#
              dplyr::filter(prop.var >= pc.cutoff)#
            if (nrow(keep.num.pc0) < 23) {#
              # cutoff fails because too stringent, switching to a default of 0.02#
              keep.num.pc0 <- fit.pca.summary %>%#
                dplyr::filter(prop.var >= 0.02)#
            }#
            keep.num.pc0 <- keep.num.pc0 %>%#
              dplyr::filter(PC == max(PC, na.rm = TRUE))#
            keep.num.pc <- keep.num.pc0$PC#
            names(keep.num.pc) <- keep.num.pc0$COUNTRY2#
          }#
          if (str_to_lower(pc.rule) == "omit") {#
            # this is just to avoid errors and is not used#
            keep.num.pc <- rep(0, length(unique(data$COUNTRY2)))#
            names(keep.num.pc) <- unique(data$COUNTRY2)#
          }#
        }#
        tmp.df.pca <- data.frame(#
          COUNTRY = names(keep.num.pc),#
          NumPCAkeep = keep.num.pc#
        )#
        tmp.df.pca$Rule <- pc.rule#
        tmp.df.pca$Cutoff <- pc.cutoff#
        fit.pca.summary <- dplyr::left_join(fit.pca.summary, tmp.df.pca)#
      }#
#
      # # test:#
      # tmp.data <- svy.data.imp %>%#
      # filter(COUNTRY == "United States", .imp == 1)#
#
      # get_aicc_by_pc <- function(keep.num.pc, x){#
      # #x = tmp.data$svy.data[[1]]#
      # #keep.num.pc = 1#
      # # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
      # keep.var <- unlist(lapply(covariates, check.var, dat = x[['variables']]))#
      # tmp.model <- reformulate(#
      # response = "PRIMARY_OUTCOME",#
      # termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_",1:keep.num.pc))#
      # )#
      # tmp.fit <-  svyglm(tmp.model, design = x)#
      # k <- tmp.fit$rank +1 # number of dimensions of design matrix plus residual variance#
      # n <- sum(tmp.fit$weights)#
      # # AICC#
      # tmp.fit$aic + n*(n+k)/(n-k-2)#
#
      # }#
#
      # est.aicc <- map(1:(length(var.cont.exposures)-1), \(y){#
      # get_aicc_by_pc(y, tmp.data$svy.data[[1]])#
      # })#
      # plot.dat <- data.frame(PC = 1:(length(var.cont.exposures)-1), AICC = unlist(est.aicc))#
#
      # ggplot(plot.dat, aes(x=PC, y=AICC))+#
      # geom_point()+#
      # geom_line()#
#
      # ============================================================================================== ##
      # RUN REGRESSION ANALYSIS#
      # svy.data.imp is a nested df by country & .imp#
      svy.data.imp <- svy.data.imp %>%#
        dplyr::mutate(#
          svy.fit = purrr::map(svy.data, \(x) {#
            tmp.fit <- NULL#
            # first check if ANY variance on outomce#
            run.analysis <- ifelse(var(x[["variables"]][["PRIMARY_OUTCOME"]], na.rm=TRUE) > 0, TRUE, FALSE)#
            if (run.analysis) {#
              cur.country <- x[["variables"]][["COUNTRY2"]][1]#
              # Next check each variable to make sure all have at least 2 levels, if only 1, exclude#
              keep.var <- keep_variable(covariates, data = x[["variables"]])#
              if (str_to_lower(pc.rule) == "omit") {#
                tmp.model <- reformulate(#
                  response = "PRIMARY_OUTCOME",#
                  termlabels = c("FOCAL_PREDICTOR", covariates[keep.var])#
                )#
              } else {#
                tmp.model <- reformulate(#
                  response = "PRIMARY_OUTCOME",#
                  termlabels = c("FOCAL_PREDICTOR", covariates[keep.var], paste0("PC_", 1:(keep.num.pc[cur.country])))#
                )#
              }#
#
              if (outcome.type == "linear") {#
                tmp.fit <- gfs_svyglm(#
                  tmp.model,#
                  svy.design = x,#
                  family = stats::gaussian(),#
                  robust.huberM = robust.huberM,#
                  robust.tune = robust.tune#
                )#
              }#
              if (outcome.type == "RR") {#
                tmp.fit <- gfs_svyglm(#
                  tmp.model,#
                  svy.design = x,#
                  family = stats::quassipoisson(),#
                  robust.huberM = FALSE#
                )#
              }#
              tmp.fit#
            }#
          }),#
          fit.tidy = map(svy.fit, \(x) x$fit.tidy),#
          fit.vif = map(svy.fit, \(x){#
          	out = NULL#
          	if(compute.vif){#
          		mm <- model.matrix(x$fit)#
          		tmp = svydiags::svyvif(mobj = x$fit, X=mm[,-1], w=x$fit$weights)#
           		out = as.data.frame(tmp[['Intercept adjusted']]) %>% rowid_to_column(var="Predictor")#
          	}#
          	out#
          })#
        ) %>%#
        ungroup()
tmp.dat <- svy.data.imp
keep.var <- rep(FALSE, length(covariates))
for(i in 1:length(keep.var)){#
      	if(covariates[i] %in% colnames(tmp.dat$data[[1]])){#
      		keep.var[i] <- keep_variable(covariates[i], data = tmp.dat$data[[1]])#
      	} #
      }
tmp.dat$data[[1]]
svy.data.imp
data
data <- readr::read_rds(here::here(data.dir,x))
data
cur.country <- as.character(data$COUNTRY[1])
devtools::load_all()
LIST.RES <- map(OUTCOME.VEC0, \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      wgt = ANNUAL_WEIGHT_R2, # wgt = as.name("ANNUAL_WEIGHT_R2")#
      psu = PSU, #psu = as.name("PSU")#
      strata = STRATA, # strata = as.name("STRATA")#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.rule = "omit",#
      res.dir = "results-primary",#
      appnd.txt.to.filename = "_primary_wopc"#
    )#
  }) }, .progress = TRUE)
LIST.RES
LIST.RES <- construct_meta_input_from_saved_results("results-primary", OUTCOME.VEC0, FOCAL_PREDICTOR, appnd.txt = "_primary_wopc")#
meta.input <- LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()
META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Excluded -- Full Imputation Approach"#
)
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-primary", "0_meta_analyzed_results_primary_wopc_2.rds"),#
  compress = "gz"#
)
names(META.RES)
colnames(META.RES)
META.RES %>% filter(OUTCOME0 == "COMPOSITE_FLOURISHING_SECURE_Y2")
META.RES %>% filter(OUTCOME0 == "COMPOSITE_FLOURISHING_SECURE_Y2")
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-primary", "0_meta_analyzed_results_primary_wopc.rds"),#
  compress = "gz"#
)
OUTCOME.VEC0
class(data)
nrow(data)
data2 <- subset(data, CASE_OBSERVED_Y2 == 1)
nrow(data2)
direct.subset = expr(CASE_OBSERVED_Y2 == 1)
data2 <- subset(data, eval(direct.subset))
nrow(data2)
devtools::load_all()
SUPP.LIST.RES <- map(OUTCOME.VEC0[73:79], \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      direct.subset = expr(CASE_OBSERVED_Y2 == 1),#
      wgt = SAMP.ATTR.WGT,#
      psu = PSU,#
      strata = STRATA,#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.rule = "omit",#
      res.dir = "results-cca",#
      appnd.txt.to.filename = "_cca_wopc"#
    )#
  }) }, .progress = TRUE)
colnames(data)
recode_imp_by_country(#
    data.dir,#
    list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES,#
    wgt = "ANNUAL_WEIGHT_R2",#
    .nimp = 2#
  )
run_attrition_model_by_country(#
  data.dir,#
  obs.id.var = "CASE_OBSERVED_Y2",#
  attr.pred = c(#
    "ANNUAL_WEIGHT_R2", "MODE_RECRUIT",#
    'COMPOSITE_HAPPI_LIFE_SAT_Y1', 'COMPOSITE_HEALTH_Y1', 'COMPOSITE_MEANING_PURPOSE_Y1',#
    'COMPOSITE_CHARACTER_Y1', 'COMPOSITE_SUBJECTIVE_SOC_CONN_Y1', 'COMPOSITE_FINL_MAT_WORRY_Y1',#
    'COMPOSITE_EXTRAVERSION_Y1', 'COMPOSITE_OPENNESS_Y1', 'COMPOSITE_AGREEABLENESS_Y1',#
    'COMPOSITE_CONSCIENTIOUSNESS_Y1', 'COMPOSITE_NEUROTICISM_Y1',#
    'COMPOSITE_DEPRESSION_Y1', 'COMPOSITE_ANXIETY_Y1', 'LONELY_Y1', 'DAYS_EXERCISE_Y1',#
    'COV_AGE_GRP_Y1', 'COV_GENDER', 'COV_MARITAL_STATUS_Y1', 'COV_EMPLOYMENT_Y1',#
    'COV_ATTEND_SVCS_Y1', 'COV_EDUCATION_3_Y1', 'COV_BORN_COUNTRY_Y1', "COV_RACE_PLURALITY",#
    "COV_URBAN_RURAL_Y1", 'COV_INCOME_Y1'#
  ),#
  wgt = "ANNUAL_WEIGHT_R2", strata = "STRATA", psu = "PSU"#
)#
#
## append attrition weights to imputed data#
append_attr_wgts_to_imp_data(data.dir, attr.dir = "results-attr")
SUPP.LIST.RES <- map(OUTCOME.VEC0[73:79], \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      direct.subset = expr(CASE_OBSERVED_Y2 == 1),#
      wgt = SAMP.ATTR.WGT,#
      psu = PSU,#
      strata = STRATA,#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.rule = "omit",#
      res.dir = "results-cca",#
      appnd.txt.to.filename = "_cca_wopc"#
    )#
  }) }, .progress = TRUE)
SUPP.LIST.RES <- construct_meta_input_from_saved_results("results-cca", OUTCOME.VEC0[73:79], FOCAL_PREDICTOR, appnd.txt = "_cca_wopc")#
meta.input <- SUPP.LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
SUPP.META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Excluded -- Complete Case Analysis"#
)
SUPP.META.RES
sqrt(0.02)
sqrt(0.005)
LIST.RES <- map(OUTCOME.VEC0[73:79], \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      wgt = ANNUAL_WEIGHT_R2, # wgt = as.name("ANNUAL_WEIGHT_R2")#
      psu = PSU, #psu = as.name("PSU")#
      strata = STRATA, # strata = as.name("STRATA")#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.cutoff = 7,#
      pc.rule = "constant",#
      res.dir = "results-primary",#
      appnd.txt.to.filename = "_primary_wpc"#
    )#
  }) }, .progress = TRUE)#
#
LIST.RES <- construct_meta_input_from_saved_results("results-primary", OUTCOME.VEC0[73:79], FOCAL_PREDICTOR, appnd.txt = "_primary_wpc")#
meta.input <- LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
#
META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Included -- Full Imputation Approach"#
)#
#
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-primary","0_meta_analyzed_results_primary_wpc.rds"),#
  compress = "gz"#
)#
remove(meta.input, LIST.RES, META.RES)#
#
# ================================================================================================ ##
# ================================================================================================ ##
# Run supplemental country-wise analyses -- "Complete Case Analysis"#
# - Uses attrition-weight adjusted sampling weights#
#
# Supplemental analysis set 1: Run without principal components#
SUPP.LIST.RES <- map(OUTCOME.VEC0[73:79], \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      direct.subset = expr(CASE_OBSERVED_Y2 == 1),#
      wgt = SAMP.ATTR.WGT,#
      psu = PSU,#
      strata = STRATA,#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.rule = "omit",#
      res.dir = "results-cca",#
      appnd.txt.to.filename = "_cca_wopc"#
    )#
  }) }, .progress = TRUE)#
#SUPP.LIST.RES <- construct_meta_input_from_saved_results("results-cca", OUTCOME.VEC0[73:79], FOCAL_PREDICTOR, appnd.txt = "_cca_wopc")#
meta.input <- SUPP.LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
SUPP.META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Excluded -- Complete Case Analysis"#
)#
readr::write_rds(#
  SUPP.META.RES,#
  file = here::here(out.dir, "results-cca", "0_meta_analyzed_results_cca_wopc.rds"),#
  compress = "gz"#
)#
remove(meta.input, SUPP.LIST.RES, SUPP.META.RES)#
#
# Analysis set 2: Run with principal components#
SUPP.LIST.RES <- map(OUTCOME.VEC0[73:79], \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      direct.subset = expr(CASE_OBSERVED_Y2 == 1),#
      wgt = SAMP.ATTR.WGT,#
      psu = PSU,#
      strata = STRATA,#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.cutoff = 7,#
      pc.rule = "constant",#
      res.dir = "results-cca",#
      appnd.txt.to.filename = "_cca_wpc"#
    )#
  }) }, .progress = TRUE)#
SUPP.LIST.RES <- construct_meta_input_from_saved_results(res.dir="results-cca", outcomes=OUTCOME.VEC0[73:79], predictors=FOCAL_PREDICTOR, appnd.txt = "_cca_wpc")#
meta.input <- SUPP.LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
SUPP.META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Included -- Complete Case Analysis"#
)#
readr::write_rds(#
  SUPP.META.RES,#
  file = here::here(out.dir, "results-cca", "0_meta_analyzed_results_cca_wpc.rds"),#
  compress = "gz"#
)#
remove(meta.input, SUPP.LIST.RES, SUPP.META.RES)#
#
# ================================================================================================ ##
# ================================================================================================ ##
# Re-run primary analysis but get UNSTANDARDIZED estimated#
#
# Model 1: Run without principal components#
LIST.RES <- map(OUTCOME.VEC0[73:79], \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      wgt = ANNUAL_WEIGHT_R2, # wgt = as.name("ANNUAL_WEIGHT_R2")#
      psu = PSU, #psu = as.name("PSU")#
      strata = STRATA, # strata = as.name("STRATA")#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = FALSE,#
      pc.rule = "omit",#
      res.dir = "results-unstd",#
      appnd.txt.to.filename = "_unstd_wopc"#
    )#
  }) }, .progress = TRUE)#
#LIST.RES <- construct_meta_input_from_saved_results("results-unstd", OUTCOME.VEC0[73:79], FOCAL_PREDICTOR, appnd.txt = "_unstd_wopc")#
meta.input <- LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
#
META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Excluded -- Unstandardized Results"#
)#
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-unstd", "0_meta_analyzed_results_unstd_wopc.rds"),#
  compress = "gz"#
)#
remove(LIST.RES, meta.input, META.RES)#
#
# Model 2: Run with principal components#
LIST.RES <- map(OUTCOME.VEC0[73:79], \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data = df.imp.long,#
      wgt = ANNUAL_WEIGHT_R2,#
      psu = PSU,#
      strata = STRATA,#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = FALSE,#
      pc.cutoff = 7,#
      pc.rule = "constant",#
      res.dir = "results-unstd",#
      appnd.txt.to.filename = "_unstd_wpc"#
    )#
  }) }, .progress = TRUE)#
#
#LIST.RES <- construct_meta_input_from_saved_results("results-unstd", OUTCOME.VEC0[73:79], FOCAL_PREDICTOR, appnd.txt = "_unstd_wpc")#
meta.input <- LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
#
META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Included -- Unstandardized Results"#
)#
#
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-unstd","0_meta_analyzed_results_unstd_wpc.rds"),#
  compress = "gz"#
)#
remove(meta.input, LIST.RES, META.RES)
LIST.RES <- map(OUTCOME.VEC0[73:79], \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      wgt = ANNUAL_WEIGHT_R2,#
      psu = PSU,#
      strata = STRATA,#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = FALSE,#
      pc.cutoff = 7,#
      pc.rule = "constant",#
      res.dir = "results-unstd",#
      appnd.txt.to.filename = "_unstd_wpc"#
    )#
  }) }, .progress = TRUE)#
#
LIST.RES <- construct_meta_input_from_saved_results("results-unstd", OUTCOME.VEC0[73:79], FOCAL_PREDICTOR, appnd.txt = "_unstd_wpc")#
meta.input <- LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
#
META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Included -- Unstandardized Results"#
)#
#
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-unstd","0_meta_analyzed_results_unstd_wpc.rds"),#
  compress = "gz"#
)
gfs_generate_supplemental_docs(#
  df.raw = df.raw,#
  dir.primary="results-primary",#
  dir.supp="results-cca",#
  dir.unstd = "results-unstd",#
  dir.attr.models = "results-attr",#
  focal.predictor = FOCAL_PREDICTOR,#
  focal.better.name =  FOCAL_PREDICTOR_BETTER_NAME,#
  focal.predictor.reference.value = FOCAL_PREDICTOR_REFERENCE_VALUE,#
  res.dir = "results",#
  wgt = WGT0,#
  wgt1 = ANNUAL_WEIGHT_R2,#
  wgt2 = AVG.SAMP.ATTR.WGT,#
  psu = PSU,#
  strata = STRATA,#
  what = "S1",#
  outcome.vec = OUTCOME.VEC0[73:79]#
)
append_attrition_weights_to_df
RECODE.DEFAULTS <- list(#
  FOCAL_PREDICTOR = FOCAL_PREDICTOR,#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC = c(#
    get_variable_codes("GENDER.RACE", appnd=""),#
    get_variable_codes("DEMOGRAPHIC.VARS", appnd="_Y1"),#
    get_variable_codes("RETROSPECTIVE.VARS", appnd="_Y1")#
  ),#
  VARIABLES.VEC = c(get_variable_codes("VARS.Y1"), get_variable_codes("VARS.Y2")),#
  FORCE_BINARY = FORCE_BINARY,#
  FORCE_CONTINUOUS = FORCE_CONTINUOUS,#
  VALUES_DEFINING_UPPER_CATEGORY = VALUES_DEFINING_UPPER_CATEGORY,#
  VALUES_DEFINING_LOWER_CATEGORY = VALUES_DEFINING_LOWER_CATEGORY,#
  USE_DEFAULT = !(FORCE_BINARY | FORCE_CONTINUOUS)#
)#
#
# needed results#
df.raw <- gfs_get_labelled_raw_data(#
  here::here(data.dir, dataset.name),#
  list.composites = get_variable_codes('LIST.COMPOSITES'),#
  add.whitespace = TRUE#
)#
df.raw <- append_attrition_weights_to_df(data=df.raw)
gfs_generate_supplemental_docs(#
  df.raw = df.raw,#
  dir.primary="results-primary",#
  dir.supp="results-cca",#
  dir.unstd = "results-unstd",#
  dir.attr.models = "results-attr",#
  focal.predictor = FOCAL_PREDICTOR,#
  focal.better.name =  FOCAL_PREDICTOR_BETTER_NAME,#
  focal.predictor.reference.value = FOCAL_PREDICTOR_REFERENCE_VALUE,#
  res.dir = "results",#
  wgt = WGT0,#
  wgt1 = ANNUAL_WEIGHT_R2,#
  wgt2 = AVG.SAMP.ATTR.WGT,#
  psu = PSU,#
  strata = STRATA,#
  what = "S1",#
  outcome.vec = OUTCOME.VEC0[73:79]#
)
devtools::load_all()
gfs_generate_supplemental_docs(#
  df.raw = df.raw,#
  dir.primary="results-primary",#
  dir.supp="results-cca",#
  dir.unstd = "results-unstd",#
  dir.attr.models = "results-attr",#
  focal.predictor = FOCAL_PREDICTOR,#
  focal.better.name =  FOCAL_PREDICTOR_BETTER_NAME,#
  focal.predictor.reference.value = FOCAL_PREDICTOR_REFERENCE_VALUE,#
  res.dir = "results",#
  wgt = WGT0,#
  wgt1 = ANNUAL_WEIGHT_R2,#
  wgt2 = AVG.SAMP.ATTR.WGT,#
  psu = PSU,#
  strata = STRATA,#
  what = "S1",#
  outcome.vec = OUTCOME.VEC0[73:79]#
)
recode_raw_data <- function(#
    df.raw = NULL,#
    list.default = NULL,#
    list.composites = NULL,#
    list.manual = NULL,#
    wave = 2,#
    method.income = "quintiles.top.random",#
    wgt = "ANNUAL_WEIGHT_R2", strata = "STRATA", psu = "PSU",#
    ...) {#
  if (is.null(list.default)) {#
    stop("'list.default' was not supplied. Check input for recode_imputed data.")#
  }#
  if (!(is.null(list.manual))) {#
    # TODO#
    # add functionality to over-write default provided in list.default(.)#
  }#
  drop_created_vars <- c("AGE_GRP_Y1", "AGE_GRP_Y2", "RACE", "RACE_PLURALITY_Y1", "INCOME_QUINTILE_Y1", "INCOME_QUINTILE_Y2")#
  ## ============================================================================================ ###
  ## ====== Initial Setup ======================================================================= ###
  # extract imputed data and coerce into "long format"#
#
  #df.imp.long <- df.imp %>%#
  #  mutate(imp.complete = map(imp.res, ~ complete(., action = "long"))) %>%#
  #  select(COUNTRY, imp.complete) %>%#
  #  unnest(imp.complete)#
#
  df.imp.long <- df.raw %>%#
    select(!any_of(drop_created_vars)) %>%#
    mutate(#
      across(where(is.factor), \(x){#
      	if(str_detect(cur_column(), "COUNTRY", negate=TRUE)){#
        	x <- sub("\\..*", "", x)#
        	x = case_when(x == "(Missing)" ~ NA, .default = x) |>#
          		as.numeric()#
        }#
        if(str_detect(cur_column(), "BORN_COUNTRY")){#
        	x <- sub("\\..*", "", x)#
        	x = case_when(x == "(Missing)" ~ NA, .default = x) |>#
          		as.numeric()#
        }#
        x#
      })#
    )#
  #options(warn=2)#
  #for(i in 1:ncol(df.imp.long)){#
  #x = df.imp.long[[i]]#
  #if(is.factor(x) & str_detect(colnames(df.imp.long)[i],"COUNTRY", negate=TRUE)){#
  # x <- sub("\\..*", "", x)#
  # x = case_when(x == "(Missing)" ~ NA, .default = x) |>#
  #   as.numeric()#
  #}#
  #}#
  ## ============================================================================================ ###
  ## ====== WAVE SPECIFIC CODE ================================================================== ###
  ## TO-DO: develop a generalized approach...#
  ## Wave 1#
  if(wave == 1 | wave == "W1" | wave == "w1" | wave == "Y1"){#
    df.imp.long <- df.imp.long %>%#
      dummy_cols(#
        select_columns = c(#
          "SVCS_MOTHER",#
          "SVCS_FATHER",#
          "MOTHER_RELATN",#
          "MOTHER_LOVED",#
          "FATHER_RELATN",#
          "FATHER_LOVED",#
          "MARITAL_STATUS"#
        ),#
        ignore_na = T#
      ) %>%#
      mutate(#
        COV_AGE_GRP = recode_labels(AGE, "AGE_GRP"),#
        COV_AGE_GRP = recode_to_type(COV_AGE_GRP, "AGE_GRP"),#
        across(any_of(c(list.default[["DEMOGRAPHICS.CHILDHOOD.PRED.VEC"]])), \(x){#
          x <- recode_labels(x, cur_column(), include.value = FALSE)#
          x <- case_when(x == "(Missing)" ~ NA, .default = x) # needed for Abused and other 100% missing variable sin some countries#
          #x <- str_sub(x, 4, -1) # removed the numbers#
          #x <- str_replace_all(x, "\\n", "")#
          #x <- str_trim(x)#
          x <- recode_to_type(x, cur_column())#
          x#
        }, .names = "COV_{.col}"),#
        COV_MOTHER_RELATN = case_when(MOTHER_RELATN_1 == 1 | MOTHER_RELATN_2 == 1 ~ "Very/somewhat good", .default = "Very/somewhat bad"),#
        COV_MOTHER_RELATN = factor(COV_MOTHER_RELATN),#
        COV_FATHER_RELATN = case_when(FATHER_RELATN_1 == 1 | FATHER_RELATN_2 == 1 ~ "Very/somewhat good", .default = "Very/somewhat bad"),#
        COV_FATHER_RELATN = factor(COV_FATHER_RELATN),#
        COV_MOTHER_NA = case_when(SVCS_MOTHER_97 == 1 | MOTHER_RELATN_97 == 1 | MOTHER_LOVED_97 == 1 ~ 1, .default = 0),#
        COV_FATHER_NA = case_when(SVCS_FATHER_97 == 1 | FATHER_RELATN_97 == 1 | FATHER_LOVED_97 == 1 ~ 1, .default = 0),#
#
        # enforce reference group#
        COV_AGE_GRP = relevel(COV_AGE_GRP, ref = levels(COV_AGE_GRP)[str_detect(levels(COV_AGE_GRP),"18-24")]),#
        COV_GENDER = relevel(COV_GENDER, ref = "Male"),#
        COV_EDUCATION_3 = relevel(COV_EDUCATION_3, ref = "9-15"),#
        COV_EMPLOYMENT = relevel(COV_EMPLOYMENT, ref = "Employed for an employer"),#
        COV_MARITAL_STATUS = relevel(COV_MARITAL_STATUS, ref = "Single/Never been married"),#
        COV_ATTEND_SVCS = relevel(COV_ATTEND_SVCS, ref = "Never"),#
        COV_BORN_COUNTRY = relevel(COV_BORN_COUNTRY, ref = "Born in this country"),#
        COV_PARENTS_12YRS = relevel(COV_PARENTS_12YRS, ref = "Yes, married"),#
        COV_MOTHER_RELATN = relevel(COV_MOTHER_RELATN, ref = "Very/somewhat bad"),#
        COV_FATHER_RELATN = relevel(COV_FATHER_RELATN, ref = "Very/somewhat bad"),#
        COV_SVCS_12YRS = relevel(COV_SVCS_12YRS, ref = "Never"),#
        COV_OUTSIDER = relevel(COV_OUTSIDER, ref = "No"),#
        COV_ABUSED = ifelse(COUNTRY == "Israel", COV_ABUSED, relevel(COV_ABUSED, ref = "No")),#
        COV_HEALTH_GROWUP = relevel(COV_HEALTH_GROWUP, ref = "Good"),#
        COV_INCOME_12YRS = relevel(COV_INCOME_12YRS, ref = "Got by"),#
#
        # Other basic setup to make things easier later...#
        RACE = recode_labels(SELFID1, "SELFID1", include.value = FALSE),#
        MARITAL_STATUS_EVER_MARRIED = case_when(MARITAL_STATUS %in% c(2:5) ~ 1, .default = 0),#
        MARITAL_STATUS_DIVORCED = case_when(MARITAL_STATUS == 4 ~ 1, .default = 0),#
        CIGARETTES_BINARY = case_when(CIGARETTES > 0 ~ 1, .default = 0),#
        COUNTRY2 = recode_labels(COUNTRY2, "COUNTRY", include.value = FALSE)#
      )#
  }#
  ## Wave 2#
  if(is.null(wave) | wave == 2 | wave == "W2" | wave == "w2" | wave == "Y2"){#
    df.imp.long <- df.imp.long %>%#
      dummy_cols(#
        select_columns = c(#
          "SVCS_MOTHER_Y1",#
          "SVCS_FATHER_Y1",#
          "MOTHER_RELATN_Y1",#
          "MOTHER_LOVED_Y1",#
          "FATHER_RELATN_Y1",#
          "FATHER_LOVED_Y1",#
          "MARITAL_STATUS_Y1",#
          "MARITAL_STATUS_Y2"#
        ),#
        ignore_na = T#
      ) %>%#
      mutate(#
        COV_AGE_GRP_Y1 = recode_labels(AGE_Y1, "AGE_GRP_Y1"),#
        COV_AGE_GRP_Y1 = recode_to_type(COV_AGE_GRP_Y1, "AGE_GRP_Y1"),#
        across(any_of(c("URBAN_RURAL_Y1", list.default[["DEMOGRAPHICS.CHILDHOOD.PRED.VEC"]])), \(x){#
          x <- recode_labels(x, cur_column(), include.value = FALSE)#
          x <- case_when(x == "(Missing)" ~ NA, .default = x) # needed for Abused and other 100% missing variable sin some countries#
          #x <- str_sub(x, 4, -1) # removed the numbers#
          #x <- str_replace_all(x, "\\n", "")#
          #x <- str_trim(x)#
          x <- recode_to_type(x, cur_column())#
          x#
        }, .names = "COV_{.col}"),#
        COV_MOTHER_RELATN_Y1 = case_when(MOTHER_RELATN_Y1_1 == 1 | MOTHER_RELATN_Y1_2 == 1 ~ "Very/somewhat good", .default = "Very/somewhat bad"),#
        COV_MOTHER_RELATN_Y1 = factor(COV_MOTHER_RELATN_Y1),#
        COV_FATHER_RELATN_Y1 = case_when(FATHER_RELATN_Y1_1 == 1 | FATHER_RELATN_Y1_2 == 1 ~ "Very/somewhat good", .default = "Very/somewhat bad"),#
        COV_FATHER_RELATN_Y1 = factor(COV_FATHER_RELATN_Y1),#
        COV_MOTHER_NA = case_when(SVCS_MOTHER_Y1_97 == 1 | MOTHER_RELATN_Y1_97 == 1 | MOTHER_LOVED_Y1_97 == 1 ~ 1, .default = 0),#
        COV_FATHER_NA = case_when(SVCS_FATHER_Y1_97 == 1 | FATHER_RELATN_Y1_97 == 1 | FATHER_LOVED_Y1_97 == 1 ~ 1, .default = 0),#
#
        # enforce reference group#
        COV_AGE_GRP_Y1 = relevel(COV_AGE_GRP_Y1, ref = levels(COV_AGE_GRP_Y1)[str_detect(levels(COV_AGE_GRP_Y1),"18-24")]),#
        COV_GENDER = relevel(COV_GENDER, ref = "Male"),#
        COV_EDUCATION_3_Y1 = relevel(COV_EDUCATION_3_Y1, ref = "9-15"),#
        COV_EMPLOYMENT_Y1 = relevel(COV_EMPLOYMENT_Y1, ref = "Employed for an employer"),#
        COV_MARITAL_STATUS_Y1 = relevel(COV_MARITAL_STATUS_Y1, ref = "Single/Never been married"),#
        COV_ATTEND_SVCS_Y1 = relevel(COV_ATTEND_SVCS_Y1, ref = "Never"),#
        COV_BORN_COUNTRY_Y1 = relevel(COV_BORN_COUNTRY_Y1, ref = "Born in this country"),#
        COV_PARENTS_12YRS_Y1 = relevel(COV_PARENTS_12YRS_Y1, ref = "Yes, married"),#
        COV_MOTHER_RELATN_Y1 = relevel(COV_MOTHER_RELATN_Y1, ref = "Very/somewhat bad"),#
        COV_FATHER_RELATN_Y1 = relevel(COV_FATHER_RELATN_Y1, ref = "Very/somewhat bad"),#
        COV_SVCS_12YRS_Y1 = relevel(COV_SVCS_12YRS_Y1, ref = "Never"),#
        COV_OUTSIDER_Y1 = relevel(COV_OUTSIDER_Y1, ref = "No"),#
        COV_ABUSED_Y1 = ifelse(COUNTRY == "Israel", COV_ABUSED_Y1, relevel(COV_ABUSED_Y1, ref = "No")),#
        COV_HEALTH_GROWUP_Y1 = relevel(COV_HEALTH_GROWUP_Y1, ref = "Good"),#
        COV_INCOME_12YRS_Y1 = relevel(COV_INCOME_12YRS_Y1, ref = "Got by"),#
#
        # Other basic setup to make things easier later...#
        MODE_RECRUIT = recode_labels( MODE_RECRUIT, "MODE_RECRUIT", include.value = FALSE),#
        MODE_RECRUIT = recode_to_type(MODE_RECRUIT, "MODE_RECRUIT"),#
        RACE = COV_SELFID1,#
        MARITAL_STATUS_EVER_MARRIED_Y1 = case_when(MARITAL_STATUS_Y1 %in% c(2:5) ~ 1, .default = 0),#
        MARITAL_STATUS_EVER_MARRIED_Y2 = case_when(MARITAL_STATUS_Y2 %in% c(2:5) ~ 1, .default = 0),#
        MARITAL_STATUS_DIVORCED_Y1 = case_when(MARITAL_STATUS_Y1 %in% c(4) ~ 1, .default = 0),#
        MARITAL_STATUS_DIVORCED_Y2 = case_when(MARITAL_STATUS_Y2 %in% c(4) ~ 1, .default = 0),#
        CIGARETTES_BINARY_Y1 = case_when(CIGARETTES_Y1 > 0 ~ 1, .default = 0),#
        CIGARETTES_BINARY_Y2 = case_when(CIGARETTES_Y2 > 0 ~ 1, .default = 0),#
        COUNTRY2 = COUNTRY #recode_labels(COUNTRY2, "COUNTRY_Y1", include.value = FALSE)#
      )#
  }#
  ## ============================================================================================ ###
  ## ====== RACE PLURALITY INDICATOR ============================================================ ###
  {#
  df.imp.long <- df.imp.long %>%#
    mutate(#
      COV_RACE_PLURALITY = case_when(#
        COUNTRY2 == "Argentina" & str_detect(RACE, "White") ~ 0,#
        COUNTRY2 == "Argentina" & str_detect(RACE, "White", negate = TRUE) ~ 1,#
        COUNTRY2 == "Australia" & str_detect(RACE, "Australian") ~ 0,#
        COUNTRY2 == "Australia" & str_detect(RACE, "Australian", negate = TRUE) ~ 1,#
        COUNTRY2 == "Brazil" & str_detect(RACE, "Branca") ~ 0,#
        COUNTRY2 == "Brazil" & str_detect(RACE, "Branca", negate = TRUE) ~ 1,#
        COUNTRY2 == "Egypt" & str_detect(RACE, "Arab") ~ 0,#
        COUNTRY2 == "Egypt" & str_detect(RACE, "Arab", negate = TRUE) ~ 1,#
        COUNTRY2 == "Germany" ~ NA,#
        COUNTRY2 == "Hong Kong" & str_detect(RACE, "Chinese (Cantonese)") ~ 0,#
        COUNTRY2 == "Hong Kong" & str_detect(RACE, "Chinese (Cantonese)", negate = TRUE) ~ 1,#
        COUNTRY2 == "India" & str_detect(RACE, "Other backward caste") ~ 0,#
        COUNTRY2 == "India" & str_detect(RACE, "Other backward caste", negate = TRUE) ~ 1,#
        COUNTRY2 == "Indonesia" & str_detect(RACE, "Jawa") ~ 0,#
        COUNTRY2 == "Indonesia" & str_detect(RACE, "Jawa", negate = TRUE) ~ 1,#
        COUNTRY2 == "Israel" & str_detect(RACE, "Jewish") ~ 0,#
        COUNTRY2 == "Israel" & str_detect(RACE, "Jewish", negate = TRUE) ~ 1,#
        COUNTRY2 == "Japan" ~ NA,#
        COUNTRY2 == "Kenya" & str_detect(RACE, "Kikuyu") ~ 0,#
        COUNTRY2 == "Kenya" & str_detect(RACE, "Kikuyu", negate = TRUE) ~ 1,#
        COUNTRY2 == "Mexico" & str_detect(RACE, "Mestizo") ~ 0,#
        COUNTRY2 == "Mexico" & str_detect(RACE, "Mestizo", negate = TRUE) ~ 1,#
        COUNTRY2 == "Nigeria" & str_detect(RACE, "Hausa") ~ 0,#
        COUNTRY2 == "Nigeria" & str_detect(RACE, "Hausa", negate = TRUE) ~ 1,#
        COUNTRY2 == "Philippines" & str_detect(RACE, "Tagalog") ~ 0,#
        COUNTRY2 == "Philippines" & str_detect(RACE, "Tagalog", negate = TRUE) ~ 1,#
        COUNTRY2 == "Poland" & str_detect(RACE, "Polish") ~ 0,#
        COUNTRY2 == "Poland" & str_detect(RACE, "Polish", negate = TRUE) ~ 1,#
        COUNTRY2 == "South Africa" & str_detect(RACE, "Black") ~ 0,#
        COUNTRY2 == "South Africa" & str_detect(RACE, "Black", negate = TRUE) ~ 1,#
        COUNTRY2 == "Spain" ~ NA,#
        COUNTRY2 == "Sweden" ~ NA,#
        COUNTRY2 == "Tanzania" & str_detect(RACE, "African") ~ 0,#
        COUNTRY2 == "Tanzania" & str_detect(RACE, "African", negate = TRUE) ~ 1,#
        COUNTRY2 == "Turkiye" & str_detect(RACE, "Turkish") ~ 0,#
        COUNTRY2 == "Turkiye" & str_detect(RACE, "Turkish", negate = TRUE) ~ 1,#
        COUNTRY2 == "United Kingdom" & str_detect(RACE, "White") ~ 0,#
        COUNTRY2 == "United Kingdom" & str_detect(RACE, "White", negate = TRUE) ~ 1,#
        COUNTRY2 == "United States" & str_detect(RACE, "White") ~ 0,#
        COUNTRY2 == "United States" & str_detect(RACE, "White", negate = TRUE) ~ 1,#
        .default = 0#
      )#
    )#
  }#
  ## ============================================================================================ ###
  ## ====== RECODING RELIGION DATA ============================================================== ###
  {#
    # Next, recode religion.#
    # 	This must be done BY country.#
    # function to recode religion#
    # recodes religion variable to either use "No religion" as reference group if that grp contains at least 3% of the total sample.#
    # 	else, recodes such that the most prominant religion is the reference grp.#
    # 	combines all religious grps with less than 3% of the smaple into a single combined grp.#
    recode_REL <- function(data, var, wgt) {#
      # re-level REL2 based on most prominent religion as reference#
      rel.prominence <- data %>%#
        group_by((!!as.name(var)), .drop = FALSE) %>%#
        summarise(N = sum(.data[[wgt]])) %>%#
        ungroup() %>%#
        mutate(N = N / sum(N))#
      rel.prominence.tab <- rel.prominence[, 2, drop = T]#
      names(rel.prominence.tab) <- rel.prominence[, 1, drop = T]#
      rel.lvl <- levels(data[[var]])#
      rel.ag.prom <- rel.prominence.tab[rel.lvl == "No religion/Atheist/Agnostic"]#
        if (length(rel.ag.prom) == 0) {#
            rel.ag.prom <- 0 }#
      if (rel.ag.prom > 0.03) {#
        rel.mp <- "No religion/Atheist/Agnostic"#
      } else {#
        rel.mp <- rel.lvl[which.max(rel.prominence.tab)]#
      }#
      data[[var]] <- fct_lump_prop(data[[var]], 0.03, other_level = "Combined")#
      data[[var]] <- fct_infreq(data[[var]])#
      data[[var]] <- relevel(data[[var]], ref = rel.mp)#
      data#
    }#
#
    df.imp.long <- df.imp.long %>%#
      group_by(COUNTRY) %>%#
      nest() %>%#
      mutate(#
        data = map(data, \(x){#
          recode_REL(x, paste0("COV_REL1", ifelse(wave == 2, "_Y1", "")), wgt = wgt)#
        }),#
        data = map(data, \(x){#
          recode_REL(x, paste0("COV_REL2", ifelse(wave == 2, "_Y1", "")), wgt = wgt)#
        })#
      ) %>%#
      unnest(c(data))#
  }#
  ## ============================================================================================ ###
  ## ====== RECODING INCOME DATA ================================================================ ###
  {#
    if(wave == 1 | wave == "W1"){#
      income.quintiles <- df.imp.long  %>%#
        select(#
          dplyr::all_of(c(".imp", "ID", "COUNTRY", "INCOME", wgt, strata, psu))#
        ) %>%#
        mutate(#
          across(INCOME,\(x){#
          	x <- sub("\\..*", "", x)#
        	x = case_when(x == "(Missing)" ~ NA, .default = x) |>#
          		as.numeric()#
            case_when(#
              x < 0 ~ NA,#
              x > 9900 ~ NA,#
              x == 9900 ~ 0,#
              .default=x#
            )#
          })#
        ) %>%#
        group_by(.imp, COUNTRY) %>%#
        nest() %>%#
        mutate(#
          svy.data = map(data, \(x){#
            svydesign(data=x, ids=~(!!as.name(psu)), strata=~(!!as.name(strata)), weights=~(!!as.name(wgt)))#
          }),#
          quintiles = map(svy.data, \(x){#
            svyquantile(~INCOME, design=x, quantiles=c(0.20,0.40,0.60,0.80), na.rm = TRUE)#
          })#
        ) %>%#
        select(.imp, COUNTRY, quintiles_w1)#
#
      df.imp.long <- df.imp.long %>%#
        group_by(.imp, COUNTRY2) %>%#
        nest() %>%#
        mutate(#
          data = map(data, \(x){#
            cur.country = x$COUNTRY[1]#
            cur.imp = x$.imp[1]#
#
            tmp.quintiles <- income.quintiles %>%#
              filter(COUNTRY == cur.country, .imp == cur.imp)#
#
            tmp.quintiles.w1 <- tmp.quintiles$quintiles[[1]][[1]]#
#
            x <- x %>%#
              mutate(#
                INCOME_QUINTILE = case_when(#
                  INCOME >= tmp.quintiles.w1["0.8",1] ~ 5,#
                  INCOME >= tmp.quintiles.w1["0.6",1] & INCOME < tmp.quintiles.w1["0.8",1] ~ 4,#
                  INCOME >= tmp.quintiles.w1["0.4",1] & INCOME < tmp.quintiles.w1["0.6",1] ~ 3,#
                  INCOME >= tmp.quintiles.w1["0.2",1] & INCOME < tmp.quintiles.w1["0.4",1] ~ 2,#
                  INCOME < tmp.quintiles.w1["0.2",1] ~ 1#
                )#
              )#
            if(method.income=="quintiles.top.fixed"){#
              x <- x %>%#
                mutate(#
                  across(contains("INCOME_QUINTILE"), \(x){#
                    y <- case_when(#
                      x == 5 ~ 1,#
                      x %in% 1:4 ~ 0#
                    )#
                    y#
                  })#
                )#
            }#
            if(method.income == "quintiles.top.random"){#
              set.seed(314150)#
              x <- x %>%#
                mutate(#
                  across(contains("INCOME_QUINTILE"), \(x){#
                    y <- case_when(#
                      x == 5 ~ 1,#
                      x %in% 1:4 ~ 0#
                    )#
                    y.mean = mean(y)#
                    if(y.mean > 0.20){#
                      n0 <- length(y)#
                      nq <- round(y.mean*n0,0) - round(0.2*n0,0) # number of cases to randomly fix to 0#
                      y[y==1][sample(1:(length(y[y==1])), nq, replace = FALSE)] <- 0#
                    }#
                    if(y.mean < 0.20){#
                      n0 <- length(y)#
                      nq <- round(0.2*n0,0) - round(y.mean*n0,0) # number of cases to randomly fix to 1 from those who are in the fourth quintile#
                      x[x==4][sample(1:(length(x[x==4])), nq, replace = FALSE)] <- 5#
                      y <- case_when(#
                        x == 5 ~ 1,#
                        x %in% 1:4 ~ 0#
                      )#
                    }#
                    y#
                  })#
                )#
            }#
            x#
          }),#
          data = map(data, \(x){#
            x %>%#
              mutate(#
                INCOME = recode_labels(INCOME, "INCOME"),#
                INCOME_QUINTILE = recode_labels(INCOME_QUINTILE, "INCOME_QUINTILE"),#
                INCOME_QUINTILE = factor(INCOME_QUINTILE),#
                INCOME_QUINTILE = recode_to_numeric(INCOME_QUINTILE, "INCOME_QUINTILE")#
              )#
          })#
        ) %>%#
        unnest(c(data)) %>%#
        ungroup()#
    }#
    if(is.null(wave) | wave == 2 | wave == "W2"){#
#
      income.quintiles <-  df.imp.long  %>%#
        select(#
          dplyr::all_of(c( "ID", "COUNTRY", "INCOME_Y1", "INCOME_Y2", wgt, strata, psu))#
        ) %>%#
        mutate(#
          across(contains("INCOME"),\(x){#
          	x <- sub("\\..*", "", x)#
        	x = case_when(x == "(Missing)" ~ NA, .default = x) |>#
          		as.numeric()#
            case_when(#
              x < 0 ~ NA,#
              x > 9900 ~ NA,#
              x == 9900 ~ 0,#
              .default=x#
            )#
          })#
        ) %>%#
        group_by( COUNTRY) %>%#
        nest() %>%#
        mutate(#
          svy.data = map(data, \(x){#
            svydesign(data=x, ids=~(!!as.name(psu)), strata=~(!!as.name(strata)), weights=~(!!as.name(wgt)))#
          }),#
          quintiles_w1 = map(svy.data, \(x){#
            svyquantile(~INCOME_Y1, design=x, quantiles=c(0.20,0.40,0.60,0.80), na.rm = TRUE)#
          }),#
          quintiles_w2 = map(svy.data, \(x){#
            svyquantile(~INCOME_Y2, design=x, quantiles=c(0.20,0.40,0.60,0.80), na.rm = TRUE)#
          }),#
        ) %>%#
        select(COUNTRY, quintiles_w1, quintiles_w2)#
#
       df.imp.long <-  df.imp.long %>%#
        group_by(COUNTRY2) %>%#
        nest() %>%#
        mutate(#
          data = map(data, \(x){#
            cur.country = x$COUNTRY[1]#
#
            tmp.quintiles <- income.quintiles %>%#
              filter(COUNTRY == cur.country)#
#
            tmp.quintiles.w1 <- tmp.quintiles$quintiles_w1[[1]][[1]]#
            tmp.quintiles.w2 <- tmp.quintiles$quintiles_w2[[1]][[1]]#
#
            x <- x %>%#
              mutate(#
                INCOME_QUINTILE_Y1 = case_when(#
                  INCOME_Y1 >= tmp.quintiles.w1["0.8",1] ~ 5,#
                  INCOME_Y1 >= tmp.quintiles.w1["0.6",1] & INCOME_Y1 < tmp.quintiles.w1["0.8",1] ~ 4,#
                  INCOME_Y1 >= tmp.quintiles.w1["0.4",1] & INCOME_Y1 < tmp.quintiles.w1["0.6",1] ~ 3,#
                  INCOME_Y1 >= tmp.quintiles.w1["0.2",1] & INCOME_Y1 < tmp.quintiles.w1["0.4",1] ~ 2,#
                  INCOME_Y1 < tmp.quintiles.w1["0.2",1] ~ 1#
                ),#
                INCOME_QUINTILE_Y2 = case_when(#
                  INCOME_Y2 >= tmp.quintiles.w2["0.8",1] ~ 5,#
                  INCOME_Y2 >= tmp.quintiles.w2["0.6",1] & INCOME_Y2 < tmp.quintiles.w2["0.8",1] ~ 4,#
                  INCOME_Y2 >= tmp.quintiles.w2["0.4",1] & INCOME_Y2 < tmp.quintiles.w2["0.6",1] ~ 3,#
                  INCOME_Y2 >= tmp.quintiles.w2["0.2",1] & INCOME_Y2 < tmp.quintiles.w2["0.4",1] ~ 2,#
                  INCOME_Y2 < tmp.quintiles.w2["0.2",1] ~ 1#
                )#
              )#
            if(method.income=="quintiles.top.fixed"){#
              x <- x %>%#
                mutate(#
                  across(contains("INCOME_QUINTILE"), \(x){#
                    y <- case_when(#
                      x == 5 ~ 1,#
                      x %in% 1:4 ~ 0#
                    )#
                    y#
                  })#
                )#
            }#
            if(method.income == "quintiles.top.random"){#
              set.seed(314150)#
              x <- x %>%#
                mutate(#
                  across(contains("INCOME_QUINTILE"), \(x){#
                    y <- case_when(#
                      x == 5 ~ 1,#
                      x %in% 1:4 ~ 0#
                    )#
                    y.mean = mean(y, na.rm=TRUE)#
                    if(y.mean > 0.20){#
                      n0 <- length(y[!is.na(y)])#
                      nq <- round(y.mean*n0,0) - round(0.2*n0,0) # number of cases to randomly fix to 0#
                      y[y==1][sample(1:(length(y[y==1])), nq, replace = TRUE)] <- 0#
                    }#
                    if(y.mean < 0.20){#
                      n0 <- length(y)#
                      nq <- round(0.2*n0,0) - round(y.mean*n0,0) # number of cases to randomly fix to 1 from those who are in the fourth quintile#
                      x[x==4][sample(1:(length(x[x==4])), nq, replace = TRUE)] <- 5#
                      y <- case_when(#
                        x == 5 ~ 1,#
                        x %in% 1:4 ~ 0#
                      )#
                    }#
                    y#
                  })#
                )#
            }#
            x#
          }),#
          data = map(data, \(x){#
            x %>%#
              mutate(#
                INCOME_Y1 = recode_labels(INCOME_Y1, "INCOME_Y1"),#
                INCOME_Y2 = recode_labels(INCOME_Y2, "INCOME_Y2"),#
                INCOME_QUINTILE_Y1 = recode_labels(INCOME_QUINTILE_Y1, "INCOME_QUINTILE"),#
                INCOME_QUINTILE_Y2 = recode_labels(INCOME_QUINTILE_Y2, "INCOME_QUINTILE"),#
                INCOME_QUINTILE_Y1 = factor(INCOME_QUINTILE_Y1),#
                INCOME_QUINTILE_Y2 = factor(INCOME_QUINTILE_Y2),#
                INCOME_QUINTILE_Y1 = recode_to_numeric(INCOME_QUINTILE_Y1, "INCOME_QUINTILE"),#
                INCOME_QUINTILE_Y2 = recode_to_numeric(INCOME_QUINTILE_Y2, "INCOME_QUINTILE")#
              )#
          })#
        ) %>%#
        unnest(c(data)) %>%#
        ungroup()#
    }#
  }#
  ## ============================================================================================ ###
  ## ====== CATEGORICAL LEVELS CHECK ============================================================ ###
  # Next, make sure all categorical items are recoded as binary#
  # 	Must do this last as a few composites are formed from the#
  # 	categorical Likert-type items#
  tmp.var <- list.default[["VARIABLES.VEC"]][1]#
  for (tmp.var in list.default[["VARIABLES.VEC"]]) {#
    # print(tmp.var)#
    x <- df.imp.long[, tmp.var, drop = TRUE]#
    if ((tmp.var %in% list.default[["FOCAL_PREDICTOR"]]) & !(all(list.default[["USE_DEFAULT"]]))) {#
      # if the focal variable is continous, essential ignore and moe to next#
      if (get_outcome_scale(tmp.var) == "cont") {#
        if (list.default[["FORCE_BINARY"]][tmp.var]) {#
          x <- case_when(#
            x %in% c(list.default[["VALUES_DEFINING_UPPER_CATEGORY"]][[tmp.var]]) ~ 1,#
            x %in% c(list.default[["VALUES_DEFINING_LOWER_CATEGORY"]][[tmp.var]]) ~ 0#
          )#
        } else {#
          x <- recode_to_type(x, tmp.var)#
          x <- reorder_levels(x, tmp.var)#
          x <- recode_to_numeric(x, tmp.var)#
        }#
      } else if (get_outcome_scale(tmp.var) %in% c("bin", "likert")) {#
      	  if (list.default[["FORCE_CONTINUOUS"]][tmp.var]) {#
      	  	x <- recode_to_type(x, tmp.var)#
      	  	x <- reorder_levels(x, tmp.var)#
      	  	if (get_outcome_scale(tmp.var) %in% c("bin", "likert")) {#
      	    	x <- as.numeric(x)#
      	  	} else {#
      	    	x <- recode_to_numeric(x, tmp.var)#
      	  	}#
      	  } else {#
      	    # if focal variable is binary/categorical, then collasp as user-specified#
      	    x <- case_when(#
      	      x %in% c(list.default[["VALUES_DEFINING_UPPER_CATEGORY"]][[tmp.var]]) ~ 1,#
      	      x %in% c(list.default[["VALUES_DEFINING_LOWER_CATEGORY"]][[tmp.var]]) ~ 0#
      	    )#
      	  }#
      }#
    } else {#
      if (str_detect(tmp.var, "COMPOSITE")) {#
        is.sum <- ifelse(#
          str_detect(tmp.var, "COMPOSITE_DEPRESSION") |#
            str_detect(tmp.var, "COMPOSITE_ANXIETY") |#
            str_detect(tmp.var, "COMPOSITE_DEP_ANX_COMBO"),#
          TRUE, FALSE#
        )#
        x <- recode_to_numeric(x, tmp.var, is.sum)#
      } else if (get_outcome_scale(tmp.var) == "cont") {#
        x <- recode_to_type(x, tmp.var)#
        x <- reorder_levels(x, tmp.var)#
        x <- recode_to_numeric(x, tmp.var)#
      } else {#
        x <- recode_to_numeric(x, tmp.var)#
      }#
    }#
    if (!is.null(x)) {#
      df.imp.long[, tmp.var] <- x#
    }#
  }#
  ## ============================================================================================ ###
  df.imp.long#
#
}#
df.raw.cca <- recode_raw_data(#
	df.raw, list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES,#
    wgt = "ANNUAL_WEIGHT_R2"#
   )
head(df.raw.cca)
country.vec <- unique(df.raw.cca$COUNTRY)
country.vec
country.vec <- sort(as.character(unique(df.raw.cca$COUNTRY)))
country.vec
OUTCOME.VEC0[73:79]
OUTCOME.VEC0[73:79]#
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER_Y1",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER_Y1",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)#
#
country.vec <- sort(as.character(unique(df.raw.cca$COUNTRY)))#
fit.res <- map(country.vec, \(x){#
  df.raw.cca %>%#
	filter(COUNTRY == x) %>%#
	lm(#
		reformulate(#
		response = OUTCOME.VEC0[73],#
		termlabels = DEMO.CHILDHOOD.PRED#
		)#
	)#
})
country.vec <- sort(as.character(unique(df.raw.cca$COUNTRY)))#
fit.res <- map(country.vec, \(x){#
	lm(#
	reformulate(#
		response = OUTCOME.VEC0[73],#
		termlabels = DEMO.CHILDHOOD.PRED#
		), data = df.raw.cca %>%#
	filter(COUNTRY == x) #
	)#
})
colnames(df.raw.cca)
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)
country.vec <- sort(as.character(unique(df.raw.cca$COUNTRY)))#
fit.res <- map(country.vec, \(x){#
	lm(#
	reformulate(#
		response = OUTCOME.VEC0[73],#
		termlabels = DEMO.CHILDHOOD.PRED#
		), data = df.raw.cca %>%#
	filter(COUNTRY == x) #
	)#
})
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)#
#
country.vec <- sort(as.character(unique(df.raw.cca$COUNTRY)))#
fit.res <- map(country.vec, \(x){#
	tmp.data <- data = df.raw.cca %>%#
	filter(COUNTRY == x) #
          keep.var <- rep(FALSE, length(DEMO.CHILDHOOD.PRED))#
          for(i in 1:length(keep.var)){#
            if(DEMO.CHILDHOOD.PRED[i] %in% colnames(tmp.data)){#
              keep.var[i] <- keep_variable(DEMO.CHILDHOOD.PRED[i], data = tmp.data)#
            }#
          }#
	lm(#
	reformulate(#
		response = OUTCOME.VEC0[73],#
		termlabels = DEMO.CHILDHOOD.PRED[keep.var]#
		), tmp.data#
	)#
})
country.vec <- sort(as.character(unique(df.raw.cca$COUNTRY)))#
fit.res <- map(country.vec, \(x){#
	tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x) #
          keep.var <- rep(FALSE, length(DEMO.CHILDHOOD.PRED))#
          for(i in 1:length(keep.var)){#
            if(DEMO.CHILDHOOD.PRED[i] %in% colnames(tmp.data)){#
              keep.var[i] <- keep_variable(DEMO.CHILDHOOD.PRED[i], data = tmp.data)#
            }#
          }#
	lm(#
	reformulate(#
		response = OUTCOME.VEC0[73],#
		termlabels = DEMO.CHILDHOOD.PRED[keep.var]#
		), tmp.data#
	)#
})
fit.res
x <- country.vec[1]
tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x) #
          keep.var <- rep(FALSE, length(DEMO.CHILDHOOD.PRED))#
          for(i in 1:length(keep.var)){#
            if(DEMO.CHILDHOOD.PRED[i] %in% colnames(tmp.data)){#
              keep.var[i] <- keep_variable(DEMO.CHILDHOOD.PRED[i], data = tmp.data)#
            }#
          }
fit <- lm(#
	reformulate(#
		response = OUTCOME.VEC0[73],#
		termlabels = DEMO.CHILDHOOD.PRED[keep.var]#
		), tmp.data#
	)
fit
names(fit)
se(fit)
FOCAL_PREDICTOR
fit <- lm(#
	reformulate(#
		response = OUTCOME.VEC0[73],#
		termlabels = c(DEMO.CHILDHOOD.PRED[keep.var], FOCAL_PREDICTOR)#
		), tmp.data#
	)
fit
tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x)#
	tmp.data$PRIMARY_OUTCOME <- scale(tmp.data[[OUTCOME.VEC0[73]]], na.rm=TRUE)
tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x)#
	tmp.data$PRIMARY_OUTCOME <- scale(tmp.data[[OUTCOME.VEC0[73]]])
tmp.data$PRIMARY_OUTCOME
head(tmp.data$PRIMARY_OUTCOME)
head(tmp.data)
colnames(tmp.data)
tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x)#
	tmp.data$PRIMARY_OUTCOME <- scale(tmp.data[[OUTCOME.VEC0[73]]])#
	tmp.data$FOCAL_PREDICTOR <- scale(tmp.data[[FOCAL_PREDICTOR]])#
          keep.var <- rep(FALSE, length(DEMO.CHILDHOOD.PRED))#
          for(i in 1:length(keep.var)){#
            if(DEMO.CHILDHOOD.PRED[i] %in% colnames(tmp.data)){#
              keep.var[i] <- keep_variable(DEMO.CHILDHOOD.PRED[i], data = tmp.data)#
            }#
          }#
	fit <- lm(#
	reformulate(#
		response = "PRIMARY_OUTCOME",#
		termlabels = c(DEMO.CHILDHOOD.PRED[keep.var], FOCAL_PREDICTOR)#
		), tmp.data#
	)
fit
names(fit)
fit$df.residual
c(fit$coefficients["FOCAL_PREDICTOR"], se(fit)["FOCAL_PREDICTOR"])
fit <- lm(#
	reformulate(#
		response = "PRIMARY_OUTCOME",#
		termlabels = c(DEMO.CHILDHOOD.PRED[keep.var], "FOCAL_PREDICTOR")#
		), tmp.data#
	)
fit$coefficients["FOCAL_PREDICTOR"]
c(fit$coefficients["FOCAL_PREDICTOR"], se(fit)["FOCAL_PREDICTOR"])
fit.res <- map(country.vec, \(x){#
	tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x)#
	tmp.data$PRIMARY_OUTCOME <- scale(tmp.data[[OUTCOME.VEC0[73]]])#
	tmp.data$FOCAL_PREDICTOR <- scale(tmp.data[[FOCAL_PREDICTOR]])#
          keep.var <- rep(FALSE, length(DEMO.CHILDHOOD.PRED))#
          for(i in 1:length(keep.var)){#
            if(DEMO.CHILDHOOD.PRED[i] %in% colnames(tmp.data)){#
              keep.var[i] <- keep_variable(DEMO.CHILDHOOD.PRED[i], data = tmp.data)#
            }#
          }#
	fit <- lm(#
	reformulate(#
		response = "PRIMARY_OUTCOME",#
		termlabels = c(DEMO.CHILDHOOD.PRED[keep.var], "FOCAL_PREDICTOR")#
		), tmp.data#
	)#
	c(fit$coefficients["FOCAL_PREDICTOR"], se(fit)["FOCAL_PREDICTOR"])#
}) |>bind_rows(.id="COUNTRY")
fit.res <- map(country.vec, \(x){#
	tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x)#
	tmp.data$PRIMARY_OUTCOME <- scale(tmp.data[[OUTCOME.VEC0[73]]])#
	tmp.data$FOCAL_PREDICTOR <- scale(tmp.data[[FOCAL_PREDICTOR]])#
          keep.var <- rep(FALSE, length(DEMO.CHILDHOOD.PRED))#
          for(i in 1:length(keep.var)){#
            if(DEMO.CHILDHOOD.PRED[i] %in% colnames(tmp.data)){#
              keep.var[i] <- keep_variable(DEMO.CHILDHOOD.PRED[i], data = tmp.data)#
            }#
          }#
	fit <- lm(#
	reformulate(#
		response = "PRIMARY_OUTCOME",#
		termlabels = c(DEMO.CHILDHOOD.PRED[keep.var], "FOCAL_PREDICTOR")#
		), tmp.data#
	)#
	as.numeric(c(fit$coefficients["FOCAL_PREDICTOR"], se(fit)["FOCAL_PREDICTOR"]))#
}) |>bind_rows(.id="COUNTRY")
fit$coefficients["FOCAL_PREDICTOR"]
se(fit)["FOCAL_PREDICTOR"]
fit.res
country.vec
country.vec <- sort(as.character(unique(df.raw.cca$COUNTRY)))
names(country.vec) <- country.vec
fit.res <- map(country.vec, \(x){#
	tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x)#
	tmp.data$PRIMARY_OUTCOME <- scale(tmp.data[[OUTCOME.VEC0[73]]])#
	tmp.data$FOCAL_PREDICTOR <- scale(tmp.data[[FOCAL_PREDICTOR]])#
          keep.var <- rep(FALSE, length(DEMO.CHILDHOOD.PRED))#
          for(i in 1:length(keep.var)){#
            if(DEMO.CHILDHOOD.PRED[i] %in% colnames(tmp.data)){#
              keep.var[i] <- keep_variable(DEMO.CHILDHOOD.PRED[i], data = tmp.data)#
            }#
          }#
	fit <- lm(#
	reformulate(#
		response = "PRIMARY_OUTCOME",#
		termlabels = c(DEMO.CHILDHOOD.PRED[keep.var], "FOCAL_PREDICTOR")#
		), tmp.data#
	)#
	c(est = fit$coefficients["FOCAL_PREDICTOR"], se = se(fit)["FOCAL_PREDICTOR"])#
}) |>bind_rows(.id="COUNTRY")
fit.res
library(metafor)
colnames(fit.res) <- c("COUNTRY", "est", "se")
rma(yi=fit.res$est, sei = fit.res$se)
country.vec <- sort(as.character(unique(df.raw.cca$COUNTRY)))#
names(country.vec) <- country.vec#
fit.res <- map(country.vec, \(x){#
	tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x)#
	tmp.data$PRIMARY_OUTCOME <- scale(tmp.data[[OUTCOME.VEC0[73]]])#
	tmp.data$FOCAL_PREDICTOR <- scale(tmp.data[[FOCAL_PREDICTOR]])#
          keep.var <- rep(FALSE, length(DEMO.CHILDHOOD.PRED))#
          for(i in 1:length(keep.var)){#
            if(DEMO.CHILDHOOD.PRED[i] %in% colnames(tmp.data)){#
              keep.var[i] <- keep_variable(DEMO.CHILDHOOD.PRED[i], data = tmp.data)#
            }#
          }#
	fit <- lm(#
	reformulate(#
		response = "PRIMARY_OUTCOME",#
		termlabels = c(DEMO.CHILDHOOD.PRED[keep.var], "FOCAL_PREDICTOR")#
		), tmp.data#
	)#
	c(est = fit$coefficients["FOCAL_PREDICTOR"], se = se(fit)["FOCAL_PREDICTOR"], n = nrow(tmp.data))#
}) |>bind_rows(.id="COUNTRY")#
#
colnames(fit.res) <- c("COUNTRY", "est", "se", "n")#
#
library(metafor)#
#
rma(yi=fit.res$est, sei = fit.res$se)
fit.res
sum(fit.res$n)
fit
fit$df.residual
N = nrow(na.omit(tmp.data[,c("PRIMARY_OUTCOME", DEMO.CHILDHOOD.PRED[keep.var], "FOCAL_PREDICTOR")]))
N
country.vec <- sort(as.character(unique(df.raw.cca$COUNTRY)))#
names(country.vec) <- country.vec#
fit.res <- map(country.vec, \(x){#
	tmp.data <- df.raw.cca %>%#
	filter(COUNTRY == x)#
	tmp.data$PRIMARY_OUTCOME <- scale(tmp.data[[OUTCOME.VEC0[73]]])#
	tmp.data$FOCAL_PREDICTOR <- scale(tmp.data[[FOCAL_PREDICTOR]])#
          keep.var <- rep(FALSE, length(DEMO.CHILDHOOD.PRED))#
          for(i in 1:length(keep.var)){#
            if(DEMO.CHILDHOOD.PRED[i] %in% colnames(tmp.data)){#
              keep.var[i] <- keep_variable(DEMO.CHILDHOOD.PRED[i], data = tmp.data)#
            }#
          }#
    N = nrow(na.omit(tmp.data[,c("PRIMARY_OUTCOME", DEMO.CHILDHOOD.PRED[keep.var], "FOCAL_PREDICTOR")]))#
	fit <- lm(#
	reformulate(#
		response = "PRIMARY_OUTCOME",#
		termlabels = c(DEMO.CHILDHOOD.PRED[keep.var], "FOCAL_PREDICTOR")#
		), tmp.data#
	)#
	c(est = fit$coefficients["FOCAL_PREDICTOR"], se = se(fit)["FOCAL_PREDICTOR"], n = N)#
}) |>bind_rows(.id="COUNTRY")#
#
colnames(fit.res) <- c("COUNTRY", "est", "se", "n")#
sum(fit.res$n)
rma(yi=fit.res$est, sei = fit.res$se)
# Add the directory where the dataset is stored on your computer#
data.dir <- "/Users/noahp/Documents/GitHub/global-flourishing-study/data/wave2-data"#
dataset.name <- "gfs_all_countries_wave2.sav"#
#
# Specify where you want to output results#
# Can be left blank, and the results will output to the same directory as the data.#
out.dir <- getwd()#
#
# Here is YOUR wave 1 construct variable#
FOCAL_PREDICTOR <- c("PHYSICAL_HLTH_Y1")#
FOCAL_PREDICTOR_BETTER_NAME <- c("Self-rated physical health")#
FOCAL_PREDICTOR_REFERENCE_VALUE <- c("mean rating within country")#
#
# IF your predictor (focal exposure) is binary/categorical, use the code below to define how you#
#   want it to be categorized. Categorization must result in a binary variable 0/1 for#
#   consistency across studies.#
VALUES_DEFINING_UPPER_CATEGORY <- list(NA)#
VALUES_DEFINING_LOWER_CATEGORY <- list(NA)#
# Note 1: if your focal predictor is continuous (all items with 7+ response options), you can force the responses#
# 	to be categorized as 0/1 using the above with the below option changed to TRUE. This can be useful#
# 	when testing the sensitivity of results or for composite outcomes such as anxiety (sum of#
#   feel_anxious and control_worry)  or depression (sum of depressed and interest) that have a#
# 	history of being dichotomized.#
FORCE_BINARY <- c(FALSE)#
# Note 2: if your focal predictor is categorical/binary, you can use the responses as if they were continuous.#
# 	The provided (straightforward-ish) approach implemented is to reverse code all#
#   ordered-categorical variables (reverse code from what is reported in the codebook), and#
#   standardized as if continuous. This approach is not applicable for variables with nominal#
#   response categories such as employment. This is employed using the option below.#
FORCE_CONTINUOUS <- c(FALSE)#
# Note 3: if you need to define a subpopulation for domain analysis. (in-development)#
SUBPOPULATION <- list(NULL)#
#
names(FORCE_CONTINUOUS) <- names(FORCE_BINARY) <- names(VALUES_DEFINING_UPPER_CATEGORY)  <- names(VALUES_DEFINING_LOWER_CATEGORY) <- names(SUBPOPULATION) <- FOCAL_PREDICTOR#
# ================================================================================================ ##
# ================================================================================================ ##
# Data Prep#
#
if (is.null(out.dir)) {#
  out.dir <- data.dir#
}#
setwd(out.dir)#
# Note:#
# The following function loads the required packages for the remainder of the script to work.#
load_packages()#
# global options#
options(#
  survey.lonely.psu = "certainty"#
)#
# outcome vectors#
LIST.COMPOSITES <- get_variable_codes('LIST.COMPOSITES')#
RECODE.DEFAULTS <- list(#
  FOCAL_PREDICTOR = FOCAL_PREDICTOR,#
  DEMOGRAPHICS.CHILDHOOD.PRED.VEC = c(#
    get_variable_codes("GENDER.RACE", appnd=""),#
    get_variable_codes("DEMOGRAPHIC.VARS", appnd="_Y1"),#
    get_variable_codes("RETROSPECTIVE.VARS", appnd="_Y1")#
  ),#
  VARIABLES.VEC = c(get_variable_codes("VARS.Y1"), get_variable_codes("VARS.Y2")),#
  FORCE_BINARY = FORCE_BINARY,#
  FORCE_CONTINUOUS = FORCE_CONTINUOUS,#
  VALUES_DEFINING_UPPER_CATEGORY = VALUES_DEFINING_UPPER_CATEGORY,#
  VALUES_DEFINING_LOWER_CATEGORY = VALUES_DEFINING_LOWER_CATEGORY,#
  USE_DEFAULT = !(FORCE_BINARY | FORCE_CONTINUOUS)#
)#
#
# get "raw data"#
df.raw <- gfs_get_labelled_raw_data(#
  file = here::here(data.dir, dataset.name),#
  list.composites = LIST.COMPOSITES#
)
run.imp <- TRUE#
  if (run.imp) {#
    pred0 <- c(#
      'ANNUAL_WEIGHT_R2', 'MODE_RECRUIT',#
      'AGE_Y1', 'GENDER_Y1', 'RACE_PLURALITY1', 'MARITAL_STATUS_Y1',#
      'EMPLOYMENT_Y1', 'EDUCATION_3_Y1', 'ATTEND_SVCS_Y1',#
      'URBAN_RURAL_Y1', 'BORN_COUNTRY_Y1', 'REL2_Y1',#
      'ABUSED_Y1', 'OUTSIDER_Y1',#
      'HEALTH_GROWUP_Y1', 'INCOME_12YRS_Y1',#
      'FATHER_RELATN_Y1', 'MOTHER_RELATN_Y1',#
      'PARENTS_12YRS_Y1'#
    )#
    df.imp <- run_impute_data(#
      data =  df.raw,#
      data.dir = data.dir,#
      Nimp = 5,#
      Miter = 2,#
      pred.vars = pred0#
    )#
  }#
# ================================================================================================ ##
# ================================================================================================ ##
# Recode the imputed data for easily use in analyses#
  # ~~#
  recode_imp_by_country(#
    data.dir,#
    list.default = RECODE.DEFAULTS,#
    list.composites = LIST.COMPOSITES,#
    wgt = "ANNUAL_WEIGHT_R2",#
    .nimp = 2#
  )#
# ================================================================================================ ##
# ================================================================================================ ##
# CHECK VARIABLE CODING/COLLAPSING#
##
# the following checks the imputed data back with the raw data#
tmp.dat1 <- df.raw %>%#
  filter(COUNTRY == "United States") %>%#
  arrange(ID)#
tmp.dat2 <- readr::read_rds(here::here(data.dir, "recoded_imputed_data_obj_United States.rds")) %>%#
  filter(.imp == 1) %>%#
  arrange(ID)#
dnn0 <- c("Raw Data", "Recoded Imputed Data (.imp==1)")#
for(i in 1:length(FOCAL_PREDICTOR)){#
  print(FOCAL_PREDICTOR[i])#
  print(table(tmp.dat1[[FOCAL_PREDICTOR[i]]], tmp.dat2[[FOCAL_PREDICTOR[i]]], dnn = dnn0, useNA = "ifany"))#
}#
#
# ================================================================================================ ##
# ================================================================================================ ##
# Attrition Weights#
run_attrition_model_by_country(#
  data.dir,#
  obs.id.var = "CASE_OBSERVED_Y2",#
  attr.pred = c(#
    "ANNUAL_WEIGHT_R2", "MODE_RECRUIT",#
    'COMPOSITE_HAPPI_LIFE_SAT_Y1', 'COMPOSITE_HEALTH_Y1', 'COMPOSITE_MEANING_PURPOSE_Y1',#
    'COMPOSITE_CHARACTER_Y1', 'COMPOSITE_SUBJECTIVE_SOC_CONN_Y1', 'COMPOSITE_FINL_MAT_WORRY_Y1',#
    'COMPOSITE_EXTRAVERSION_Y1', 'COMPOSITE_OPENNESS_Y1', 'COMPOSITE_AGREEABLENESS_Y1',#
    'COMPOSITE_CONSCIENTIOUSNESS_Y1', 'COMPOSITE_NEUROTICISM_Y1',#
    'COMPOSITE_DEPRESSION_Y1', 'COMPOSITE_ANXIETY_Y1', 'LONELY_Y1', 'DAYS_EXERCISE_Y1',#
    'COV_AGE_GRP_Y1', 'COV_GENDER', 'COV_MARITAL_STATUS_Y1', 'COV_EMPLOYMENT_Y1',#
    'COV_ATTEND_SVCS_Y1', 'COV_EDUCATION_3_Y1', 'COV_BORN_COUNTRY_Y1', "COV_RACE_PLURALITY",#
    "COV_URBAN_RURAL_Y1", 'COV_INCOME_Y1'#
  ),#
  wgt = "ANNUAL_WEIGHT_R2", strata = "STRATA", psu = "PSU"#
)#
#
## append attrition weights to imputed data#
append_attr_wgts_to_imp_data(data.dir, attr.dir = "results-attr")#
# ================================================================================================ ##
# ================================================================================================ ##
# Run primary country-wise analyses -- Full imputation based approach#
#
VARIABLES.VEC <- RECODE.DEFAULTS[['VARIABLES.VEC']]#
OUTCOME.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "_Y2")]#
CONTEMPORANEOUS.EXPOSURES.VEC <- VARIABLES.VEC[str_detect(VARIABLES.VEC, "COMPOSITE", negate = TRUE)]#
CONTEMPORANEOUS.EXPOSURES.VEC <- CONTEMPORANEOUS.EXPOSURES.VEC[str_detect(CONTEMPORANEOUS.EXPOSURES.VEC, "_Y1")]#
DEMO.CHILDHOOD.PRED <- c(#
  "COV_AGE_GRP_Y1",#
  "COV_GENDER_Y1",#
  "COV_EDUCATION_3_Y1",#
  "COV_EMPLOYMENT_Y1",#
  "COV_MARITAL_STATUS_Y1",#
  "COV_ATTEND_SVCS_Y1",#
  "COV_BORN_COUNTRY_Y1",#
  "COV_PARENTS_12YRS_Y1",#
  "COV_SVCS_12YRS_Y1",#
  "COV_MOTHER_RELATN_Y1",#
  "COV_FATHER_RELATN_Y1",#
  "COV_OUTSIDER_Y1",#
  "COV_ABUSED_Y1",#
  "COV_HEALTH_GROWUP_Y1",#
  "COV_INCOME_12YRS_Y1",#
  "COV_REL1_Y1",#
  "COV_RACE_PLURALITY",#
  "COV_MOTHER_NA",#
  "COV_FATHER_NA"#
)#
# Run country-specific regression analyses for ALL wave 2 outcomes#
OUTCOME.VEC0 <- OUTCOME.VEC # c(1, 8, 24)+76,#
your.outcome <- OUTCOME.VEC0[2]#
#
# Model 1: Run without principal components#
LIST.RES <- map(OUTCOME.VEC0, \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      wgt = ANNUAL_WEIGHT_R2, # wgt = as.name("ANNUAL_WEIGHT_R2")#
      psu = PSU, #psu = as.name("PSU")#
      strata = STRATA, # strata = as.name("STRATA")#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.rule = "omit",#
      res.dir = "results-primary",#
      appnd.txt.to.filename = "_primary_wopc"#
    )#
  }) }, .progress = TRUE)#
LIST.RES <- construct_meta_input_from_saved_results("results-primary", OUTCOME.VEC0, FOCAL_PREDICTOR, appnd.txt = "_primary_wopc")#
meta.input <- LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
#
META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Excluded -- Full Imputation Approach"#
)#
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-primary", "0_meta_analyzed_results_primary_wopc.rds"),#
  compress = "gz"#
)#
remove(LIST.RES, meta.input, META.RES)#
#
# Model 2: Run with principal components#
LIST.RES <- map(OUTCOME.VEC0, \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      wgt = ANNUAL_WEIGHT_R2, # wgt = as.name("ANNUAL_WEIGHT_R2")#
      psu = PSU, #psu = as.name("PSU")#
      strata = STRATA, # strata = as.name("STRATA")#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.cutoff = 7,#
      pc.rule = "constant",#
      res.dir = "results-primary",#
      appnd.txt.to.filename = "_primary_wpc"#
    )#
  }) }, .progress = TRUE)#
#
LIST.RES <- construct_meta_input_from_saved_results("results-primary", OUTCOME.VEC0, FOCAL_PREDICTOR, appnd.txt = "_primary_wpc")#
meta.input <- LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
#
META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Included -- Full Imputation Approach"#
)#
#
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-primary","0_meta_analyzed_results_primary_wpc.rds"),#
  compress = "gz"#
)#
remove(meta.input, LIST.RES, META.RES)#
#
# ================================================================================================ ##
# ================================================================================================ ##
# Run supplemental country-wise analyses -- "Complete Case Analysis"#
# - Uses attrition-weight adjusted sampling weights#
#
# Supplemental analysis set 1: Run without principal components#
SUPP.LIST.RES <- map(OUTCOME.VEC0, \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      direct.subset = expr(CASE_OBSERVED_Y2 == 1),#
      wgt = SAMP.ATTR.WGT,#
      psu = PSU,#
      strata = STRATA,#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.rule = "omit",#
      res.dir = "results-cca",#
      appnd.txt.to.filename = "_cca_wopc"#
    )#
  }) }, .progress = TRUE)#
#SUPP.LIST.RES <- construct_meta_input_from_saved_results("results-cca", OUTCOME.VEC0, FOCAL_PREDICTOR, appnd.txt = "_cca_wopc")#
meta.input <- SUPP.LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
SUPP.META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Excluded -- Complete Case Analysis"#
)#
readr::write_rds(#
  SUPP.META.RES,#
  file = here::here(out.dir, "results-cca", "0_meta_analyzed_results_cca_wopc.rds"),#
  compress = "gz"#
)#
remove(meta.input, SUPP.LIST.RES, SUPP.META.RES)#
#
# Analysis set 2: Run with principal components#
SUPP.LIST.RES <- map(OUTCOME.VEC0, \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      direct.subset = expr(CASE_OBSERVED_Y2 == 1),#
      wgt = SAMP.ATTR.WGT,#
      psu = PSU,#
      strata = STRATA,#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = TRUE,#
      pc.cutoff = 7,#
      pc.rule = "constant",#
      res.dir = "results-cca",#
      appnd.txt.to.filename = "_cca_wpc"#
    )#
  }) }, .progress = TRUE)#
SUPP.LIST.RES <- construct_meta_input_from_saved_results(res.dir="results-cca", outcomes=OUTCOME.VEC0, predictors=FOCAL_PREDICTOR, appnd.txt = "_cca_wpc")#
meta.input <- SUPP.LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
SUPP.META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Included -- Complete Case Analysis"#
)#
readr::write_rds(#
  SUPP.META.RES,#
  file = here::here(out.dir, "results-cca", "0_meta_analyzed_results_cca_wpc.rds"),#
  compress = "gz"#
)#
remove(meta.input, SUPP.LIST.RES, SUPP.META.RES)#
#
# ================================================================================================ ##
# ================================================================================================ ##
# Re-run primary analysis but get UNSTANDARDIZED estimated#
#
# Model 1: Run without principal components#
LIST.RES <- map(OUTCOME.VEC0, \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      wgt = ANNUAL_WEIGHT_R2, # wgt = as.name("ANNUAL_WEIGHT_R2")#
      psu = PSU, #psu = as.name("PSU")#
      strata = STRATA, # strata = as.name("STRATA")#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = FALSE,#
      pc.rule = "omit",#
      res.dir = "results-unstd",#
      appnd.txt.to.filename = "_unstd_wopc"#
    )#
  }) }, .progress = TRUE)#
#LIST.RES <- construct_meta_input_from_saved_results("results-unstd", OUTCOME.VEC0, FOCAL_PREDICTOR, appnd.txt = "_unstd_wopc")#
meta.input <- LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
#
META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Excluded -- Unstandardized Results"#
)#
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-unstd", "0_meta_analyzed_results_unstd_wopc.rds"),#
  compress = "gz"#
)#
remove(LIST.RES, meta.input, META.RES)#
#
# Model 2: Run with principal components#
LIST.RES <- map(OUTCOME.VEC0, \(x){#
  map(FOCAL_PREDICTOR, \(y){#
    gfs_run_regression_single_outcome(#
      your.outcome = x,#
      your.pred = y,#
      data.dir = data.dir,#
      wgt = ANNUAL_WEIGHT_R2,#
      psu = PSU,#
      strata = STRATA,#
      covariates = DEMO.CHILDHOOD.PRED,#
      contemporaneous.exposures = CONTEMPORANEOUS.EXPOSURES.VEC,#
      list.composites = LIST.COMPOSITES[[1]],#
      standardize = FALSE,#
      pc.cutoff = 7,#
      pc.rule = "constant",#
      res.dir = "results-unstd",#
      appnd.txt.to.filename = "_unstd_wpc"#
    )#
  }) }, .progress = TRUE)#
#
LIST.RES <- construct_meta_input_from_saved_results("results-unstd", OUTCOME.VEC0, FOCAL_PREDICTOR, appnd.txt = "_unstd_wpc")#
meta.input <- LIST.RES %>%#
  bind_rows() %>%#
  mutate(#
    OUTCOME0 = OUTCOME,#
    FOCAL_PREDICTOR0 = FOCAL_PREDICTOR#
  ) %>%#
  group_by(OUTCOME0, FOCAL_PREDICTOR0) %>%#
  nest()#
#
META.RES <- gfs_meta_analysis(#
  meta.input,#
  p.subtitle = "Principal Components Included -- Unstandardized Results"#
)#
#
readr::write_rds(#
  META.RES,#
  file = here::here(out.dir, "results-unstd","0_meta_analyzed_results_unstd_wpc.rds"),#
  compress = "gz"#
)#
remove(meta.input, LIST.RES, META.RES)
